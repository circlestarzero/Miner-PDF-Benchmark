Visual Presentation for the Web



# The Definitive Guide 



## CSS: The Definitive Guide



Want to achieve sophisticated web page styling while saving time and effort? CSS: The Definitive Guide, Third Edition, shows you how to put every aspect of cascading style sheets into practice according to the latest specifications, CSS2 and CSS2.1. Through the many examples provided, you'll learn to create or change the appearance of an entire web site in just one place, and achieve a much richer presentation than is possible with HTML.

Noted CSS expert Eric A. Meyer uses his trademark wit and breadth of experience to explore properties, tags, attributes, and implementation, as well as real-life issues such as browser support and design guidelines. All you need is knowledge of HTML 4.0 to create clean, easy-to-maintain scripts for web site layout and pagination with the same elegance and control of desktop publishing. You'll learn about:

- Styling text in sophisticated ways
- User interface, table layout, lists, and generated content
- The ins and outs of floating and positioning
- Font families and fallbacks
- How the box model works
- New CSS3 selectors supported by IE7, Firefox, and other browsers

Thoroughly updated to cover Internet Explorer 7, this new edition of CSS: The Definitive Guide covers in detail each individual CSS property and how it interacts with others, and teaches you how to avoid common mistakes in interpretation. Whether you're an experienced web author or a complete novice, this is your complete CSS sourcebook.

Eric A. Meyer is an internationally recognized expert on the subjects of HTML, CSS, and web standards who has worked with the Web since 1993. He's also the founder of Complex Spiral Consulting, which includes among its clients America Online, Apple Computer, Wells Fargo Bank, and Macromedia.

www.oreilly.com

US $\$ 44.99$

CAN $\$ 58.99$

ISBN-10: $0-596-52733-0$

ISBN-13: $978-0-596-52733-4$

CSS

The Definitive Guide

## Other resources from 0'Reilly



Related titles HTML \& XHTML: The

Definitive Guide

JavaScript: The Definitive

Guide

Learning JavaScript

Dynamic HTML: The<br>Definitive Reference<br>JavaScript \& DHTML<br>Cookbook $^{\mathrm{m}}$<br>Web Design in a Nutshell

oreilly.com oreilly.com is more than a complete catalog of O'Reilly books. You'll also find links to news, events, articles, weblogs, sample chapters, and code examples.

oreillynet.com is the essential portal for developers interested in open and emerging technologies, including new platforms, programming languages, and operating systems.

Conferences O'Reilly brings diverse innovators together to nurture the ideas that spark revolutionary industries. We specialize in documenting the latest tools and systems, translating the innovator's knowledge into useful skills for those in the trenches. Visit conferences.oreilly.com for our upcoming events.

Safari Bookshelf (safari.oreilly.com) is the premier online reference library for programmers and IT professionals. Conduct searches across more than 1,000 books. Subscribers can zero in on answers to time-critical questions in a matter of seconds. Read the books on your Bookshelf from cover to cover or simply flip to the page you need. Try it today for free.

## THIRD EDITION

CSS

## The Definitive Guide

Eric A. Meyer

## CSS: The Definitive Guide, Third Edition

by Eric A. Meyer

Copyright (C) 2007, 2004, 2000 O’Reilly Media, Inc. All rights reserved.

Printed in the United States of America.

Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.

O'Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also available for most titles (safari.oreilly.com). For more information, contact our corporate/institutional sales department: (800)998-9938 or corporate@oreilly.com.

Editor: Tatiana Apandi

Production Editor: Rachel Monaghan

Copyeditor: Rachel Monaghan

Proofreader: Laurel R.T. Ruma
Indexer: Reg Aubry

Cover Designer: Karen Montgomery

Interior Designer: David Futato

Illustrators: Robert Romano and Jessamyn Read

## Printing History:

May 2000: $\quad$ First Edition.

March 2004: $\quad$ Second Edition.

November 2006: Third Edition.

Nutshell Handbook, the Nutshell Handbook logo, and the O'Reilly logo are registered trademarks of O'Reilly Media, Inc. CSS: The Definitive Guide, the image of salmon, and related trade dress are trademarks of O'Reilly Media, Inc.

Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and O'Reilly Media, Inc. was aware of a trademark claim, the designations have been printed in caps or initial caps.

While every precaution has been taken in the preparation of this book, the publisher and author assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.

$\xrightarrow{\text { RepKover }}$ This book uses RepKover,' a durable and flexible lay-flat binding.

To my wife and daughter

and all the joys they bring me.

## Table of Contents

Preface ..... xi

1. CSS and Documents ..... 1
The Web's Fall from Grace ..... 1
CSS to the Rescue ..... 3
Elements ..... 8
Bringing CSS and XHTML Together ..... 11
2. Selectors ..... 23
Basic Rules ..... 23
Grouping ..... 27
Class and ID Selectors ..... 31
Attribute Selectors ..... 38
Using Document Structure ..... 44
Pseudo-Classes and Pseudo-Elements ..... 51
3. Structure and the Cascade ..... 62
Specificity ..... 62
Inheritance ..... 68
The Cascade ..... 71
4. Values and Units ..... 77
Numbers ..... 77
Percentages ..... 77
Color ..... 78
Length Units ..... 83
URLS ..... 90
CSS2 Units ..... 92
5. Fonts ..... 94
Font Families ..... 95
Font Weights ..... 100
Font Size ..... 106
Styles and Variants ..... 114
Stretching and Adjusting Fonts ..... 117
The font Property ..... 120
Font Matching ..... 124
6. Text Properties ..... 128
Indentation and Horizontal Alignment ..... 128
Vertical Alignment ..... 134
Word Spacing and Letter Spacing ..... 143
Text Transformation ..... 146
Text Decoration ..... 148
Text Shadows ..... 152
7. Basic Visual Formatting ..... 158
Basic Boxes ..... 158
Block-Level Elements ..... 161
Inline Elements ..... 179
Altering Element Display ..... 198
8. Padding, Borders, and Margins ..... 207
Basic Element Boxes ..... 207
Margins ..... 211
Borders ..... 223
Padding ..... 238
9. Colors and Backgrounds ..... 246
Colors ..... 246
Foreground Colors ..... 248
Backgrounds ..... 253
10. Floating and Positioning ..... 283
Floating ..... 283
Positioning ..... 302
11. Table Layout ..... 339
Table Formatting ..... 339
Table Cell Borders ..... 352
Table Sizing ..... 359
12. Lists and Generated Content ..... 370
Lists ..... 370
Generated Content ..... 378
13. User Interface Styles ..... 395
System Fonts and Colors ..... 395
Cursors ..... 400
Outlines ..... 404
14. Non-Screen Media ..... 411
Designating Medium-Specific Style Sheets ..... 411
Paged Media ..... 413
Aural Styles ..... 429
A. Property Reference ..... 449
B. Selector, Pseudo-Class, and
Pseudo-Element Reference ..... 491
C. Sample HTML 4 Style Sheet ..... 499
Index ..... 503

## Preface

If you are a web designer or document author interested in sophisticated page styling, improved accessibility, and saving time and effort, this book is for you. All you really need before starting the book is a decent knowledge of HTML 4.0. The better you know HTML, of course, the better prepared you'll be. You will need to know very little else to follow this book.

This third edition of CSS: The Definitive Guide covers CSS2 and CSS2.1 (up through the 11 April 2006 Working Draft), the latter of which is, in many ways, a clarification of the first. While some CSS3 modules have reached Candidate Recommendation status as of this writing, I have chosen not to cover them in this edition (with the exception of some CSS3 selectors). I made this decision because implementation of these modules is still incomplete or nonexistent. I feel it's important to keep the book focused on currently supported and well-understood levels of CSS, and to leave any future capabilities for future editions.

## Conventions Used in This Book

The following typographical conventions are used in this book:

Italic

Indicates new terms, URLs, variables in text, user-defined files and directories, commands, file extensions, filenames, directory or folder names, and UNC pathnames.

Constant width

Indicates command-line computer output, code examples, Registry keys, and keyboard accelerators.

## Constant width bold

Indicates user input in examples.

Constant width italic

Indicates variables in examples and in Registry keys. It is also used to indicate variables or user-defined elements within italic text (such as pathnames or filenames). For instance, in the path $\backslash$ Windowslusername, replace username with your name.



This icon signifies a tip, suggestion, or general note.

This icon indicates a warning or caution.

## Property Conventions

Throughout this book, there are boxes that break down a given CSS property. These have been reproduced practically verbatim from the CSS specifications, but some explanation of the syntax is in order.

Throughout, the allowed values for each property are listed with the following syntax:

Value: $[<$ length $>\mid$ thick $\mid$ thin $]\{1,4\}$

Value: [<family-name>, $]^{*}<$ family-name>

Value: <url>? <color> [ / <color> ]?

Value: <url> || <color>

Any words between " $<$ " and ">" give a type of value or a reference to another property. For example, the property font will accept values that actually belong to the property font-family. This is denoted by the text <font-family>. Any words presented in constant width are keywords that must appear literally, without quotes. The forward slash (/) and the comma (,) must also be used literally.

Several keywords strung together means that all of them must occur in the given order. For example, help me means that the property must use those keywords in that exact order.

If a vertical bar separates alternatives $(\mathrm{X} \mid \mathrm{Y})$, then any one of them must occur. A vertical double bar (X $\| \mathrm{Y})$ means that $\mathrm{X}$, $\mathrm{Y}$, or both must occur, but they may appear in any order. Brackets ([...]) are for grouping things together. Juxtaposition is stronger than the double bar, and the double bar is stronger than the bar. Thus "V $\mathrm{W} \mid \mathrm{X} \| \mathrm{Y} \mathrm{Z}$ " is equivalent to "[ $\mathrm{VW}] \mid[\mathrm{X} \|[\mathrm{Y} \mathrm{Z}]]$ ".

Every word or bracketed group may be followed by one of the following modifiers:

- An asterisk $(*)$ indicates that the preceding value or bracketed group is repeated zero or more times. Thus, bucket* means that the word bucket can be used any number of times, including zero. There is no upper limit defined on the number of times it can be used.
- A plus (+) indicates that the preceding value or bracketed group is repeated one or more times. Thus, mop+ means that the word mop must be used at least once, and potentially many more times.
- A question mark (?) indicates that the preceding value or bracketed group is optional. For example, [pine tree]? means that the words pine tree need not be used (although they must appear in that exact order if they are used).
- A pair of numbers in curly braces $(\{M, N\})$ indicates that the preceding value or bracketed group is repeated at least $M$ and at most $N$ times. For example, ha $\{1,3\}$ means that there can be one, two, or three instances of the word ha.

Some examples follow:

give || me || liberty

At least one of the three words must be used, and they can be used in any order. For example, give liberty, give me, liberty me give, and give me liberty are all valid.

[ I | am ]? the || walrus

Either the word I or am may be used, but not both, and use of either is optional. In addition, either the or walrus, or both, must follow in any order. Thus, you could construct I the walrus, am walrus the, am the, I walrus, walrus the, and so forth.

koot ka-choo

One or more instances of koo must be followed by ka-choo. Therefore, koo koo ka-choo, koo koo koo ka-choo, and koo ka-choo are all legal. The number of koos is potentially infinite, although there are bound to be implementation-specific limits.

I really $\{1,4\}$ ? [love | hate] [Microsoft | Netscape | Opera | Safari]

This is the all-purpose web designer's opinion expresser. This example can be interpreted as I love Netscape, I really love Microsoft, and similar expressions. Anywhere from zero to four reallys may be used. You also get to pick between love and hate, even though only love was shown in this example.

[[Alpha || Baker || Cray],]\{2,3\} and Delphi

This is a potentially long and complicated expression. One possible result would be Alpha, Cray, and Delphi. The comma is placed because of its position within the nested bracket groups.

## Using Code Examples

This book is here to help you get your job done. In general, you may use the code in this book in your programs and documentation. You do not need to contact us for permission unless you're reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O'Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product's documentation does require permission.

We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: "CSS: The Definitive Guide, Third Edition, by Eric A. Meyer. Copyright 2007 O’Reilly Media, Inc., 978-0-596-52733-4.”

If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.

## How to Contact Us

We at O'Reilly have tested and verified the information in this book to the best of our ability, but you may find that features have changed (or even that we have made mistakes!). Please let us know about any errors you find, as well as your suggestions for future editions, by writing to:

O'Reilly Media, Inc.

1005 Gravenstein Highway North

Sebastopol, CA 95472

800-998-9938 (in the United States or Canada)

707-829-0515 (international or local)

707-829-0104 (fax)

There is a web page for this book, which lists errata, examples, or any additional information. You can access this page at:

http://www.oreilly.com/catalog/csstdg3

To comment or ask technical questions about this book, send email to:

bookquestions@oreilly.com

For more information about books, conferences, Resource Centers, and the O'Reilly Network, see the O'Reilly web site at:

http://www.oreilly.com

## Safari ${ }^{\circledR}$ Enabled

When you see a Safari® Enabled icon on the cover of your favorite technology book, that means the book is available online through the O'Reilly Network Safari Bookshelf.

Safari offers a solution that's better than e-books. It's a virtual library that lets you easily search thousands of top tech books, cut and paste code samples, download chapters, and find quick answers when you need the most accurate, current information. Try it for free at http://safari.oreilly.com.

## Acknowledgments

I'd like to take a moment to thank the people who have backed me up during the long process of getting this book to its readers.

First, I'd like to thank everyone at O'Reilly for all they've done over the years, giving me my break into publishing and continuing to give me the opportunity to produce a book that matters. For this third edition, I'd like to thank Tatiana Apandi for her good humor, patience, and understanding as I played chicken with my deadlines.

I'd also like to thank most profoundly my technical reviewers. For the first edition, that was David Baron and Ian Hickson, with additional input from Bert Bos and Håkon Lie. The second edition was reviewed by Tantek Çelik and Ian Hickson. The fine folks who performed technical review on the third edition, the one you hold in your hands, were Darrell Austin, Liza Daly, and Neil Lee. All lent their considerable expertise and insight, keeping me honest and up-to-date on the latest changes in CSS as well as taking me to task for sloppy descriptions and muddled explanations. None of the editions, least of all this one, could have been as good as it is without their collective efforts, but of course whatever errors you find in the text are my fault, not theirs. That's kind of a cliché, I know, but it's true nonetheless.

Similarly, I'd like to thank everyone who pointed out errata that needed to be addressed. I may not have always been good about sending back email right away, but I read all of your questions and concerns and, when needed, made corrections. The continued feedback and constructive criticism will only help the book get better, as it always has.

There are a few personal acknowledgments to make as well.

To the staff of WRUW, 91.1 FM Cleveland, thank you for nine years of support, great music, and straight-out fun. Maybe one day I'll bring Big Band back to your airwaves, and maybe not; but either way, keep on keepin' on.

To Jeffrey Zeldman, thanks for being a great colleague and partner; and to the whole Zeldman family, thanks for being such wonderful friends.

To "Auntie" Molly, thanks for always being who you are.

To "Uncle" Jim, thanks for everything, both professionally and personally. It's no exaggeration to say I wouldn't be where I am without your influence, and our lives would be a good deal poorer without you around.

To the Bread and Soup Crew—Jim, Genevieve, Jim, Gini, Ferrett, Jen, Jenn, and Molly — thanks for all your superb cooking and tasty conversation.

To my extended family, thank you as always for your love and support.

To anyone I should have thanked, but didn't: my apologies. And my thanks.

And to my wife and daughter, more thanks than I can ever express for making my days richer than I have any right to expect, and for showering me with more love than I could ever hope to repay. Though I'll keep trying, of course.

-Eric A. Meyer

Cleveland Heights, Ohio

1 August 2006

## CHAPTER 1

## CSS and Documents

Cascading Style Sheets (CSS) are a powerful way to affect the presentation of a document or a collection of documents. Obviously, CSS is basically useless without a document of some sort, since it would have no content to present. Of course, the definition of "document" is extremely broad. For example, Mozilla and related browsers use CSS to affect the presentation of the browser chrome itself. Still, without the content of the chrome-buttons, address inputs, dialog boxes, windows, and so on-there would be no need for CSS (or any other presentational information).

## The Web's Fall from Grace

Back in the dimly remembered, early years of the Web (1990-1993), HTML was a fairly lean language. It was composed almost entirely of structural elements that were useful for describing things like paragraphs, hyperlinks, lists, and headings. It had nothing even remotely approaching tables, frames, or the complex markup we assume is necessary to create web pages. HTML was originally intended to be a structural markup language, used to describe the various parts of a document; very little was said about how those parts should be displayed. The language wasn't concerned with appearance - it was just a clean little markup scheme.

Then came Mosaic.

Suddenly, the power of the World Wide Web was obvious to almost anyone who spent more than 10 minutes playing with it. Jumping from one document to another was no more difficult than pointing the cursor at a specially colored bit of text, or even an image, and clicking the mouse. Even better, text and images could be displayed together, and all you needed to create a page was a plain-text editor. It was free, it was open, and it was cool.

Web sites began to spring up everywhere. There were personal journals, university sites, corporate sites, and more. As the number of sites increased, so did the demand for new HTML elements that would each perform a specific function. Authors started demanding that they be able to make text boldfaced or italicized.

At the time, HTML wasn't equipped to handle those sorts of desires. You could declare a bit of text to be emphasized, but that wasn't necessarily the same as being italicized - it could be boldfaced instead, or even normal text with a different color, depending on the user's browser and preferences. There was nothing to ensure that what the author created was what the reader would see.

As a result of these pressures, markup elements like <FONT> and <BIG> started to creep into the language. Suddenly, a structural language started to become presentational.

## What a Mess

Years later, we have inherited the problems of this haphazard process. Large parts of HTML 3.2 and HTML 4.0, for example, were devoted to presentational considerations. The ability to color and size text through the font element, to apply background colors and images to documents and tables, to use table attributes (such as cellspacing), and to make text blink on and off are all the legacy of the original cries for "more control!"

For an example of the mess in action, take a quick glance at almost any corporate web site's markup. The sheer amount of markup in comparison to actual useful information is astonishing. Even worse, for most sites, the markup is almost entirely comprised of tables and font elements, neither of which conveys any real semantic meaning as to what's being presented. From a structural standpoint, these pages are little better than random strings of letters.

For example, let's assume that for page titles, an author uses font elements instead of heading elements like h1:

<font size="+3" face="Helvetica" color="red">Page Title</font>

Structurally speaking, the font tag has no meaning. This makes the document far less useful. What good is a font tag to a speech-synthesis browser, for example? If an author uses heading elements instead of font elements, though, the speaking browser can use a certain speaking style to read the text. With the font tag, the browser has no way to know that the text is any different from other text.

Why do authors run roughshod over structure and meaning this way? Because they want readers to see the page as they designed it. To use structural HTML markup is to give up a lot of control over a page's appearance, and it certainly doesn't allow for the kind of densely packed page designs that have become so popular over the years. But consider the following problems with such an approach:

- Unstructured pages make content indexing inordinately difficult. A truly powerful search engine would allow users to search only page titles, or only section headings within pages, or only paragraph text, or perhaps only those paragraphs that are marked as important. To accomplish such a feat, however, the page contents must be contained within some sort of structural markup-exactly the sort of markup most pages lack. Google, for example, does pay attention to markup structure when indexing pages, so a structural page will increase your Google rank.
- Lack of structure reduces accessibility. Imagine that you are blind and rely on a speech-synthesis browser to search the Web. Which would you prefer: a structured page that lets your browser read only section headings so that you can choose which section you'd like to hear more about; or a page that is so lacking in structure that your browser is forced to read the entire thing with no indication of what's a heading, what's a paragraph, and what's important? Let's return to Google-the search engine is, in effect, the world's most active blind user, with millions of friends who accept its every suggestion about where to surf and shop.
- Advanced page presentation is possible only with some sort of document structure. Imagine a page in which only the section headings are shown, with an arrow next to each. The user can decide which section heading applies to him and click on it, thus revealing the text of that section.
- Structured markup is easier to maintain. How many times have you spent several minutes hunting through someone else's HTML (or even your own) in search of the one little error that's messing up your page in one browser or another? How much time have you spent writing nested tables and font elements, only to get a sidebar with white hyperlinks in it? How many linebreak elements have you inserted trying to get exactly the right separation between a title and the following text? By using structural markup, you can clean up your code and make it easier to find what you're looking for.

Granted, a fully structured document is a little plain. Due to that one single fact, a hundred arguments in favor of structural markup won't sway a marketing department from using the type of HTML that was so prevalent at the end of the 20th century, and which persists even today. What we need is a way to combine structural markup with attractive page presentation.

## CSS to the Rescue

Of course, the problem of polluting HTML with presentational markup was not lost on the World Wide Web Consortium (W3C), which began searching for a quick solution. In 1995, the consortium started publicizing a work-in-progress called CSS. By 1996, it had become a full Recommendation, with the same weight as HTML itself. Here's why.

## Rich Styling

In the first place, CSS allows for much richer document appearances than HTML ever allowed, even at the height of its presentational fervor. CSS lets you set colors on text and in the background of any element; permits the creation of borders around any element, as well as the increase or decrease of the space around them; lets you change the way text is capitalized, decorated (e.g., underlining), spaced, and even whether it is displayed at all; and allows you to accomplish many other effects.

Take, for example, the first (and main) heading on a page, which is usually the title of the page itself. The proper markup is:

<h1>Leaping Above The Water</h1>

Now, suppose you want this title to be dark red, use a certain font, be italicized and underlined, and have a yellow background. To do all of that with HTML, you'd have to put the h1 into a table and load it up with a ton of other elements like font and $U$. With CSS, all you need is one rule:

h1 \{color: maroon; font: italic 2em Times, serif; text-decoration: underline; background: yellow; $\}$

That's it. As you can see, everything you did in HTML can be done in CSS. There's no need to confine yourself to only those things HTML can do, however:

h1 \{color: maroon; font: italic 2em Times, serif; text-decoration: underline; background: yellow url(titlebg.png) repeat-x;

border: 1 px solid red; margin-bottom: 0; padding: $5 \mathrm{px} ;\}$

You now have an image in the background of the h1 that is only repeated horizontally, and a border around it, separated from the text by at least five pixels. You've also removed the margin (blank space) from the bottom of the element. These are feats that HTML can't even come close to matching — and that's just a taste of what CSS can do.

## Ease of Use

If the depth of CSS doesn't convince you, then perhaps this will: style sheets can drastically reduce a web author's workload.

First, style sheets centralize the commands for certain visual effects in one handy place, instead of scattering them throughout the document. As an example, let's say you want all of the h2 headings in a document to be purple. Using HTML, the way to do this would be to put a font tag in every heading, like so:

<h2><font color="purple">This is purple!</font></h2>

This must be done for every heading of level two. If you have 40 headings in your document, you have to insert 40 font elements throughout, one for each heading! That's a lot of work for one little effect.

Let's assume that you've gone ahead and put in all those font elements. You're done, you're happy-and then you decide (or your boss decides for you) that those h2 headings should really be dark green, not purple. Now you have to go back and fix every single one of those font elements. Sure, you might be able to find-and-replace, as long as headings are the only purple text in your document. If you've put other purple font elements in your document, then you can't find-and-replace because you'd affect those, too.

It would be much better to have a single rule instead:

h2 \{color: purple; \}

Not only is this faster to type, but it's easier to change. If you do switch from purple to dark green, all you have to change is that one rule.

Let's go back to the highly styled h1 element from the previous section:

h1 \{color: maroon; font: italic 2em Times, serif; text-decoration: underline; background: yellow; \}

This may look like it's worse to write than HTML, but consider a case where you have a page with about a dozen h2 elements that should look the same as the h1. How much markup will be required for those 12 h2 elements? A lot. On the other hand, with CSS, all you need to do is this:

h1, h2 \{color: maroon; font: italic 2em Times, serif; text-decoration: underline; background: yellow; $\}$

Now the styles apply to both $\mathrm{h} 1$ and $\mathrm{h} 2$ elements, with just three extra keystrokes.

If you want to change the way h1 and h2 elements look, the advantages of CSS are even more striking. Consider how long it would take to change the HTML markup for an $\mathrm{h} 1$ and $12 \mathrm{~h} 2$ elements, compared to changing the previous styles to this:

$$
\begin{aligned}
& \text { h1, h2 \{color: navy; font: bold 2em Helvetica, sans-serif; } \\
& \text { text-decoration: underline overline; background: silver; \} }
\end{aligned}
$$

If the two approaches were timed on a stopwatch, I'm betting the CSS-savvy author would easily beat the HTML jockey.

In addition, most CSS rules are collected into one location in the document. It is possible to scatter them throughout the document by grouping them into associated styles or individual elements, but it's usually far more efficient to place all of your styles into a single style sheet. This lets you create (or change) the appearance of an entire document in one place.

## Using Your Styles on Multiple Pages

But wait-there's more! Not only can you centralize all of the style information for a page in one place, but you can also create a style sheet that can then be applied to multiple pages. This is accomplished by a process in which a style sheet is saved to its own document and then imported by any page for use with that document. Using this capability, you can quickly create a consistent look for an entire web site. All you have to do is link the single style sheet to all of the documents on your web site. Then, if you ever want to change the look of your site's pages, you need only edit a single file and the change will be propagated throughout the entire server-automatically! Consider a site where all of the headings are gray on a white background. They get this color from a style sheet that says:

h1, h2, h3, h4, h5, h6 \{color: gray; background: white;\}

Now let's say this site has 700 pages, each of which uses the style sheet that says the headings should be gray. At some point, the site's webmaster decides that the headings should be white on a gray background. So she edits the style sheet to say:

h1, h2, h3, h4, h5, h6 \{color: white; background: gray;\}

Then she saves the style sheet to disk and the change is made. That sure beats having to edit 700 pages to enclose every heading in a table and a font tag, doesn't it?

## Cascading

That's not all! CSS also makes provisions for conflicting rules; these provisions are collectively referred to as the cascade. For instance, take the previous scenario in which you import a single style sheet into several web pages. Now inject a set of pages that share many of the same styles, but also include specialized rules that apply only to them. You can create another style sheet that is imported into those pages, in addition to the already existing style sheet, or you could just place the special styles into the pages that need them.

For example, on one page out of the 700, you might want headings to be yellow on dark blue instead of white on gray. In that single document, then, you could insert this rule:

h1, h2, h3, h4, h5, h6 \{color: yellow; background: blue; \}

Thanks to the cascade, this rule will override the imported rule for white-on-gray headings. By understanding the cascade rules and using them to your advantage, you can create highly sophisticated sheets that can be changed easily and come together to give your pages a professional look.

The power of the cascade is not confined to the author. Web surfers (or readers) can, in some browsers, create their own style sheets (called reader style sheets, obviously enough) that will cascade with the author's styles as well as the styles used by the browser. Thus, a reader who is colorblind could create a style that makes hyperlinks stand out:

a:link, a:visited \{color: white; background: black;\}

A reader style sheet can contain almost anything: a directive to make text large enough to read if the user has impaired vision, rules to remove images for faster reading and browsing, and even styles to place the user's favorite picture in the background of every document. (This isn't recommended, of course, but it is possible.) This lets readers customize their web experience without having to turn off all of the author's styles.

Between importing, cascading, and its variety of effects, CSS is a wonderful tool for any author or reader.

## Compact File Size

Besides the visual power of CSS and its ability to empower both author and reader, there is something else about it that your readers will like. It can help keep document sizes as small as possible, thereby speeding download times. How? As I've mentioned, a lot of pages have used tables and font elements to achieve nifty visual effects. Unfortunately, both of these methods create additional HTML markup that drives up the file sizes. By grouping visual style information into central areas and representing those rules using a fairly compact syntax, you can remove the font elements and other bits of the usual tag soup. Thus, CSS can keep your load times low and your reader satisfaction high.

## Preparing for the Future

HTML, as I pointed out earlier, is a structural language, while CSS is its complement: a stylistic language. Recognizing this, the W3C, the body that debates and approves standards for the Web, is beginning to remove stylistic elements from HTML. The reasoning for this move is that style sheets can be used to create the effects that certain HTML elements now provide, so who needs them?

Thus, the XHTML specification has a number of elements that are deprecated-that is, they are in the process of being phased out of the language altogether. Eventually, they will be marked as obsolete, which means that browsers will be neither required nor encouraged to support them. Among the deprecated elements are <font>, <basefont>, <u>, <strike>, <s>, and <center>. With the advent of style sheets, none of these elements are necessary. And there may be more elements deprecated as time goes by.

As if that weren't enough, there is the possibility that HTML will be gradually replaced by the Extensible Markup Language (XML). XML is much more complicated than HTML, but it is also far more powerful and flexible. Despite this, XML does not provide any way to declare style elements such as <i> or <center>. Instead, it is quite probable that XML documents will rely on style sheets to determine their appearance. While the style sheets used with XML may not be CSS, they will probably be whatever follows CSS and very closely resemble it. Therefore, learning CSS now gives authors a big advantage when the time comes to make the jump to an XML-based web.

So, to get started, it's very important to understand how CSS and document structures relate to each other. It's possible to use CSS to affect document presentation in a very profound way, but there are also limits to what you can do. Let's start by exploring some basic terminology.

## Elements

Elements are the basis of document structure. In HTML, the most common elements are easily recognizable, such as p, table, span, a, and div. Every single element in a document plays a part in its presentation. In CSS terms, at least as of CSS2.1, that means each element generates a box that contains the element's content.

## Replaced and Nonreplaced Elements

Although CSS depends on elements, not all elements are created equally. For example, images and paragraphs are not the same type of element, nor are span and div. In CSS, elements generally take two forms: replaced and nonreplaced. The two types are explored in detail in Chapter 7, which covers the particulars of the box model, but I'll address them briefly here.

## Replaced elements

Replaced elements are those where the element's content is replaced by something that is not directly represented by document content. The most familiar XHTML example is the img element, which is replaced by an image file external to the document itself. In fact, img has no actual content, as you can see by considering a simple example:

<img src="howdy.gif" />

This markup fragment contains no actual content-only an element name and an attribute. The element presents nothing unless you point it to some external content (in this case, an image specified by the src attribute). The input element is also replaced by a radio button, checkbox, or text input box, depending on its type. Replaced elements also generate boxes in their display.

## Nonreplaced elements

The majority of HTML and XHTML elements are nonreplaced elements. This means that their content is presented by the user agent (generally a browser) inside a box generated by the element itself. For example, <span>hi there</span> is a nonreplaced element, and the text "hi there" will be displayed by the user agent. This is true of paragraphs, headings, table cells, lists, and almost everything else in XHTML.

## Element Display Roles

In addition to replaced and nonreplaced elements, CSS2.1 uses two other basic types of elements: block-level and inline-level. These types will be more familiar to authors who have spent time with HTML or XHTML markup and its display in web browsers; the elements are illustrated in Figure 1-1.

## h1 (block)

This paragraph (p) is a block-level element. The strongly emphasized text is an inline element, and so will line-wrap when necessary. The content outside of inline elements is actually part of the block. element. The content inside inline elements such as this one belong to the inline.

Figure 1-1. Block-and inline-level elements in an XHTML document

## Block-level elements

Block-level elements generate an element box that (by default) fills its parent element's content area and cannot have other elements at its sides. In other words, it generates "breaks" before and after the element box. The most familiar block elements from HTML are p and div. Replaced elements can be block-level elements, but they usually are not.

List items are a special case of block-level elements. In addition to behaving in a manner consistent with other block elements, they generate a marker-typically a bullet for unordered lists and a number for ordered lists - that is "attached" to the element box. Except for the presence of this marker, list items are in all other ways identical to other block elements.

## Inline-level elements

Inline-level elements generate an element box within a line of text and do not break up the flow of that line. The best inline element example is the a element in XHTML. Other candidates are strong and em. These elements do not generate a "break" before or after themselves, so they can appear within the content of another element without disrupting its display.

Note that while the names "block" and "inline" share a great deal in common with block- and inline-level elements in XHTML, there is an important difference. In HTML and XHTML, block-level elements cannot descend from inline-level elements. In CSS, there is no restriction on how display roles can be nested within each other.

To see how this works, let's consider a CSS property, display.

You may have noticed that there are a lot of values, only three of which I've even come close to mentioning: block, inline, and list-item. We're not going to explore the others now, mostly because they are covered in some detail in Chapter 2 and Chapter 7.

For the moment, let's just concentrate on block and inline. Consider the following markup:

<body>

<p>This is a paragraph with <em>an inline element</em> within it.</p>

</body>

## display

Values: $\quad$ none $\mid$ inline $\mid$ block | inline-block | list-item | run-in | table | inline-table | table-row-group | table-header-group | table-footergroup | table-row | table-column-group | table-column | table-cell | table-caption | inherit

Initial value: inline

Applies to: $\quad$ All elements

Inherited: No

Computed value: Varies for floated, positioned, and root elements (see CSS2.1, section 9.7); otherwise, as specified

Here we have two block elements (body and p) and an inline element (em). According to the XHTML specification, em can descend from $p$, but the reverse is not true. Typically, the XHTML hierarchy works out such that inlines can descend from blocks, but not the other way around.

CSS, on the other hand, has no such restrictions. You can leave the markup as it is but change the display roles of the two elements like this:

p \{display: inline; \}

em \{display: block; $\}$

This causes the elements to generate a block box inside an inline box. This is perfectly legal and violates no specification. The only problem would be if you tried to reverse the nesting of the elements:

<em><p>This is a paragraph improperly enclosed by an inline element.</p></em>

No matter what you do to the display roles via CSS, this is not legal in XHTML.

While changing the display roles of elements can be useful in XHTML documents, it becomes downright critical for XML documents. An XML document is unlikely to have any inherent display roles, so it's up to the author to define them. For example, you might wonder how to lay out the following snippet of XML:


<pubdate>2004</pubdate>

<isbn>blahblahblah</isbn>

</book>

Since the default value of display is inline, the content would be rendered as inline text by default, as illustrated in Figure 1-2. This isn't a terribly useful display.

Cascading Style Sheets: The Definitive Guide Second Edition Eric A. Meyer O'Reilly and Associates

2004 blahblahblah CSS2 Pocket Reference Eric A. Meyer O'Reilly and Associates 2004 blahblahblah

Figure 1-2. Default display of an XML document

You can define the basics of the layout with display:

book, maintitle, subtitle, author, isbn \{display: block;\}

publisher, pubdate \{display: inline; \}

You've now set five of the seven elements to be block and two to be inline. This means each of the block elements will be treated much as div is treated in XHTML, and the two inlines will be treated in a manner similar to span.

This fundamental ability to affect display roles makes CSS highly useful in a variety of situations. You could take the preceding rules as a starting point, add a number of other styles, and get the result shown in Figure 1-3.

## Cascading Style Sheets: The Definitive Guide

Second Edition

## Eric A. Meyer

O'Reilly and Associates (2004)

blahblahblah

## CSS2 Pocket Reference

## Eric A. Meyer

O'Reilly and Associates (2004)

blahblahblah

Figure 1-3. Styled display of an XML document

Throughout the rest of this book, we'll explore the various properties and values that allow presentation like this. First, though, we need to look at how one can associate CSS with a document. After all, without tying the two together, there's no way for the CSS to affect the document. We'll explore this in an XHTML setting since it's the most familiar.

## Bringing CSS and XHTML Together

I've mentioned that HTML and XHTML documents have an inherent structure, and that's a point worth repeating. In fact, that's part of the problem with web pages of old: too many of us forgot that documents are supposed to have an internal structure,
which is altogether different than a visual structure. In our rush to create the coolestlooking pages on the Web, we bent, warped, and generally ignored the idea that pages should contain information with some structural meaning.

That structure is an inherent part of the relationship between XHTML and CSS; without the structure, there couldn't be a relationship at all. To understand it better, let's look at an example XHTML document and break it down by pieces:



This markup is shown in Figure 1-4.

## Waffles!

The most wonderful of all breakfast foods is the wafle--a ridged and cratered slab of home-cooked, fluffy goodness that makes every child's heart soar with joy. And they're so easy to make! Just a simple waffle-maker and some batter, and you're ready for a morning of aromatic ecstasy!

Figure 1-4. A simple document

Now, let's examine the various ways this document connects to CSS.

## The link Tag

First, consider the use of the link tag:

<link rel="stylesheet" type="text/css" href="sheet1.css" media="all" />

The link tag is a little-regarded but nonetheless perfectly valid tag that has been hanging around the HTML specification for years, just waiting to be put to good use.

Its basic purpose is to allow HTML authors to associate other documents with the document containing the link tag. CSS uses it to link style sheets to the document; in Figure 1-5, a style sheet called sheet1.css is linked to the document.



Figure 1-5. A representation of how external style sheets are applied to documents

These style sheets, which are not part of the HTML document but are still used by it, are referred to as external style sheets. This is because they're style sheets that are external to the HTML document. (Go figure.)

To successfully load an external style sheet, link must be placed inside the head element but may not be placed inside any other element, rather like title. This will cause the web browser to locate and load the style sheet and use whatever styles it contains to render the HTML document in the manner shown in Figure 1-5.

And what is the format of an external style sheet? It's simply a list of rules, just like those we saw in the previous section and in the example XHTML document, but in this case, the rules are saved into their own file. Just remember that no XHTML or any other markup language can be included in the style sheet-only style rules. Here are the contents of an external style sheet:

h1 \{color: red; \}

h2 \{color: maroon; background: white; \}

h3 \{color: white; background: black;

font: medium Helvetica; $\}$

That's all there is to it-no HTML markup or comments at all, just plain-and-simple style declarations. These are saved into a plain-text file and are usually given an extension of .css, as in sheet1.css.



An external style sheet cannot contain any document markup at all, only CSS rules and CSS comments, both of which are explained later in the chapter. The presence of markup in an external style sheet can cause some or all of it to be ignored.

The filename extension is not required, but some older browsers won't recognize the file as containing a style sheet unless it actually ends with .css, even if you do include the correct type of text/css in the link element. In fact, some web servers won't hand over a file as text/css unless its filename ends with .css, though that can usually be fixed by changing the server's configuration files.

## Attributes

For the rest of the link tag, the attributes and values are fairly straightforward. rel stands for "relation," and in this case, the relation is stylesheet. type is always set to text/css. This value describes the type of data that will be loaded using the link tag. That way, the web browser knows that the style sheet is a CSS style sheet, a fact that will determine how the browser deals with the data it imports. After all, there may be other style languages used in the future, so it's important to declare which language you're using.

Next, we find the href attribute. The value of this attribute is the URL of your style sheet. This URL can be either absolute or relative, depending on what works for you. In our example, of course, the URL is relative. It just as easily could have been something like http://www.meyerweb.com/sheet1.css.

Finally, we have a media attribute. The value used in this case, all, means that the style sheet should be applied in all presentation media. CSS2 defines a number of allowed values for this attribute:

all

Use in all presentational media.

aural

Use in speech synthesizers, screen readers, and other audio renderings of the document.

braille

Use when rendering the document with a Braille device. embossed

Use when printing with a Braille printing device.
handheld

Use on handheld devices like personal digital assistants or web-enabled cell phones. print

Use when printing the document for sighted users and also when displaying a "print preview" of the document.

projection

Use in a projection medium, such as a digital projector used to present a slideshow when delivering a speech.

screen

Use when presenting the document in a screen medium like a desktop computer monitor. All web browsers running on such systems are screen-medium user agents.

tty

Use when delivering the document in a fixed-pitch environment like teletype printers.

tv

Use when the document is being presented on a television.

The majority of these media types are not supported by any current web browser. The three most widely supported ones are all, screen, and print. As of this writing, Opera also supports projection, which allows a document to be presented as a slideshow.

You can use a style sheet in more than one medium by providing a comma-separated list of the media in which it applies. Thus, for example, you can use a linked style sheet in both screen and projection media:

<link rel="stylesheet" type="text/css" href="visual-sheet.css"

media="screen, projection" />

Note that there can be more than one linked style sheet associated with a document. In these cases, only those link tags with a rel of stylesheet will be used in the initial display of the document. Thus, if you wanted to link two style sheets named basic.css and splash.css, it would look like this:

<link rel="stylesheet" type="text/css" href="basic.css" />

<link rel="stylesheet" type="text/css" href="splash.css" />

This will cause the browser to load both style sheets, combine the rules from each, and apply them all to the document. (We'll see exactly how the sheets are combined in Chapter 3, but for now, let's just accept that they're combined.) For example:

<link rel="stylesheet" type="text/css" href="basic.css" />

<link rel="stylesheet" type="text/css" href="splash.css" />

<p class="a1">This paragraph will be gray only if styles from the

stylesheet 'basic.css' are applied.</p>

<p class="b1">This paragraph will be gray only if styles from the

stylesheet 'splash.css' are applied.</p>

The one attribute that is not in your example markup, but could be, is the title attribute. This attribute is not often used, but it could become important in the future and, if used improperly, can have unexpected effects. Why? We will explore that in the next section.

## Alternate style sheets

It's also possible to define alternate style sheets. These are defined by making the value of the rel attribute alternate stylesheet, and they are used in document presentation only if selected by the user.

Should a browser be able to use alternate style sheets, it will use the values of the link elements' title attributes to generate a list of style alternatives. So you could write the following:



Users could then pick the style they want to use, and the browser would switch from the first one (labeled "Default" in this case) to whichever the user picked. Figure 1-6 shows one way in which this selection mechanism is accomplished.



Figure 1-6. A browser offering alternate style sheet selection



Alternate style sheets are supported in most Gecko-based browsers like Mozilla and Netscape 6+, and in Opera 7. They can be supported : in Internet Explorer through the use of JavaScript but are not natively supported by those browsers.

It is also possible to group alternate style sheets together by giving them the same title value. Thus, you make it possible for the user to pick a different presentation for your site in both screen and print media. For example:



If a user selects "Big Text" from the alternate style sheet selection mechanism in a conforming user agent, then bigtext.css will be used to style the document in the screen medium, and print-bigtext.css will be used in the print medium. Neither sheet1.css nor print-sheet1.css will be used in any medium.

Why is that? Because if you give a link with a rel of stylesheet a title, then you are designating that style sheet as a preferred style sheet. This means that its use is preferred to alternate style sheets, and it will be used when the document is first displayed. Once you select an alternate style sheet, however, the preferred style sheet will not be used.

Furthermore, if you designate a number of style sheets as preferred, then all but one of them will be ignored. Consider:



All three link elements now refer to preferred style sheets, thanks to the presence of a title attribute on all three, but only one of them will actually be used in that manner. The other two will be ignored completely. Which two? There's no way to be certain, as neither HTML nor XHTML provide a method of determining which preferred style sheets should be ignored or which should be used.

If you simply don't give a style sheet a title, then it becomes a persistent style sheet and is always used in the display of the document. Often, this is exactly what an author wants.

## The style Element

The style element is one way to include a style sheet, and it appears in the document itself:

<style type="text/css">

style should always use the attribute type; in the case of a CSS document, the correct value is "text/css", just as it was with the link element.

The style element should always start with <style type="text/css">, as shown in the preceding example. This is followed by one or more styles and is finished with a
closing </style> tag. It is also possible to give the style element a media attribute, with the same allowed values as previously discussed for linked style sheets.

The styles between the opening and closing style tags are referred to as the document style sheet, or the embedded style sheet since this style sheet is embedded within the document. It will contain many of the styles that will apply to the document, but it can also contain multiple links to external style sheets using the @import directive.

## The @import Directive

Now we'll discuss the stuff that is found inside the style tag. First, we have something very similar to link: the @import directive:

@import url(sheet2.css);

Just like link, @import can be used to direct the web browser to load an external style sheet and use its styles in the rendering of the HTML document. The only major difference is in the actual syntax and placement of the command. As you can see, @import is found inside the style container. It must be placed there, before the other CSS rules, otherwise it won't work at all. Consider this example:



Like link, there can be more than one @import statement in a document. Unlike link, however, the style sheets of every @import directive will be loaded and used; there is no way to designate alternate style sheets with @import. So, given the following markup:

@import url(sheet2.css);

@import url(blueworld.css);

@import url(zany.css);

all three external style sheets will be loaded, and all of their style rules will be used in the display of the document.



Many older browsers cannot process varying forms of the @import directive. This fact can actually be used to one's advantage in "hiding" styles from these browsers. For more details, see http:// w3development.de/css/hide_css_from_browsers.

As with link, you can restrict imported style sheets to one or more media by listing the media to which it should be applied after the style sheet's URL:

@import url(sheet2.css) all;

@import url(blueworld.css) screen;

@import url(zany.css) projection, print;
@import can be highly useful if you have an external style sheet that needs to use the styles found in other external style sheets. Since external style sheets cannot contain any document markup, the link element can’t be used-but @import can. Therefore, you might have an external style sheet that contains the following:



Well, maybe not those exact styles, but you get the idea. Note the use of both absolute and relative URLs in the previous example. Either URL form can be used, just as with link.

Note also that the @import directives appear at the beginning of the style sheet, as they did in our example document. CSS requires the @import directive to come before any other rules in a style sheet. An @import that comes after other rules (e.g., body \{color: red;\}) will be ignored by conforming user agents.



Internet Explorer for Windows does not ignore any @import directive, even those that come after other rules. Since other browsers do ignore improperly placed @import directives, it is easy to mistakenly place the @import directive incorrectly and thus alter the display in other browsers.

## Actual Style Rules

After the @import statement in our example, we find some ordinary style rules. What they mean doesn't actually matter for this discussion, although you can probably guess that they set $\mathrm{h} 1$ elements to be maroon and body elements to have a yellow background:

h1 \{color: maroon; \}

body \{background: yellow; \}

Styles such as these comprise the bulk of any embedded style sheet-simple and complex, short and long. Rarely will you have a document where the style element does not contain any rules.

## Backward accessibility

For those of you concerned about making your documents accessible to older browsers, there is an important warning to consider. You're probably aware that browsers ignore tags they don't recognize; for example, if a web page contains a blooper tag, browsers will completely ignore the tag because it isn't one they recognize.

The same is true with style sheets. If a browser does not recognize <style> and </style>, it will ignore them altogether. However, the declarations within those tags will not
necessarily be ignored because they look like ordinary text as far as the browser is concerned. So your style declarations will appear at the top of your page! (Of course, the browser should ignore the text because it isn't part of the body element, but this is never the case.)

To combat this problem, it is recommended that you enclose your declarations in a comment tag. In the example given here, the beginning of the comment tag appears just after the opening style tag, and the end of the comment appears just before the closing style tag:



This should cause older browsers to completely ignore the declarations as well as the style tags because HTML comments are not displayed. Meanwhile, those browsers that understand CSS will still be able to read the style sheet.

## CSS Comments

CSS also allows for comments. These are very similar to $\mathrm{C} / \mathrm{C}++$ comments in that they are surrounded by $/ *$ and $* /$ :

/* This is a CSS1 comment */

Comments can span multiple lines, just as in C++:

/* This is a CSS1 comment, and it

can be several lines long without

any problem whatsoever. */

It's important to remember that CSS comments cannot be nested. So, for example, this would not be correct:



However, it's hardly ever desirable to nest comments, so this limitation is no big deal.



One way to create "nested" comments accidentally is to temporarily comment out a large block of a style sheet that already contains a comment. Since CSS doesn't permit nested comments, the "outside" comment will end where the "inside" comment ends.

If you wish to place comments on the same line as markup, then you need to be careful about how you place them. For example, this is the correct way to do it:
h1 \{color: gray;\} /* This CSS comment is several lines */

h2 \{color: silver;\} /* long, but since it is alongside */

p \{color: white; \} /* actual styles, each line needs to */

pre $\{$ color: gray; $\}$ /* be wrapped in comment markers. */

Given this example, if each line isn't marked off, then most of the style sheet will become part of the comment and thus will not work:



In this example, only the first rule (h1 \{color: gray; \}) will be applied to the document. The rest of the rules, as part of the comment, are ignored by the browser's rendering engine.

Moving on with the example, you see some more CSS information actually found inside an XHTML tag!

## Inline Styles

For cases where you want to simply assign a few styles to one individual element, without the need for embedded or external style sheets, employ the HTML attribute style to set an inline style:

<p style="color: gray;">The most wonderful of all breakfast foods is

the waffle--a ridged and cratered slab of home-cooked, fluffy goodness...

</p>

The style attribute can be associated with any HTML tag whatsoever, except for those tags that are found outside of body (head or title, for instance).

The syntax of a style attribute is fairly ordinary. In fact, it looks very much like the declarations found in the style container, except here the curly braces are replaced by double quotation marks. So <p style="color: maroon; background: yellow;"> will set the text color to be maroon and the background to be yellow for that paragraph only. No other part of the document will be affected by this declaration.

Note that you can only place a declaration block, not an entire style sheet, inside an inline style attribute. Therefore, you can't put an @import into a style attribute, nor can you include any complete rules. The only thing you can put into the value of a style attribute is what might go between the curly braces of a rule.

Use of the style attribute is not generally recommended. Indeed, it is marked as deprecated by XHTML 1.1 and is very unlikely to appear in XML languages other than XHTML. Some of the primary advantages of CSS-the ability to organize centralized styles that control an entire document's appearance or the appearance of all documents on a web server-are negated when you place styles into a style attribute. In many ways, inline styles are not much better than the font tag, although they do have a good deal more flexibility.

## Summary

With CSS, it is possible to completely change the way elements are presented by a user agent. This can be executed at a basic level with the display property, and in a different way by associating style sheets with a document. The user will never know whether this is done via an external or embedded style sheet, or even with an inline style. The real importance of external style sheets is the way in which they allow authors to put all of a site's presentation information in one place, and point all of the documents to that place. This not only makes site updates and maintenance a breeze, but it helps to save bandwidth since all of the presentation is removed from documents.

To make the most of the power of CSS, authors need to know how to associate a set of styles with the elements in a document. To fully understand how CSS can do all of this, authors need a firm grasp of the way CSS selects pieces of a document for styling, which is the subject of the next chapter.

## CHAPTER 2

## Selectors

One of the primary advantages of CSS — particularly to designers - is its ability to easily apply a set of styles to all elements of the same type. Unimpressed? Consider this: by editing a single line of CSS, you can change the colors of all your headings. Don't like the blue you're using? Change that one line of code, and they can all be purple, yellow, maroon, or any other color you desire. That lets you, the designer, focus on design, rather than grunt work. The next time you're in a meeting and someone wants to see headings with a different shade of green, just edit your style and hit Reload. Voilà! The results are accomplished in seconds and there for everyone to see.

Of course, CSS can't solve all your problems-you can't use it to change the color of your GIFs, for example-but it can make some global changes much easier. So let's begin with selectors and structure.

## Basic Rules

As I've stated, a central feature of CSS is its ability to apply certain rules to an entire set of element types in a document. For example, let's say that you want to make the text of all h2 elements appear gray. Using old-school HTML, you'd have to do this by inserting 〈FONT COLOR="gray">...</FONT> tags in all your h2 elements:

<h2><font color="gray">This is h2 text</font></h2>

Obviously, this is a tedious process if your document contains a lot of h2 elements. Worse, if you later decide that you want all those h2s to be green instead of gray, you'd have to start the manual tagging all over again.

CSS allows you to create rules that are simple to change, edit, and apply to all the text elements you define (the next section will explain how these rules work). For example, simply write this rule once to make all your h2 elements gray:

h2 \{color: gray; \}

If you want to change all h2 text to another color-say, silver-simply alter the rule:

h2 \{color: silver; \}

## Rule Structure

To illustrate the concept of rules in more detail, let's break down the structure.

Each rule has two fundamental parts, the selector and the declaration block. The declaration block is composed of one or more declarations, and each declaration is a pairing of a property and a value. Every style sheet is made up of a series of rules. Figure 2-1 shows the parts of a rule.



Figure 2-1. The structure of a rule

The selector, shown on the left side of the rule, defines which piece of the document will be affected. In Figure 2-1, h1 elements are selected. If the selector were p, then all p (paragraph) elements would be selected.

The right side of the rule contains the declaration block, which is made up of one or more declarations. Each declaration is a combination of a CSS property and a value of that property. In Figure 2-1, the declaration block contains two declarations. The first states that this rule will cause parts of the document to have a color of red, and the second states that part of the document will have a background of yellow. So, all of the h1 elements in the document (defined by the selector) will be styled in red text with a yellow background.

## Element Selectors

A selector is most often an HTML element, but not always. For example, if a CSS file contains styles for an XML document, a selector might look something like this:



In other words, the elements of the document serve as the most basic selectors. In XML, a selector could be anything, since XML allows for the creation of new markup languages that can have just about anything as an element name. If you're styling an HTML document, on the other hand, the selector will generally be one of the many HTML elements such as p, h3, em, a, or even html itself. For example:
html \{color: black; \}

h1 \{color: gray; \}

h2 \{color: silver; \}

The results of this style sheet are shown in Figure 2-2.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled.

## Safety Information

When handling plutonium, care must be taken to avoid the formation of a critical mass.

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate.

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-2. Simple styling of a simple document

Once you've globally applied styles directly to elements, you can shift those styles from one element to another. Let's say you decide that the paragraph text, not the h1 elements, in Figure 2-2 should be gray. No problem. Simply change the h1 selector to p:

html \{color: black; $\}$

p \{color: gray; $\}$

h2 \{color: silver; \}

The results are shown in Figure 2-3.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled.

## Safety Information

When handling plutonium, care must be taken to avoid the formation of a critical mass.

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-3. Moving a style from one element to another

## Declarations and Keywords

The declaration block contains one or more declarations. A declaration is always formatted as a property followed by a colon and then a value followed by a semicolon. The colon and semicolon can be followed by zero or more spaces. In nearly all cases, a value is either a single keyword or a space-separated list of one or more keywords that are permitted for that property. If you use either an incorrect property or value in a declaration, the whole thing will be ignored. Thus, the following two declarations would fail:

brain-size: $2 \mathrm{~cm}$; /* unknown property */

color: ultraviolet; /* unknown value */

In an instance where you can use more than one keyword for a property's value, the keywords are usually separated by spaces. Not every property can accept multiple keywords, but many, such as the font property, can. Let's say you want to define medium-sized Helvetica for paragraph text, as illustrated in Figure 2-4.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled.

## Safety Information

When handling plutonium, care must be taken to avoid the formation of a critical mass.

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate.

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-4. The results of a property value with multiple keywords

The rule would read as follows:

p \{font: medium Helvetica; $\}$

Note the space between medium and Helvetica, each of which is a keyword (the first is the font's size and the second is the actual font name). The space allows the user agent to distinguish between the two keywords and apply them correctly. The semicolon indicates that the declaration has been concluded.

These space-separated words are referred to as keywords because, taken together, they form the value of the property in question. For instance, consider the following fictional rule:

rainbow: red orange yellow green blue indigo violet;

There is no such property as rainbow, of course, and two of the colors used aren't valid either, but the example is useful for illustrative purposes. The value of rainbow is red orange yellow green blue indigo violet, and the seven keywords add up to a single, unique value. We can redefine the value for rainbow as follows:

rainbow: infrared red orange yellow green blue indigo violet ultraviolet;

Now we have a new value for rainbow composed of nine keywords instead of seven. Although the name of the two values is the same, they are as unique and different as zero and one.



As we've seen, CSS keywords are separated by spaces-except in one instance. In the CSS property font, there is exactly one place where a forward slash (/) can be used to separate two specific keywords. Here's an example: h2 \{font: large/150\% sans-serif; \}

The slash separates the keywords that set the element's font size and line height. This is the only place the slash is allowed to appear in the font declaration. All of the other keywords allowed for font are separated by spaces.

Those are the basics of simple declarations, but they can get much more complex. The next section begins to show you just how powerful CSS can be.

## Grouping

So far, we've learned fairly simple techniques for applying a single style to a single selector. But what if you want the same style to apply to multiple elements? If that's the case, you'll want to use more than one selector or apply more than one style to an element or group of elements.

## Grouping Selectors

Let's say you want h2 elements and paragraphs to have gray text. The easiest way to accomplish this is to use the following declaration:

$$
\text { h2, p \{color: gray; }\}
$$

By placing the $h 2$ and $p$ selectors on the left side of the rule and separating them with a comma, you've defined a rule where the style on the right (color: gray;) applies to the elements referenced by both selectors. The comma tells the browser that there are two different selectors involved in the rule. Leaving out the comma would give the rule a completely different meaning, which we'll explore later in "Descendant Selectors."

There are really no limits on how many selectors you can group together. For example, if you want to display a large number of elements in gray, you might use something like the following rule:

body, table, th, td, h1, h2, h3, h4, p, pre, strong, em, b, i \{color: gray; \}

Grouping allows an author to drastically compact certain types of style assignments, which makes for a shorter style sheet. The following alternatives produce exactly the same result, but it's pretty obvious which one is easier to type:



Grouping allows for some interesting choices. For example, all of the groups of rules in the following example are equivalent-each merely shows a different way of grouping both selectors and declarations:



Any of these will yield the result shown in Figure 2-5. (These styles use grouped declarations, which are explained in the upcoming section, "Grouping Declarations.")

## The universal selector

CSS2 introduced a new simple selector called the universal selector, displayed as an asterisk (*). This selector matches any element at all, much like a wildcard. For example, to make every single element in a document red, you would write:

* \{color: red; $\}$


## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled.

## Safety Information

When handling plutonium, care must be taken to avoid the formation of a critical mass

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate.

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-5. The result of equivalent style sheets

This declaration is equivalent to a grouped selector that lists every single element contained within the document. The universal selector lets you assign the color value red to every element in the document in one efficient stroke. Beware, however: although the universal selector is convenient, it can have unintended consequences, which I'll discuss in the next chapter.

## Grouping Declarations

Since you can group selectors together into a single rule, it follows that you can also group declarations. Assume that you want all h1 elements to appear in purple, 18pixel-high Helvetica text on an aqua background (and you don't mind blinding your readers). You could write your styles like this:

h1 \{font: 18px Helvetica; \}

h1 \{color: purple; $\}$

h1 \{background: aqua; \}

But this method is inefficient; imagine creating such a list for an element that will carry 10 or 15 styles! Instead, you can group your declarations together:

h1 \{font: 18px Helvetica; color: purple; background: aqua;\}

This will have exactly the same effect as the three-line style sheet just shown.

Note that using semicolons at the end of each declaration is crucial when you're grouping them. Browsers ignore whitespace in style sheets, and the user agent must rely on correct syntax to parse the style sheet. You can fearlessly format styles like the following:



If the second semicolon is omitted, however, the user agent will interpret the style sheet as follows:

h1 \{

font: 18 px Helvetica;

\}

color: purple background: aqua;

Because background: is not a valid value for color, and because color can be given only one keyword, a user agent will ignore the color declaration (including the background: aqua part) entirely. It might render h1s as purple text without an aqua background, but more likely, you won't even get purple h1s. Instead, they will be the default color (which is usually black) with no background at all. (The declaration font: $18 \mathrm{px}$ Helvetica will still take effect since it was correctly terminated with a semicolon.)



Although it is not technically necessary to follow the last declaration of a rule with a semicolon, it is generally good practice to do so. First, it will keep you in the habit of terminating your declarations with semicolons, the lack of which is one of the most common causes of rendering errors. Second, if you decide to add another declaration to a rule, you won't have to worry about forgetting to insert an extra semicolon. Finally, some older browsers such as Internet Explorer 3.x have a greater tendency to become confused if the semicolon is left off the final declaration in a rule. Avoid all these problems-always follow a declaration with a semicolon, wherever the rule appears.

As with selector grouping, declaration grouping is a convenient way to keep your style sheets short, expressive, and easy to maintain.

## Grouping Everything

You now know that you can group selectors, and you can group declarations. By combining both kinds of grouping in single rules, you can define very complex styles using only a few statements. Now, what if you want to assign some complex styles to all the headings in a document, and you want the same styles to be applied to all of them? Here's how to do it:

h1, h2, h3, h4, h5, h6 \{color: gray; background: white; padding: $0.5 \mathrm{em}$;

border: 1px solid black; font-family: Charcoal, sans-serif; \}

You've grouped the selectors, so the styles on the right side of the rule will be applied to all the headings listed, and grouping the declarations means that all of the listed styles will be applied to the selectors on the left side of the rule. The result of this rule is shown in Figure 2-6.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled.

## Safety Information

When handling plutonium, care must be taken to avoid the formation of a critical mass.

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-6. Grouping both selectors and rules

This approach is preferable to the drawn-out alternative, which would begin with something like this:

h1 \{color: gray; \}

h2 \{color: gray; $\}$

h3 \{color: gray; \}

h4 \{color: gray; \}

h5 \{color: gray; \}

h6 \{color: gray; \}

h1 \{background: white; \}

h2 \{background: white; $\}$

h3 \{background: white; \}

and continue for many lines. You can write out your styles the long way, but I wouldn't recommend it — editing them would be as tedious as using font tags everywhere!

It's possible to add even more expression to selectors and to apply styles in a way that cuts across elements in favor of types of information. Of course, to get something so powerful, you'll have to do a little work in return, but it's well worth it.

## Class and ID Selectors

So far, we've been grouping selectors and declarations together in a variety of ways, but the selectors we've been using are still simple ones that refer only to document elements. They're fine up to a point, but there are times when you need something a little more specialized.

In addition to raw document elements, there are two other types of selectors: class selectors and ID selectors, which let you assign styles in a way that is independent of document elements. These selectors can be used on their own or in conjunction with element selectors. However, they work only if you've marked up your document appropriately, so using them generally involves a little forethought and planning.

For example, say you're drafting a document that discusses ways of handling plutonium. The document contains various warnings about safely dealing with such a dangerous substance. You want each warning to appear in boldface text so that it will stand out. However, you don't know which elements these warnings will be. Some warnings could be entire paragraphs, while others could be a single item within a lengthy list or a small section of text. So, you can't define a rule using simple selectors of any kind. Suppose you tried this route:

p \{font-weight: bold; \}

All paragraphs would be bold, not just those that contain warnings. You need a way to select only the text that contains warnings, or more precisely, a way to select only those elements that are warnings. How do you do it? You apply styles to parts of the document that have been marked in a certain way, independent of the elements involved, by using class selectors.

## Class Selectors

The most common way to apply styles without worrying about the elements involved is to use class selectors. Before you can use them, however, you need to modify your actual document markup so that the class selectors will work. Enter the class attribute:

<p class="warning"> When handling plutonium, care must be taken to avoid the formation of a critical mass. $\langle/ p\rangle$

<p>with plutonium, <span class="warning">the possibility of implosion is

very real, and must be avoided at all costs</span>. This can be accomplished

by keeping the various masses separate.</p>

To associate the styles of a class selector with an element, you must assign a class attribute to the appropriate value. In the previous code, a class value of warning was assigned to two elements: the first paragraph and the span element in the second paragraph.

All you need now is a way to apply styles to these classed elements. In HTML documents, you can use a very compact notation where the name of a class is preceded by a period (.) and can be joined with a simple selector:

*.warning \{font-weight: bold; \}

When combined with the example markup shown earlier, this simple rule has the effect shown in Figure 2-7. That is, the style of font-weight: bold will be applied to every element (thanks to the presence of the universal selector) that carries a class attribute with a value of warning.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled

## Safety Information

## When handling plutonium, care must be taken to avoid the formation of a critical mass. <br> With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate.

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-7. Using a class selector

As you can see, the class selector works by directly referencing a value that will be found in the class attribute of an element. This reference is always preceded by a period (.), which marks it as a class selector. The period helps keep the class selector separate from anything with which it might be combined — such as an element selector. For example, you may want boldface text only when an entire paragraph is a warning:

p.warning \{font-weight: bold; \}

The selector now matches any $p$ elements that have a class attribute containing the word warning, but no other elements of any kind, classed or otherwise. The selector p.warning translates to: "Any paragraph whose class attribute contains the word warning." Since the span element is not a paragraph, the rule's selector doesn't match it, and it won't be converted to bold text.

If you did want to assign different styles to the span element, you could use the selector span.warning:

p.warning \{font-weight: bold; \}

span.warning \{font-style: italic; \}

In this case, the warning paragraph is boldfaced, while the warning span is italicized. Each rule applies only to a specific type of element/class combination, so it does not leak over to other elements.

Another option is to use a combination of a general class selector and an elementspecific class selector to make the styles even more useful, as in the following markup:

$$
\text { .warning }\{\text { font-style: italic; }\}
$$

span.warning \{font-weight: bold; $\}$

The results are shown in Figure 2-8.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled

## Safety Information

When handling plutonium, care must be taken to avoid the formation of a critical mass.

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate.

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-8. Using generic and specific selectors to combine styles

In this situation, any warning text will be italicized, but only the text within a span element and text with a class of warning will be boldfaced and italicized.

Notice the format of the general class selector in the previous example: it's simply a class name preceded by a period without any element name. In cases where you only want to select all elements that share a class name, you can omit the universal selector from a class selector without any ill effects.

## Multiple Classes

In the previous section, we dealt with class values that contained a single word. In HTML, it's possible to have a space-separated list of words in a single class value. For example, if you want to mark a particular element as being both urgent and a warning, you could write:



The order of the words doesn't actually matter; warning urgent would also suffice.

Now let's say you want all elements with a class of warning to be boldface, those with a class of urgent to be italic, and those elements with both values to have a silver background. This would be written as follows:

.warning \{font-weight: bold;\}

.urgent $\{$ font-style: italic; $\}$

.warning.urgent $\{$ background: silver; $\}$

By chaining two class selectors together, you can select only those elements that have both class names, in any order. As you can see, the HTML source contains class="urgent warning" but the CSS selector is written .warning. urgent. Regardless, the rule will still cause the "When handling plutonium..." paragraph to have a silver background, as illustrated in Figure 2-9.

## Plutonium

Useful for many applications, plutonium can also be dangerous if improperly handled.

## Safety Information

## When handling plutonium, care must be taken to avoid the formation of a critical mass.

With plutonium, the possibility of implosion is very real, and must be avoided at all costs. This can be accomplished by keeping the various masses separate.

## Comments

It's best to avoid using plutonium at all if it can be avoided.

Figure 2-9. Selecting elements with multiple class names

If a multiple class selector contains a name that is not in the space-separated list, then the match will fail. Consider the following rule:

p.warning.help \{background: red; \}

As you would expect, the selector will match only those $p$ elements with a class containing the words warning and help. Therefore, it will not match a $p$ element with just the words warning and urgent in its class attribute. It would, however, match the following:

<p class="urgent warning help">Help me!</p>



In versions previous to IE7, Internet Explorer for both platforms has problems with correctly handling multiple class selectors. In these older versions, although you can select a single class name out of a list, selecting based on multiple names in a list does not work properly. Thus, p.warning would work as expected, but p.warning.help would match any $p$ elements that have a class attribute with the word help because it comes last in the selector. If you wrote p. help.warning, then older versions of Explorer would match any $p$ elements that have warning in their class value, whether or not help appears in the same value.

## ID Selectors

In some ways, ID selectors are similar to class selectors, but there are a few crucial differences. First, ID selectors are preceded by an octothorpe (\#)—also known as a pound sign, hash mark, or tic-tac-toe board-instead of a period. Thus, you might see a rule like this one:

*\#first-para \{font-weight: bold; \}

This rule applies boldface text to any element whose id attribute has a value of first-para.

The second difference is that instead of referencing values of the class attribute, ID selectors refer, unsurprisingly, to values found in id attributes. Here's an example of an ID selector in action:

*\#lead-para \{font-weight: bold;\}

<p id="lead-para">This paragraph will be boldfaced.</p>

<p>This paragraph will NOT be bold.</p>

Note that the value lead-para could have been assigned to any element within the document. In this particular case, it is applied to the first paragraph, but you could have applied it just as easily to the second or third paragraph.

As with class selectors, it is possible to omit the universal selector from an ID selector. In the previous example, you could also have written:

\#lead-para \{font-weight: bold; \}

The effect of this selector would be the same.

## Deciding Between Class and ID

You may assign classes to any number of elements, as demonstrated earlier; the class name warning was applied to both a p and a span element, and it could have been applied to many more elements. IDs, on the other hand, are used once, and only once, within an HTML document. Therefore, if you have an element with an id value of lead-para, no other element in that document can have an id value of lead-para.



In the real world, browsers don't usually check for the uniqueness of IDs in HTML, which means that if you sprinkle an HTML document 1: with several elements, all of which have the same value for their ID attributes, you'll probably get the same styles applied to each. This is incorrect behavior, but it happens anyway. Having more than one of the same ID value in a document also makes DOM scripting more difficult, since functions like getElementById() depend on there being one, and only one, element with a given ID value.

Unlike class selectors, ID selectors can't be combined, since ID attributes do not permit a space-separated list of words.

On a purely syntactical level, the dot-class notation (e.g., .warning) is not guaranteed to work for XML documents. As of this writing, the dot-class notation works in HTML, SVG, and MathML, and it may well be permitted in future languages, but it's up to each language's specification to decide that. The hash-ID notation (e.g., \#lead) will work in any document language that has an attribute that enforces uniqueness within a document. Uniqueness can be enforced with an attribute called id, or indeed anything else, as long as the attribute's contents are defined to be unique within the document.

Another difference between class and id names is that IDs carry more weight when you're trying to determine which styles should be applied to a given element. I'll explain this in greater detail in the next chapter.

As with classes, IDs can also be selected independently of an element. There may be circumstances in which you know that a certain ID value will appear in a document, but you don't know the element on which it will appear (as in the plutonium-handling warnings), so you'll want to declare standalone ID selectors. For example, you may know that in any given document, there will be an element with an ID value of mostImportant. You don't know whether that most important thing will be a paragraph, a short phrase, a list item, or a section heading. You know only that it will exist in each document, occur in an arbitrary element, and appear no more than once. In that case, you would write a rule like this:

\#mostImportant \{color: red; background: yellow; \}

This rule would match any of the following elements (which, as I noted before, should not appear together in the same document because they all have the same ID value):

<h1 id="mostImportant">This is important!</h1>

<em id="mostImportant">This is important!</em>

<ul id="mostImportant">This is important!</ul>

Also note that class and ID selectors may be case-sensitive, depending on the document language. HTML and XHTML define class and ID values to be case-sensitive, so the capitalization of your class and ID values must match that found in your documents. Thus, in the following pairing of CSS and HTML, the element will not be boldfaced:

p.criticalinfo \{font-weight: bold; \}

<p class="criticalinfo">Don't look down.</p>

Because of the change in case for the letter $i$, the selector will not match the element shown.



Some older browsers did not treat class and ID names as case-sensitive, but all browsers current as of this writing enforce case sensitivity.

## Attribute Selectors

When it comes to both class and ID selectors, what you're really doing is selecting values of attributes. The syntax used in the previous two sections is particular to HTML, SVG, and MathML documents (as of this writing). In other markup languages, these class and ID selectors may not be available. To address this situation, CSS2 introduced attribute selectors, which can be used to select elements based on their attributes and the values of those attributes. There are four types of attribute selectors.



Attribute selectors are supported by Safari, Opera, and all Geckobased browsers, but not by Internet Explorer up through IE5/Mac and IE6/Win. IE7 fully supports all CSS2.1 attribute selectors, as well as a few CSS3 attribute selectors, which are covered in this section.

## Simple Attribute Selection

If you want to select elements that have a certain attribute, regardless of that attribute's value, you can use a simple attribute selector. For example, to select all h1 elements that have a class attribute with any value and make their text silver, write:

$$
\text { h1[class] \{color: silver; }\}
$$

So, given the following markup:

<h1 class="hoopla">Hello</h1>

<h1 class="severe">Serenity</h1>

<h1 class="fancy">Fooling</h1>

you get the result shown in Figure 2-10.



Figure 2-10. Selecting elements based on their attributes

This strategy is very useful in XML documents, as XML languages tend to have element and attribute names that are very specific to their purpose. Consider an XML language that is used to describe planets of the solar system (we'll call it PlanetML). If you want to select all planet elements with a moons attribute and make them boldface, thus calling attention to any planet that has moons, you would write:[^0]

This would cause the text of the second and third elements in the following markup fragment to be boldfaced, but not the first:

<planet>Venus</planet>

<planet moons="1">Earth</planet>

<planet moons="2">Mars</planet>

In HTML documents, you can use this feature in a number of creative ways. For example, you could style all images that have an alt attribute, thus highlighting those images that are correctly formed:

img[alt] \{border: 3px solid red;\}

(This particular example is useful more for diagnostic purposes-that is, determining whether images are indeed correctly formed - than for design purposes.)

If you wanted to boldface any element that includes title information, which most browsers display as a "tool tip" when a cursor hovers over the element, you could write:

$*$ [title] \{font-weight: bold; \}

Similarly, you could style only those anchors (a elements) that have an href attribute. It is also possible to select based on the presence of more than one attribute. You do this simply by chaining the attribute selectors together. For example, to boldface the text of any HTML hyperlink that has both an href and a title attribute, you would write:

a[href][title] \{font-weight: bold;\}

This would boldface the first link in the following markup, but not the second or third:

<a href="http://www.w3.org/" title="W3C Home">W3C</a><br />

<a href="http://www.webstandards.org">Standards Info</a><br />

<a title="Not a link">dead.letter</a>

## Selection Based on Exact Attribute Value

In addition to selecting elements with attributes, you can further narrow the selection process to encompass only those elements whose attributes are a certain value. For example, let's say you want to boldface any hyperlink that points to a certain document on the web server. This would look something like:

a[href="http://www.css-discuss.org/about.html"] \{font-weight: bold;\}

Any attribute and value combination can be specified for any element. However, if that exact combination does not appear in the document, then the selector won't match anything. Again, XML languages can benefit from this approach to styling. Let's return to our PlanetML example. Suppose you want to select only those planet elements that have a value of 1 for the attribute moons:

planet[moons="1"] \{font-weight: bold;\}

This would boldface the text of the second element in the following markup fragment, but not the first or third:

<planet>Venus</planet>

<planet moons="1">Earth</planet>

<planet moons="2">Mars</planet>

As with attribute selection, you can chain together multiple attribute-value selectors to select a single document. For example, to double the size of the text of any HTML hyperlink that has both an href with a value of http://www.w3.org/ and a title attribute with a value of W3C Home, you would write:

a[href="http://www.w3.org/"][title="W3C Home"] \{font-size: 200\%; \}

This would double the text size of the first link in the following markup, but not the second or third:



The results are shown in Figure 2-11.

$\frac{\text { W3C }}{\frac{\text { Standards Info }}{\text { dead.link }}}$

Figure 2-11. Selecting elements based on attributes and their values

Note that this format requires an exact match for the attribute's value. Matching becomes an issue when the form encounters values that can in turn contain a spaceseparated list of values (e.g., the HTML attribute class). For example, consider the following markup fragment:

<planet type="barren rocky">Mercury</planet>

The only way to match this element based on its exact attribute value is to write:

planet[type="barren rocky"] \{font-weight: bold;\}

If you were to write planet[type="barren"], the rule would not match the example markup and thus would fail. This is true even for the class attribute in HTML. Consider the following:

<p class="urgent warning">when handling plutonium, care must be taken to

avoid the formation of a critical mass.</p>

To select this element based on its exact attribute value, you would have to write:

p[class="urgent warning"] \{font-weight: bold;\}

This is not equivalent to the dot-class notation covered earlier, as we will discuss in the next section. Instead, it selects any p element whose class attribute has exactly the value urgent warning, with the words in that order and a single space between them. It's effectively an exact string match.

Also, be aware that ID selectors and attribute selectors that target the id attribute are not precisely the same. In other words, there is a subtle but crucial difference between h1\#page-title and h1[id="page-title"]. This difference is explained in the next chapter.

## Selection Based on Partial Attribute Values

For any attribute that accepts a space-separated list of words, it is possible to select based on the presence of any one of those words. The classic example in HTML is the class attribute, which can accept one or more words as its value. Consider our usual example text:

<p class="urgent warning">When handling plutonium, care must be taken to avoid the formation of a critical mass.</p>

Let's say you want to select elements whose class attribute contains the word warning. You can do this with an attribute selector:

p[class ="warning"] \{font-weight: bold;\}

Note the presence of the tilde $\left(^{\sim}\right)$ in the selector. It is the key to selection based on the presence of a space-separated word within the attribute's value. If you omit the tilde, you would have an exact-value matching requirement, as discussed in the previous section.

This selector construct is equivalent to the dot-class notation discussed earlier. Thus, p.warning and p[class ="warning"] are equivalent when applied to HTML documents. Here's an example that is an HTML version of the "PlanetML" markup seen earlier:

<span class="barren rocky">Mercury</span><span class="cloudy barren">Venus</span><span class="life-bearing cloudy">Earth</span>To italicize all elements with the word barren in their class attribute, you write:

span[class ="barren"] \{font-style: italic; \}

This rule's selector will match the first two elements in the example markup and thus italicize their text, as shown in Figure 2-12. This is the same result we would expect from writing span.barren \{font-style: italic; \}.

Mercury Venus Earth

Figure 2-12. Selecting elements based on portions of attribute values

So why bother with the tilde-equals attribute selector in HTML? Because it can be used for any attribute, not just class. For example, you might have a document that contains a number of images, only some of which are figures. You can use a partialvalue attribute selector aimed at the title text to select only those figures:

img[title $=$ "Figure"] \{border: 1px solid gray;\}

This rule will select any image whose title text contains the word Figure. Therefore, as long as all your figures have title text that looks something like "Figure 4. A bald-headed elder statesman," this rule will match those images. For that matter, the selector img[title ${ }^{\sim}=$ "Figure"] will also match a title attribute with the value "How To Figure Out Who's In Charge." Any image that does not have a title attribute, or whose title value doesn't contain the word "Figure," won't be matched.

The even more advanced CSS Selectors module, which was released well after CSS2 was completed, contains a few more partial-value attribute selectors (or, as the specification calls them, "substring matching attribute selectors"). Since these are supported in many modern browsers, including IE7, we'll cover them quickly in Table 2-1.

Table 2-1. Substring matching attribute selectors

| Type | Description |
| :--- | :--- |
| $[$ foo^="bar" $]$ | Selects any element with an attribute foo whose value begins with "bar". |
| $[$ foo $\$=" b a r "]$ | Selects any element with an attribute foo whose value ends with "bar". |
| $[$ foo*="bar" $]$ | Selects any element with an attribute foo whose value contains the substring "bar". |

Thus, given the following rules and markup, we would get the result shown in Figure 2-13.



## Mercury Venus Earth

Figure 2-13. Selecting elements based on substrings within attribute values

The first of the three rules matches any span element whose class attribute contains the substring cloud, so both "cloudy" planets are matched. The second rule matches any span element whose class attribute starts with the substring bar, so the only match is Mercury, whose class value is barren rocky. Venus is not matched because
the bar in barren comes later in its class value, not at the beginning. Finally, the third rule matches any span element whose class attribute ends with the substring $y$, so Mercury and Earth both are picked. Venus is again left out in the cold, since the end of its class value is not $\mathrm{y}$.

As you can imagine, there are many useful applications for such selectors. As an example, suppose you wanted to specially style any links to the O'Reilly Media web site. Instead of classing them all and writing styles based on that class, you could simply write the following rule:

$$
\text { a[href*="oreilly.com"] \{font-weight: bold; }\}
$$

And, of course, you aren't confined to the class and href attributes. Any attribute is up for grabs here. title, alt, src, id... you name it, you can style based on its value or some part thereof. The following rule draws attention to any spacer GIF in an oldschool table layout (plus any other image with the string "space" in its URL):

img[src*="space"] \{border: 5px solid red;\}



As of this writing, support for these substring selectors is confined to Safari, Gecko-based browsers, Opera, and IE7/Win.

## A Particular Attribute Selection Type

The last type of attribute selector, the particular attribute selector, is easier to show than it is to describe. Consider the following rule:

*[lang|="en"] \{color: white; \}

This rule will select any element whose lang attribute is equal to en or begins with en-. Therefore, the first three elements in the following example markup would be selected, but the last two would not:



In general, the form [att|="val"] can be used for any attribute and its values. Let's say you have a series of figures in an HTML document, each of which has a filename like figure-1.gif and figure-3.jpg. You can match all of these images using the following selector:

$$
\text { img[src|="figure"] \{border: 1px solid gray;\} }
$$

The most common use for this type of attribute selector is to match language values, as demonstrated later in this chapter.

## Using Document Structure

As I've mentioned before, CSS is powerful because it uses the structure of HTML documents to determine appropriate styles and how to apply them. That's only part of the story since it implies that such determinations are the only way CSS uses document structure. Structure plays a much larger role in the way styles are applied to a document. Let's take a moment to discuss structure before moving on to more powerful forms of selection.

## Understanding the Parent-Child Relationship

To understand the relationship between selectors and documents, you need to once again examine how documents are structured. Consider this very simple HTML document:



Much of the power of CSS is based on the parent-child relationship of elements. HTML documents (actually, most structured documents of any kind) are based on a hierarchy of elements, which is visible in the "tree" view of the document (see

Figure 2-14). In this hierarchy, each element fits somewhere into the overall structure of the document. Every element in the document is either the parent or the child of another element, and it's often both.



Figure 2-14. A document tree structure

An element is said to be the parent of another element if it appears directly above that element in the document hierarchy. For example, in Figure 2-14, the first $p$ element is parent to the em and strong elements, while strong is parent to an anchor element, which is itself parent to another em element. Conversely, an element is the child of another element if it is directly beneath the other element. Thus, the anchor element in Figure 2-14 is a child of the strong element, which is in turn child to the $p$ element, and so on.

The terms parent and child are specific applications of the terms ancestor and descendant. There is a difference between them: in the tree view, if an element is exactly one level above another, then they have a parent-child relationship. If the path from one element to another continues through two or more levels, the elements have an ancestor-descendant relationship, but not a parent-child relationship. (Of course, a child is also a descendant, and a parent is an ancestor.) In Figure 2-14, the first ul element is parent to two li elements, but the first ul is also the ancestor of every element descended from its li element, all the way down to the most deeply nested li elements.

Also, in Figure 2-14, there is an anchor that is a child of strong, but also a descendant of paragraph, body, and html elements. The body element is an ancestor of everything that the browser will display by default, and the html element is ancestor to the entire document. For this reason, the html element is also called the root element.

## Descendant Selectors

The first benefit of understanding this model is the ability to define descendant selectors (also known as contextual selectors). Defining descendant selectors is the act of creating rules that operate in certain structural circumstances but not others. As an example, let's say you want to style only those em elements that are descended from $\mathrm{h} 1$ elements. You could put a class attribute on every em element found within an h1, but that's almost as time-consuming as using the font tag. It's obviously far more efficient to declare rules that match only em elements that are found inside h1 elements.

To do so, write the following:

h1 em \{color: gray; \}

This rule will make gray any text in an em element that is the descendant of an h1 element. Other em text, such as that found in a paragraph or a block quote, will not be selected by this rule. Figure 2-15 makes this clear.

## Meerkat Central

Figure 2-15. Selecting an element based on its context

In a descendant selector, the selector side of a rule is composed of two or more space-separated selectors. The space between the selectors is an example of a combinator. Each space combinator can be translated as "found within," "which is part of," or "that is a descendant of," but only if you read the selector right to left. Thus, h1 em can be translated as, "Any em element that is a descendant of an h1 element." (To read the selector left to right, you might phrase it something like, "Any h1 that contains an em will have the following styles applied to the em.")

You aren't limited to two selectors, of course. For example:

ul ol ul em \{color: gray; \}

In this case, as Figure 2-16 shows, any emphasized text that is part of an unordered list that is part of an ordered list that is itself part of an unordered list (yes, this is correct) will be gray. This is obviously a very specific selection criterion.

- It's a list
- A right smart list

1. Within, another list

- This is deep
- So very deep

2. A list of lists to see

- And all the lists for me!

Figure 2-16. A very specific descendant selector

Descendant selectors can be extremely powerful. They make possible what could never be done in HTML-at least not without oodles of font tags. Let's consider a
common example. Assume you have a document with a sidebar and a main area. The sidebar has a blue background, the main area has a white background, and both areas include lists of links. You can't set all links to be blue because they'd be impossible to read in the sidebar.

The solution: descendant selectors. In this case, you give the table cell that contains your sidebar a class of sidebar, and assign the main area a class of main. Then, you write styles like this:

td.sidebar \{background: blue;\}

td.main \{background: white; \}

td.sidebar a:link \{color: white; \}

td.main a:link \{color: blue; \}

Figure 2-17 shows the result.

## glish.com <br> In hixie. ch <br> meyerweb.com <br> simon.incutio.con <br> stopdesign. com <br> tantek. com <br> zeldman.com <br> Web Blogs <br> These are the web logs ("blogs") I visit a lot. They're all written by people who know a lot about Web design and CSS in general. By reading them I can get a sense of the trends in design and thinking about document structure.

Figure 2-17. Using descendant selectors to apply different styles to the same type of element


:link refers to links to resources that haven't been visited. We'll talk about it in detail later in this chapter.

Here's another example: let's say that you want gray to be the text color of any $b$ (boldface) element that is part of a blockquote, and also for any bold text that is found in a normal paragraph:

blockquote b, p b \{color: gray; \}

The result is that the text within $b$ elements that are descended from paragraphs or block quotes will be gray.

One overlooked aspect of descendant selectors is that the degree of separation between two elements can be practically infinite. For example, if you write ul em, that syntax will select any em element descended from a ul element, no matter how deeply nested the em may be. Thus, ul em would select the em element in the following markup:

<ul>

$<$ li $>$ List item 1

<ol>

<li>List item 1-1</li>

<li>List item 1-2</li>

<li>List item 1-3
<ol>

$<$ li $>$ List item 1-3-1</li>

$<$ li $>$ List item <em>1-3-2</em></li>

$<$ li $>$ List item $1-3-3</$ li $>$

$</$ ol></li>

$<$ li>List item 1-4</li>

$</$ ol></li>

</ul>

## Selecting Children

In some cases, you don't want to select an arbitrarily descended element; rather, you want to narrow your range to select an element that is a child of another element. You might, for example, want to select a strong element only if it is a child (as opposed to a descendant) of an h1 element. To do this, you use the child combinator, which is the greater-than symbol (>):

h1 > strong \{color: red;\}

This rule will make red the strong element shown in the first $\mathrm{h} 1$ below, but not the second:

<h1>This is <strong>very</strong> important.</h1>

<h1>This is <em>really <strong>very</strong></em> important.</h1>

Read right to left, the selector h1 > strong translates as "selects any strong element that is a child of an $\mathrm{h} 1$ element." The child combinator is optionally surrounded by whitespace. Thus, h1 > strong, h1> strong, and h1>strong are all equivalent. You can use or omit whitespace as you wish.

When viewing the document as a tree structure, it's easy to see that a child selector restricts its matches to elements that are directly connected in the tree. Figure 2-18 shows part of a document tree.



Figure 2-18. A document tree fragment

In this tree fragment, you can easily pick out parent-child relationships. For example, the a element is parent to the strong, but it is child to the $p$ element. You could match elements in this fragment with the selectors $p>a$ and $a>$ strong, but not $p>$ strong, since the strong is a descendant of the $p$ but not its child.

You can also combine descendant and child combinations in the same selector. Thus, table.summary $t d>p$ will select any $p$ element that is a child of a td element that is itself descended from a table element that has a class attribute containing the word summary.

## Selecting Adjacent Sibling Elements

Let's say you want to style the paragraph immediately after a heading or give a special margin to a list that immediately follows a paragraph. To select an element that immediately follows another element with the same parent, you use the adjacentsibling combinator, represented as a plus symbol (+). As with the child combinator, the symbol can be surrounded by whitespace at the author's discretion.

To remove the top margin from a paragraph immediately following an h1 element, write:

$h 1+p\{$ margin-top: 0; $\}$

The selector is read as, "selects any paragraph that immediately follows an h1 element that shares a parent with the p element."

To visualize how this selector works, it is easiest to once again consider a fragment of a document tree, shown in Figure 2-19.



Figure 2-19. Another document tree fragment

In this fragment, a pair of lists descends from a div element, one ordered and the other not, each containing three list items. Each list is an adjacent sibling, and the list items themselves are also adjacent siblings. However, the list items from the first list are not siblings of the second, since the two sets of list items do not share the same parent element. (At best, they're cousins.)

Remember that you can select the second of two adjacent siblings only with a single combinator. Thus, if you write li + li $\{$ font-weight: bold; $\}$, only the second and third items in each list will be boldfaced. The first list items will be unaffected, as illustrated in Figure 2-20.

To work properly, CSS requires that the two elements appear in "source order." In our example, an ol element is followed by a ul element. This allows you to select the second element with ol + ul, but you cannot select the first using the same syntax. For $u l+01$ to match, an ordered list must immediately follow an unordered list.



Figure 2-20. Selecting adjacent siblings

In addition, text content between two elements does not prevent the adjacent-sibling combinator from working. Consider this markup fragment, whose tree view would be the same as that shown in Figure 2-19:



Even though there is text between the two lists, you can still match the second list with the selector ol $+u l$. That's because the intervening text is not contained with a sibling element, but is instead part of the parent div. If you wrapped that text in a paragraph element, it would then prevent ol $+u l$ from matching the second list. Instead, you might have to write something like $o l+p+u l$.

As the following example illustrates, the adjacent-sibling combinator can be used in conjunction with other combinators:

html > body table + ul\{margin-top: $1.5 \mathrm{em} ;\}$

The selector translates as "selects any ul element that immediately follows a sibling table element that is descended from a body element that is itself a child of an html element."

Internet Explorer for Windows through IE6 does not support child and adjacent-sibling selectors. IE7 supports both.

## Pseudo-Classes and Pseudo-Elements

Things get really interesting with pseudo-class selectors and pseudo-element selectors. These selectors let you assign styles to structures that don't necessarily exist in the document, or to phantom classes that are inferred by the state of certain elements, or even by the state of the document itself. In other words, the styles are applied to pieces of a document based on something other than the structure of the document, and in a way that cannot be precisely deduced simply by studying the document's markup.

It may sound like I'm applying styles at random, but I'm not. Instead, I'm applying styles based on somewhat ephemeral conditions that can't be predicted in advance. However, the circumstances under which the styles will appear are, in fact, welldefined. Think of it this way: during a sporting event, whenever the home team scores, the crowd will cheer. You don't know exactly when during a game the team will score, but when it does, the crowd will cheer, just as predicted. The fact that you can't predict the moment of the cause doesn't make the effect any less expected.

## Pseudo-Class Selectors

Let's begin by examining pseudo-class selectors since they're better supported by browsers and are therefore more widely used.

Consider the anchor element (a), which, in HTML and XHTML, establishes a link from one document to another. Anchors are always anchors, of course, but some anchors refer to pages that have already been visited, while others refer to pages that have yet to be visited. You can't tell the difference by simply looking at the HTML markup, because in the markup, all anchors look the same. The only way to tell which links have been visited is by comparing the links in a document to the user's browser history. So, there are actually two basic types of anchors: visited and unvisited. These types are known as pseudo-classes, and the selectors that use them are called pseudo-class selectors.

To better understand these classes and selectors, consider how browsers behave with regard to links. The Mosaic convention designated that links to pages you hadn't visited were blue, and links to already visited pages were red (the red became purple in succeeding browsers such as Internet Explorer). So, if you could insert classes into anchors, such that any already visited anchor would have a class of, say, "visited," then you could write a style to make such anchors red:

a.visited \{color: red;\}

<a href="http://www.w3.org/" class="visited">W3C Web site</a>

However, such an approach requires that the classes on anchors change every time you visit a new page, which is a little silly. Instead, CSS defines pseudo-classes that make the anchors to visited pages act as though they have classes of "visited":

a:visited \{color: red; \}

Now, any anchor that points to a visited page will be red, and you don't even have to add class attributes to any of the anchors. Note the colon (:) in the rule. The colon separating the a and the visited is the calling card of a pseudo-class or pseudo-element. All pseudo-class and -element keywords are preceded by a colon.

## Link pseudo-classes

CSS2. 1 defines two pseudo-classes that apply only to hyperlinks. In HTML and XHTML 1.0 and 1.1, these are any a elements with an href attribute; in XML languages, they're any elements that act as links to another resource. Table 2-2 describes these two pseudo-classes.

Table 2-2. Link pseudo-classes

| Name | Description |
| :--- | :--- |
| $:$ :link | Refers to any anchor that is a hyperlink (i.e., has an href attribute) and points to an address that has not <br> been visited. Note that some browsers may incorrectly interpret : link to refer to any hyperlink, visited <br> or unvisited. |
| :visited | Refers to any anchor that is a hyperlink to an already visited address. |

The first of the pseudo-classes in Table 2-2 may seem a bit redundant. After all, if an anchor hasn't been visited, then it must be unvisited, right? If that's the case, all we should need is the following:

a \{color: blue; \}

a:visited \{color: red; \}

Although this format seems reasonable, it's actually not quite enough. The first of the rules shown here applies not only to unvisited links, but also to target anchors such as this one:

<a name="section4">4. The Lives of Meerkats</a>

The resulting text would be blue because the a element will match the rule a \{color: blue; \}, as shown above. Therefore, to avoid applying your link styles to target anchors, use the :link pseudo-class:

a:link \{color: blue;\} /* unvisited links are blue */

a:visited \{color: red;\} /* visited links are red */

As you may have already realized, the :link and :visited pseudo-class selectors are functionally equivalent to the body attributes link and vlink. Assume that an author wants all anchors to unvisited pages to be purple and anchors to visited pages to be silver. In HTML 3.2, this could be specified as follows:

<body link="purple" vlink="silver">

In CSS, the same effect would be accomplished with:



In the case of the CSS pseudo-classes, of course, you can apply more than just colors. Let's say you want visited links to be italicized and to have, in addition to their silver color, a strikethrough line, as shown in Figure 2-21.

## glish.com

h.hixie.ch

meyerweb.com

simon.incutio.com

stopdesign.com

tantek.com zeldman.com

## Web Blogs

These are the web logs ("blogs") I visit a lot. They're all written by people who know a lot about Web design and CSS in general. By reading them I can get a sense of the trends in design and thinking about document structure.

Figure 2-21. Applying multiple styles to a visited link

This is simply done with the following styles:

a:visited \{color: silver; text-decoration: line-through; font-style: italic; \}

This is a good place to revisit class selectors and show how they can be combined with pseudo-classes. For example, let's say you want to change the color of links that point outside your own site. If you assign a class to each of these anchors, it's easy:

<a href="http://www.mysite.net/">My home page</a>

<a href="http://www.site.net/" class="external">Another home page</a>

To apply different styles to the external link, all you need is a rule like this:

a.external:link, a.external:visited \{color: maroon;\}

This rule will make the second anchor in the preceding markup maroon, while the first anchor will remain the default color for hyperlinks (usually blue).

The same general syntax is used for ID selectors as well:

a\#footer-copyright:link\{font-weight: bold; \}

a\#footer-copyright:visited \{font-weight: normal; \}

Although :link and :visited are very useful, they're also static-they typically don't change the styling of a document after its initial display. Other pseudo-classes that aren't quite so static are available in CSS2.1; we'll review them next.

## Dynamic pseudo-classes

CSS2.1 defines three pseudo-classes that can change a document's appearance as a result of user behavior. These dynamic pseudo-classes have traditionally been used to style hyperlinks, but the possibilities are much wider. Table 2-3 describes these pseudo-classes.

Table 2-3. Dynamic pseudo-classes

| Name | Description |
| :--- | :--- |
| :focus | Refers to any element that currently has the input focus-i.e., can accept keyboard input or be activated |
| in some way. |  |

As with :link and :visited, these pseudo-classes are most familiar in the context of hyperlinks. Many web pages have styles that look like this:



The first two rules use static pseudo-classes, and the last two employ dynamic pseudo-classes. :active is analogous to the alink attribute in HTML 3.2, although, as before, you can apply color changes and any style you like to active links.



The order of the pseudo-classes is more important than it might seem at first. The usual recommendation is "link-visited-hover-active,"

although this has been modified to "link-visited-focus-hover-active." The next chapter explains why this particular ordering is important and discusses several reasons you might choose to change or even ignore the recommended ordering.

Notice that the dynamic pseudo-classes can be applied to any element, which is good since it's often useful to apply dynamic styles to elements that aren't links. For example, using this markup:

input:focus \{background: silver; font-weight: bold; \}

you could highlight a form element that is ready to accept keyboard input, as shown in Figure 2-22.

| Name | Eric Meyer |
| :---: | :---: |
| Title | Standards Evang |
| E-mail |  |

Figure 2-22. Highlighting a form element that has focus

You can also perform some rather odd feats by applying dynamic pseudo-classes to arbitrary elements. You might decide to give users a "highlight" effect by way of the following:

body *:hover \{background: yellow; \}

This rule will cause any element that's descended from the body element to display a yellow background when it's in a hover state. Headings, paragraphs, lists, tables, images, and anything else found inside the body will be changed to have a yellow background. You could also change the font, put a border around the element being hovered, or alter anything else the browser will allow.



Internet Explorer for Windows through IE6 does not permit dynamic pseudo-classes to select any elements other than hyperlinks. IE7 added support for : hover on any element, but not :focus styles for form elements.

## Real-world issues with dynamic styling

Dynamic pseudo-classes present some interesting issues and peculiarities. For example, it's possible to set visited and unvisited links to one font size and make hovered links a larger size, as shown in Figure 2-23:

a:link, a:visited \{font-size: $13 \mathrm{px}$; \}

a:hover \{font-size: 20px; \}



In.hixie.ch

meyerweb.com

simon.incutip.com

stopdesign.com These are the web logs ("blogs") I visit a lot. They're all written by people

tantek.com

zeldman.com who know a lot about Web design and CSS in general. By reading them I can get a sense of the trends in design and thinking about document structure.

Figure 2-23. Changing layout with dynamic pseudo-classes

As you can see, the user agent increases the size of the anchor while the mouse pointer hovers over it. A user agent that supports this behavior must redraw the document while an anchor is in hover state, which could force a reflow of all the content that follows the link.

However, the CSS specifications state that user agents are not required to redraw a document once it's been rendered for initial display, so you can't absolutely rely on your intended effect taking place. I strongly recommend that you avoid designs that depend on such behavior.

## Selecting a first child

Another static pseudo-class, : first-child, is used to select elements that are the first children of other elements. This particular pseudo-class is easily misunderstood, so an extended example is in order. Consider the following markup:

## <div>

$\langle p\rangle$ These are the necessary steps:</p>

<ul>

$<$ li>Insert key</li>

<li>Turn key <strong>clockwise</strong></li>

<li>Push accelerator</li>

$\langle/$ ul>

$\langle p\rangle$

Do <em>not</em> push the brake at the same time as the accelerator.

$\langle/ p\rangle$

</div>

In this example, the elements that are first children are the first $p$, the first li, and the strong and em elements. Given the following two rules:

p:first-child \{font-weight: bold; \}

li:first-child \{text-transform: uppercase; \}

you get the result shown in Figure 2-24.



Figure 2-24. Styling first children

The first rule boldfaces any $p$ element that is the first child of another element. The second rule uppercases any li element that is the first child of another element (which, in HTML, must be either an ol or a ul element).

The most common error is to assume that a selector like p:first-child will select the first child of a p element. However, remember the nature of pseudo-classes, which is to attach a sort of phantom class to the element associated with the pseudo-class. If you were to add actual classes to the markup, it would look like this:

<div>

<p class="first-child">These are the necessary steps:</p>

<ul>

$<$ li class="first-child">Insert key</li>

<li>Turn key <strong class="first-child">clockwise</strong></li>

$<$ li>Push accelerator</li>

</ul>



Therefore, if you want to select those em elements that are the first children of another element, you write em:first-child. This selector allows you to, for example, style the first item in a list, the first paragraph of a div, or the first $t d$ in a table row.



Internet Explorer for Windows through IE6 does not support :firstchild, but IE7 does.

## Selecting based on language

For situations where you want to select an element based on its language, you can use the :lang( ) pseudo-class. In terms of its matching patterns, the :lang( ) pseudo-class is exactly like the $\mid=$ attribute selector. For example, to italicize any element in French, you would write:

$*: \operatorname{lang}(\mathrm{fr})$ \{font-style: italic; \}

The primary difference between the pseudo-selector and the attribute selector is that the language information can be derived from a number of sources, some of which are outside the element itself. As CSS2. 1 states:

In HTML, the language is determined by a combination of the lang attribute, the META element, and possibly by information from the protocol (such as HTTP headers). XML uses an attribute called $\mathrm{xml}$ :lang, and there may be other document language-specific methods for determining the language.

Therefore, the pseudo-class is a bit more robust than the attribute selector and is probably a better choice in most cases where language-specific styling is needed.

## Combining pseudo-classes

With CSS2.1, you can combine pseudo-classes in the same selector. For example, you can make unvisited links red when they're hovered, but visited links maroon when they're hovered:

a:link:hover \{color: red;\}

a:visited:hover \{color: maroon;\}

The order you specify doesn't actually matter; you could also write a:hover:link to the same effect as a:link:hover. It's also possible to assign separate hover styles to unvisited and visited links that are in another language-for example, German:

a:link:hover:lang(de) \{color: gray; \}

a:visited:hover:lang(de) \{color: silver; \}

Be careful not to combine mutually exclusive pseudo-classes. For example, a link cannot be both visited and unvisited, so a:link:visited doesn't make any sense. User agents will most likely ignore such a selector and thus effectively ignore the entire rule, although this cannot be guaranteed, as different browsers will have different error-handling behaviors.



Internet Explorer for Windows through IE6 does not correctly recognize combined pseudo-classes. As with class-value combinations, it will pay attention to the last of the combined pseudo-classes. Thus, given a:link:hover, older versions of IE/Win will pay attention to the :hover but not the :link portion of the selector. IE7 does not suffer from this limitation; it correctly handles combined pseudo-classes.

## Pseudo-Element Selectors

Much as pseudo-classes assign phantom classes to anchors, pseudo-elements insert fictional elements into a document in order to achieve certain effects. Four pseudoelements are defined in CSS2.1: styling the first letter, styling the first line, and styling before and after elements.

## Styling the first letter

The first pseudo-element styles the first letter, and only that letter, of a block-level element:

p:first-letter \{color: red; \}

This rule causes the first letter of every paragraph to be colored red. Alternatively, you could make the first letter of each h2 twice as big as the rest of the heading:

h2:first-letter \{font-size: $200 \%$; \}

The result of this rule is illustrated in Figure 2-25.

## $\mathbf{T}_{\text {his is an h2 element }}$

Figure 2-25. The :first-letter pseudo-element in action

As I mentioned, this rule effectively causes the user agent to respond to a fictional element that encloses the first letter of each h2. It would look something like this:

<h2>[h2:first-letter](h2:first-letter)T</h2:first-letter>his is an h2 element</h2>

The :first-letter styles are applied only to the contents of the fictional element shown in the example. This [h2:first-letter](h2:first-letter) element does not appear in the document source. Instead, its existence is constructed on the fly by the user agent and is used to apply the :first-letter style(s) to the appropriate block of text. In other words, [h2:first-letter](h2:first-letter) is a pseudo-element. Remember, you don't have to add any new tags. The user agent will do it for you.

## Styling the first line

Similarly, : first-line can be used to affect the first line of text in an element. For example, you could make the first line of each paragraph in a document purple:

p:first-line \{color: purple; \}

In Figure 2-26, the style is applied to the first displayed line of text in each paragraph. This is true no matter how wide or narrow the display region is. If the first line contains only the first five words of the paragraph, then only those five words will be purple. If the first line contains the first 30 words of the element, then all 30 will be purple.

This is a paragraph of text that has only

one stylesheet applied to it. That style

causes the first line to be gray. No other

lines will be gray.

Figure 2-26. The :first-line pseudo-element in action

Because the text from "This" to "only" should be purple, the user agent employs a fictional markup that looks something like this:

<p><p:first-line>This is a paragraph of text that has only</p:first-line>

one stylesheet applied to it. That style

causes the first line to be purple. No other ...

If the first line of text were edited to include only the first seven words of the paragraph, then the fictional </p: first-line> would move back and occur just after the word "that."

## Restrictions on :first-letter and :first-line

In CSS2, the : first-letter and : first-line pseudo-elements can be applied only to block-level elements such as headings or paragraphs and not to inline-level elements such as hyperlinks. In CSS2.1, :first-letter applies to all elements. There are also limits on the CSS properties that may be applied to :first-line and :first-letter. Table 2-4 displays the limits.

Table 2-4. Properties permitted on pseudo-elements

## :first-letter

All font properties

color

All background properties

All margin properties

All padding properties

All border properties :first-line

All font properties

color

All background properties

word-spacing

letter-spacing

text-decoration

Table 2-4. Properties permitted on pseudo-elements (continued)



In addition, all pseudo-elements must be placed at the very end of the selector in which they appear. Therefore, it would not be legal to write $p$ :first-line em since the pseudo-element comes before the subject of the selector (the subject is the last element listed). The same rule applies to the other two pseudo-elements CSS2.1 defines.

## Style before and after elements

Let's say you want to preface every h2 element with a pair of silver square brackets as a typographical effect:

h2:before \{content: "]]"; color: silver;\}

CSS2.1 lets you insert generated content, and then style it directly using the pseudoelements :before and : after. Figure 2-27 illustrates an example.

## ]) This is an h2 element

Figure 2-27. Inserting content before an element

The pseudo-element is used to insert the generated content and to style it. To place content after an element, use the pseudo-element : after. You could end your documents with an appropriate finish:

body:after \{content: " The End.";\}

Generated content is a separate subject, and the entire topic (including more detail on :before and :after) is covered more thoroughly in Chapter 12.

## Summary

By using selectors based on the document's language, authors can create CSS rules that apply to a large number of similar elements just as easily as they can construct rules that apply in very narrow circumstances. The ability to group together both selectors and rules keeps style sheets compact and flexible, which incidentally leads to smaller file sizes and faster download times.

Selectors are the one thing that user agents usually must get right because the inability to correctly interpret selectors pretty much prevents a user agent from using CSS at all. On the flip side, it's crucial for authors to correctly write selectors because errors can prevent the user agent from applying the styles as intended. An integral part of correctly understanding selectors and how they can be combined is a strong grasp of how selectors relate to document structure and how mechanisms-such as inheritance and the cascade itself-come into play when determining how an element will be styled. This is the subject of the next chapter.

## CHAPTER 3

## Structure and the Cascade

Chapter 2 shows how document structure and CSS selectors allow you to apply a wide variety of styles to elements. Knowing that every valid document generates a structural tree, you can create selectors that target elements based on their ancestors, attributes, sibling elements, and more. The structural tree is what allows selectors to function and is also central to a similarly crucial aspect of CSS: inheritance.

Inheritance is the mechanism by which some property values are passed on from an element to its descendants. When determining which values should apply to an element, a user agent must consider not only inheritance but also the specificity of the declarations, as well as the origin of the declarations themselves. This process of consideration is what's known as the cascade. We will explore the interrelation between these three mechanisms - specificity, inheritance, and the cascade-in this chapter.

Above all, regardless of how abstract things may seem, keep going! Your perseverance will be rewarded.

## Specificity

You know from Chapter 2 that you can select elements using a wide variety of means. In fact, it's possible that the same element could be selected by two or more rules, each with its own selector. Let's consider the following three pairs of rules. Assume that each pair will match the same element:



Obviously, only one of the two rules in each pair can win out, since the matched elements can be only one color or the other. How do you know which one will win?

The answer is found in the specificity of each selector. For every rule, the user agent evaluates the specificity of the selector and attaches it to each declaration in the rule. When an element has two or more conflicting property declarations, the one with the highest specificity will win out.



This isn't the whole story in terms of conflict resolution. In fact, all style conflict resolution is handled by the cascade, which has its own 1s: section later in this chapter.

A selector's specificity is determined by the components of the selector itself. A specificity value is expressed in four parts, like this: $0,0,0,0$. The actual specificity of a selector is determined as follows:

- For every ID attribute value given in the selector, add $0,1,0,0$.
- For every class attribute value, attribute selection, or pseudo-class given in the selection, add $0,0,1,0$.
- For every element and pseudo-element given in the selector, add $0,0,0,1$. CSS2 contradicted itself as to whether pseudo-elements had any specificity at all, but CSS2.1 makes it clear that they do, and this is where they belong.
- Combinators and the universal selector do not contribute anything to the specificity (more on these values later).

For example, the following rules' selectors result in the indicated specificities:



Given a case where an em element is matched by both the second and fifth rules in the example above, that element will be maroon because the fifth rule's specificity outweighs the second's.

As an exercise, let's return to the pairs of rules from earlier in the section and fill in the specificities:



You've indicated the winning rule in each pair; in each case, it's because the specificity is higher. Notice how they're sorted. In the second pair, the selector h2.grape
wins because it has an extra 1: $0,0,1,1$ beats out $0,0,0,1$. In the third pair, the second rule wins because $0,1,0,1$ wins out over $0,0,1,7$. In fact, the specificity value $0,0,1,0$ will win out over the value $0,0,0,13$.

This happens because the values are sorted from left to right. A specificity of $1,0,0,0$ will win out over any specificity that begins with a 0 , no matter what the rest of the numbers might be. So $0,1,0,1$ wins over $0,0,1,7$ because the 1 in the first value's second position beats out the second 0 in the second value.

## Declarations and Specificity

Once the specificity of a selector has been determined, the value will be conferred on all of its associated declarations. Consider this rule:

h1 \{color: silver; background: black; \}

For specificity purposes, the user agent must treat the rule as if it were "ungrouped" into separate rules. Thus, the previous example would become:

h1 \{color: silver; \}

h1 \{background: black; \}

Both have a specificity of $0,0,0,1$, and that's the value conferred on each declaration. The same splitting-up process happens with a grouped selector as well. Given the rule:

## h1, h2.section \{color: silver; background: black; \}

the user agent treats it as follows:

h1 \{color: silver; \} /* 0,0,0,1*/

h1 \{background: black; \} $/ * 0,0,0,1 * /$

h2.section \{color: silver; \} $/ * 0,0,1,1 * /$

h2.section \{background: black; \} /* 0,0,1,1*/

This becomes important in situations where multiple rules match the same element and where some declarations clash. For example, consider these rules:



When applied to the following markup, the content will be rendered as shown in Figure 3-1:

<h1>Greetings!</h1>

<p class="aside">

It's a fine way to start a day, don't you think?

$\langle/ p\rangle$

$\langle p\rangle$

There are many ways to greet a person, but the words are not as important as the act of greeting itself.

$\langle/ p\rangle$

<h1>Salutations!</h1>
$\langle p>$

There is nothing finer than a hearty welcome from one's fellow man.

$\langle/ p\rangle$

<p class="aside">

Although a thick and juicy hamburger with bacon and mushrooms runs a close second. </p>

## Greetings!

It's a fine way to start a day, don't you think?

There are many ways to greet a person, but the words are not so important as the act of greeting itself.

## Salutations!

There is nothing finer than a hearty welcome from one's fellow man.

Although a thick and juicy hamburger with bacon and mushrooms runs a close second.

Figure 3-1. How different rules affect a document

In every case, the user agent determines which rules match an element, calculates all of the associated declarations and their specificities, determines which ones win out, and then applies the winners to the element to get the styled result. These machinations must be performed on every element, selector, and declaration. Fortunately, the user agent does it all automatically. This behavior is an important component of the cascade, which we will discuss later in this chapter.

## Universal Selector Specificity

As mentioned earlier, the universal selector does not contribute to the specificity of a selector. In other words, it has a specificity of $0,0,0,0$, which is different than having no specificity (as we'll discuss in "Inheritance"). Therefore, given the following two rules, a paragraph descended from a div will be black, but all other elements will be gray:

div p \{color: black; $\} / * 0,0,0,2 * /$

* \{color: gray; $\} / * 0,0,0,0 * /$

As you might expect, this means that the specificity of a selector that contains a universal selector along with other selectors is not changed by the presence of the universal selector. The following two selectors have exactly the same specificity:

div $p / * 0,0,0,2 * /$

body * strong $/ * 0,0,0,2 * /$

Combinators, by comparison, have no specificity at all-not even zero specificity. Thus, they have no impact on a selector's overall specificity.

## ID and Attribute Selector Specificity

It's important to note the difference in specificity between an ID selector and an attribute selector that targets an id attribute. Returning to the third pair of rules in the example code, we find:

html > body table tr[id="totals"] td ul > li \{color: maroon;\} /* 0,0,1,7 */

li\#answer \{color: navy; \} /* 0,1,0,1 (winner) */

The ID selector (\#answer) in the second rule contributes $0,1,0,0$ to the overall specificity of the selector. In the first rule, however, the attribute selector ([id="totals"]) contributes $0,0,1,0$ to the overall specificity. Thus, given the following rules, the element with an id of meadow will be green:

\#meadow \{color: green; $\} / * 0,1,0,0 * /$

*[id="meadow"] \{color: red; \} /* 0,0,1,0*/

## Inline Style Specificity

So far, we've seen specificities that begin with a zero, so you may be wondering why it's there at all. As it happens, that first zero is reserved for inline style declarations, which trump any other declaration's specificity. Consider the following rule and markup fragment:

h1 \{color: red;\}

<h1 style="color: green;">The Meadow Party</h1>

Given that the rule is applied to the h1 element, you would still probably expect the text of the $\mathrm{h} 1$ to be green. This is what happens in CSS2.1, and it happens because every inline declaration has a specificity of $1,0,0,0$.

This means that even elements with id attributes that match a rule will obey the inline style declaration. Let's modify the previous example to include an id:

h1\#meadow \{color: red; \}

<h1 id="meadow" style="color: green;">The Meadow Party</h1>

Thanks to the inline declaration's specificity, the text of the h1 element will still be green.



The primacy of inline style declarations is new to CSS2.1, and it exists to capture the state of web browser behavior at the time CSS2.1 was written. In CSS2, the specificity of an inline style declaration was 1,0,0 (CSS2 specificities had three values, not four). In other words, it had the same specificity as an ID selector, which would have easily overridden inline styles.

## Importance

Sometimes, a declaration is so important that it outweighs all other considerations. CSS2.1 calls these important declarations (for obvious reasons) and lets you mark them by inserting ! important just before the terminating semicolon in a declaration:

p.dark \{color: \#333 ! important; background: white;\}

Here, the color value of \#333 is marked ! important, whereas the background value of white is not. If you wish to mark both declarations as important, each declaration will need its own ! important marker:

p.dark \{color: \#333 !important; background: white ! important; \}

You must place !important correctly, or the declaration may be invalidated. ! important always goes at the end of the declaration, just before the semicolon. This placement is especially important-no pun intended-when it comes to properties that allow values containing multiple keywords, such as font:

p.light \{color: yellow; font: smaller Times, serif !important;\}

If ! important were placed anywhere else in the font declaration, the entire declaration would likely be invalidated and none of its styles applied.

Declarations that are marked ! important do not have a special specificity value, but are instead considered separately from nonimportant declarations. In effect, all !important declarations are grouped together, and specificity conflicts are resolved relative to each other. Similarly, all nonimportant declarations are considered together, with property conflicts resolved using specificity. In any case where an important and a nonimportant declaration conflict, the important declaration always wins.

Figure 3-2 illustrates the result of the following rules and markup fragment:

h1 \{font-style: italic; color: gray ! important; \}

.title \{color: black; background: silver;\}

* \{background: black ! important; \}

<h1 class="title">NightWing</h1>

Figure 3-2. Important rules always win



Important declarations and their handling are discussed in more detail in "The Cascade" later in this chapter.

## Inheritance

As important as specificity may be to understanding how declarations are applied to a document, another key concept is inheritance. Inheritance is the mechanism by which styles are applied not only to a specified element, but also to its descendants. If a color is applied to an h1 element, for example, then that color is applied to all text in the h1, even the text enclosed within child elements of that h1:

h1 \{color: gray; \}

<h1>Meerkat <em>Central</em></h1>

Both the ordinary $\mathrm{h} 1$ text and the em text are colored gray because the em element inherits the value of color. If property values could not be inherited by descendant elements, the em text would be black, not gray, and you'd have to color that element separately.

Inheritance also works well with unordered lists. Let's say you apply a style of color: gray; for ul elements:

ul \{color: gray; \}

You expect that a style that is applied to a ul will also be applied to its list items, and to any content of those list items. Thanks to inheritance, that's exactly what happens, as Figure 3-3 demonstrates.



Figure 3-3. Inheritance of styles

It's easier to see how inheritance works by turning to a tree diagram of a document. Figure 3-4 shows the tree diagram for a very simple document containing two lists: one unordered and the other ordered.



Figure 3-4. A simple tree diagram

When the declaration color: gray; is applied to the ul element, that element takes on that declaration. The value is then propagated down the tree to the descendant elements and continues on until there are no more descendants to inherit the value. Values are never propagated upward; that is, an element never passes values up to its ancestors.



There is an exception to the upward propagation rule in HTML: background styles applied to the body element can be passed to the html : element, which is the document's root element and therefore defines its canvas.

Inheritance is one of those things about CSS that is so basic that you almost never think about it unless you have to. However, you should still keep a few things in mind.

First, note that some properties are not inherited-generally as a result of simple common sense. For example, the property border (which is used to set borders on elements) does not inherit. A quick glance at Figure 3-5 reveals why this is the case. If borders were inherited, documents would become much more cluttered-unless the author took the extra effort to turn off the inherited borders.


Morbi justo. Aliquam nec felis. Proin molestie pellentesque tortor. Maecenas risus augue, dictum ut, sagittis eget, dignissim at, leo. In porttitor. Donec dapibus facilisis massa.

Figure 3-5. Why borders aren't inherited

As it happens, most of the box-model properties-including margins, padding, backgrounds, and borders - are not inherited for the same reason. After all, you wouldn't want all of the links in a paragraph to inherit a 30-pixel left margin from their parent element!

Inherited values have no specificity at all, not even zero specificity. This seems like an academic distinction until you work through the consequences of the lack of inherited specificity. Consider the following rules and markup fragment and compare them to the result shown in Figure 3-6:



## Meerkat Central

Welcome to the best place on the Web for meerkat information!

Figure 3-6. Zero specificity defeats no specificity

## Inherit the Bugs

Due to problems in various browser implementations, an author cannot rely on inheritance to operate as expected in all circumstances. For example, Navigator 4 (and, to a lesser extent, Explorer 4 and 5) does not inherit styles into tables. Thus, the following rule would result in a document with smaller text everywhere outside of tables:

body \{font-size: $0.8 \mathrm{em} ;\}$

This is not correct behavior under CSS, but it does exist, so authors have historically resorted to tricks such as:

body, table, th, td \{font-size: $0.8 \mathrm{em}$;

This is more likely, although still not guaranteed, to achieve the desired effect in buggy browsers.

Unfortunately, the above "fix" leads to an even worse problem in browsers that do implement inheritance correctly, such as IE6/Win, IE5/Mac, Netscape 6+, and others. In those browsers, you will end up with text inside a table cell that is 41 percent of the size of the user's default font size setting. It is often more dangerous to attempt to work around inheritance bugs in old browsers than it is to write correct CSS for updated browsers.

Since the universal selector applies to all elements and has zero specificity, its color declaration's value of gray wins out over the inherited value of black, which has no specificity at all. Therefore, the em element is rendered gray instead of black.

This example vividly illustrates one of the potential problems of using the universal selector indiscriminately. Because it can match any element, the universal selector often has the effect of short-circuiting inheritance. This can be worked around, but it's usually more sensible to avoid the problem in the first place by not using the universal selector indiscriminately.

The complete lack of specificity for inherited values is not a trivial point. For example, assume that a style sheet has been written such that all text in a "toolbar" is to be white on black:

\#toolbar \{color: white; background: black; \}

This will work as long as the element with an id of toolbar contains nothing but plain text. If, however, the text within this element is all hyperlinks (a elements), then the user agent's styles for hyperlinks will take over. In a web browser, this
means they'll likely be colored blue, since the browser's style sheet probably contains an entry like this:

a:link \{color: blue; \}

To overcome this problem, you must declare:

\#toolbar \{color: white; background: black; \}

\#toolbar a:link \{color: white; \}

By targeting the rule directly to the a elements within the toolbar, you'll get the result shown in Figure 3-7.

## Home $\mid$ Products $\mid$ Services $\mid$ Contact $\mid$ About

Figure 3-7. Directly assigning styles to the relevant elements

## The Cascade

Throughout this chapter, we've skirted one rather important issue: what happens when two rules of equal specificity apply to the same element? How does the browser resolve the conflict? For example, say you have the following rules:

h1 \{color: red; \}

h1 \{color: blue; \}

Which one wins? Both have a specificity of $0,0,0,1$, so they have equal weight and should both apply. That simply can't be the case because the element can't be both red and blue. But which will it be?

Finally, the name "Cascading Style Sheets" makes some sense. CSS is based on a method of causing styles to cascade together, which is made possible by combining inheritance and specificity. The cascade rules for CSS2.1 are simple enough:

1. Find all rules that contain a selector that matches a given element.
2. Sort by explicit weight all declarations applying to the element. Those rules marked ! important are given higher weight than those that are not. Sort by origin all declarations applying to a given element. There are three origins: author, reader, and user agent. Under normal circumstances, the author's styles win out over the reader's styles. !important reader styles are stronger than any other styles, including !important author styles. Both author and reader styles override the user agent's default styles.
3. Sort by specificity all declarations applying to a given element. Those elements with a higher specificity have more weight than those with lower specificity.
4. Sort by order all declarations applying to a given element. The later a declaration appears in the style sheet or document, the more weight it is given. Declarations that appear in an imported style sheet are considered to come before all declarations within the style sheet that imports them.

To be perfectly clear about how this all works, let's consider three examples that illustrate the last three of the four cascade rules.

## Sorting by Weight and Origin

Under the second rule, if two rules apply to an element, and one is marked ! important, the important rule wins out:

p \{color: gray ! important; \}

<p style="color: black;">Well, <em>hello</em> there!</p>

Despite the fact that there is a color assigned in the style attribute of the paragraph, the ! important rule wins out, and the paragraph is gray. This gray is inherited by the em element as well.

Furthermore, the origin of a rule is considered. If an element is matched by normalweight styles in both the author's style sheet and the reader's style sheet, then the author's styles are used. For example, assume that the following styles come from the indicated origins:



In this case, emphasized text within paragraphs is colored black, not yellow, because normal-weight author styles win out over normal-weight reader styles. However, if both rules are marked ! important, the situation changes:



Now the emphasized text in paragraphs will be yellow, not black.

As it happens, the user agent's default styles-which are often influenced by the user preferences-are figured into this step. The default style declarations are the least influential of all. Therefore, if an author-defined rule applies to anchors (e.g., declaring them to be white), then this rule overrides the user agent's defaults.

To sum up, there are five levels to consider in terms of declaration weight. In order of most to least weight, these are:

1. Reader important declarations
2. Author important declarations
3. Author normal declarations
4. Reader normal declarations
5. User agent declarations

Authors typically need to worry about only the first four weight levels, since anything declared will win out over the user agent styles.

## Sorting by Specificity

According to the third rule, if conflicting declarations apply to an element and they all have the same weight, they should be sorted by specificity, with the most specific declaration winning out. For example:

p\#bright \{color: silver; $\}$

p \{color: black; $\}$

<p id="bright">Well, hello there!</p>

Given the rules shown, the text of the paragraph will be silver, as illustrated in Figure 3-8. Why? Because the specificity of p\#bright $(0,1,0,1)$ overrode the specificity of $p(0,0,0,1)$, even though the latter rule comes later in the style sheet.

$$
\text { Well, hello there! }
$$

Figure 3-8. Higher specificity wins out over lower specificity

## Sorting by Order

Finally, under the fourth rule, if two rules have exactly the same weight, origin, and specificity, then the one that occurs later in the style sheet wins out. Therefore, let's return to our earlier example, where we find the following two rules in the document's style sheet:

h1 \{color: red; \}

h1 \{color: blue; \}

Because its rule comes later in the style sheet, the value of color for all h1 elements in the document will be blue, not red. Any rule that is contained in the document with a higher weight than the imported rule wins out. This is true even if the rule is part of the document's style sheet and not part of an element's style attribute. Consider the following:



In this case, the second rule shown will win out over the imported rule because it is a part of the document's style sheet.

For the purposes of this rule, styles specified in the style attribute of an element are considered to be at the end of the document's style sheet, which places them after all other rules. However, this is a largely academic point, since inline style declarations have a higher specificity than any style sheet selector in CSS2.1.

Remember that in CSS2, inline style declarations have a specificity equal to ID selectors. In a CSS2 (but not CSS2.1) user agent, style - attribute declarations are considered to appear at the end of the document's style sheet and are sorted by weight, origin, specificity, and order as with any other declaration in the style sheet.

Order sorting is the reason behind the often-recommended ordering of link styles. The recommendation is that you array your link styles in the order link-visitedhover-active, or LVHA, like this:



Thanks to the information in this chapter, you now know that the specificity of all of these selectors is the same: $0,0,1,0$. Because they all have the same weight, origin, and specificity, the last one that matches an element will win out. An unvisited link that is being "clicked" is matched by three of the rules-:link, :hover, and :active—so the last one of those three declared will win out. Given the LVHA ordering, : active will win, which is likely what the author intended.

Assume for a moment that you decide to ignore the common ordering and alphabetize your link styles instead. This would yield:

:active \{color: orange; \}

:hover \{color: red; $\}$

:link \{color: blue; \}

:visited \{color: purple; \}

Given this ordering, no link would ever show : hover or : active styles because the :link and :visited rules come after the other two. Every link must be either visited or unvisited, so those styles will always override the : hover rule.

Let's consider a variation on the LVHA order that an author might want to use. In this ordering, only unvisited links will get a hover style; visited links do not. Both visited and unvisited links will get an active style:



Of course, sometimes such conflicts arise when all the states attempt to set the same property. If each state styles a different property, then the order does not matter. In the following case, the link styles could be given in any order and would still function:
:link \{font-weight: bold; \}

:visited \{font-style: italic; \}

:hover \{color: red; \}

:active $\{$ background: yellow; $\}$

You may also have realized that the order of the :link and :visited styles doesn't matter. You could order the styles LVHA or VLHA with no ill effect. However, LVHA tends to be preferred because it was recommended in the CSS2 specification and also because the mnemonic "LoVe-HA!" gained rather wide currency. (There's some bitterness out there, apparently.)

The ability to chain pseudo-classes together eliminates these worries. The following could be listed in any order without any negative effects:



Because each rule applies to a unique set of link states, they do not conflict. Therefore, changing their order will not change the styling of the document. The last two rules do have the same specificity, but that doesn't matter. A hovered unvisited link will not be matched by the rule regarding hovered visited links, and vice versa. If we were to add active-state styles, then order would start to matter again. Consider:



If the active styles were moved before the hover styles, they would be ignored. Again, this would happen due to specificity conflicts. The conflicts could be avoided by adding more pseudo-classes to the chains, like this:

:link:hover:active \{color: orange;\}

:visited:hover:active \{color: silver;\}

Chained pseudo-classes, which lessen worries about specificity and ordering, would be used much more often if Internet Explorer had historically supported them. (See Chapter 2 for more information on this subject.)

## Non-CSS Presentational Hints

It is possible that a document will contain presentational hints that are not CSS-e.g., the font element. Non-CSS hints are treated as if they have a specificity of 0 and appear at the beginning of the author's style sheet. Such presentation hints will be overridden by any author or reader styles, but not by the user agent's styles.

## Summary

Perhaps the most fundamental aspect of Cascading Style Sheets is the cascade itself-the process by which conflicting declarations are sorted out and from which the final document presentation is determined. Integral to this process is the specificity of selectors and their associated declarations, and the mechanism of inheritance.

In the next chapter, we will look at the many types of units that are used to give property values their meaning. Once we have completed that discussion, the fundamentals will be out of the way, and you'll be ready to learn about the properties used to style documents.

## CHAPTER 4

## Values and Units

In this chapter, we'll tackle the elements that are the basis for almost everything you can do with CSS: the units that affect the colors, distances, and sizes of a whole host of properties. Without units, you couldn't declare that a paragraph should be purple, or that an image should have 10 pixels of blank space around it, or that a heading's text should be a certain size. By understanding the concepts put forth here, you'll be able to learn and use the rest of CSS much more quickly.

## Numbers

There are two types of numbers in CSS: integers ("whole" numbers) and reals (fractional numbers). These number types serve primarily as the basis for other value types, but, in a few instances, raw numbers can be used as a value for a property.

In CSS2.1, a real number is defined as an integer that is optionally followed by a decimal and fractional numbers. Therefore, the following are all valid number values: 15.5, -270.00004, and 5. Both integers and reals may be either positive or negative, although properties can (and often do) restrict the range of numbers they will accept.

## Percentages

A percentage value is a calculated real number followed by a percentage sign (\%). Percentage values are nearly always relative to another value, which can be anything, including the value of another property of the same element, a value inherited from the parent element, or a value of an ancestor element. Any property that accepts percentage values will define any restrictions on the range of allowed percentage values, and will also define the degree to which the percentage is relatively calculated.

## Color

One of the first questions every starting web author asks is, "How do I set colors on my page?" Under HTML, you have two choices: you could use one of a small number of colors with names, such as red or purple, or employ a vaguely cryptic method using hexadecimal codes. Both of these methods for describing colors remain in CSS, along with some other-and, I think, more intuitive-methods.

## Named Colors

Assuming that you're content to pick from a small, basic set of colors, the easiest method is simply to use the name of the color you want. CSS calls these color choices, logically enough, named colors.

Contrary to what some browser makers might have you believe, you have a limited palette of valid named-color keywords. For example, you're not going to be able to choose "mother-of-pearl" because it isn't a defined color. As of CSS2.1, the CSS specification defines 17 color names. These are the 16 colors defined in HTML 4.01 plus orange:

| aqua | fuchsia | lime | olive | red | white |
| :--- | :--- | :--- | :--- | :--- | :--- |
| black | gray | maroon | orange | silver | yellow |
| blue | green | navy | purple | teal |  |

So, let's say you want all first-level headings to be maroon. The best declaration would be:

h1 \{color: maroon; \}

Simple and straightforward, isn't it? Figure 4-1 shows a few more examples:

h1 \{color: gray; \}

h2 \{color: silver; $\}$

h3 \{color: black; \}

## Greetings!

## Salutations!

Howdy-do!

Figure 4-1. Naming colors

Of course, you've probably seen (and maybe even used) color names other than the ones listed earlier. For example, if you specify:

h1 \{color: lightgreen; \}

It's likely that all of your h1 elements will indeed turn light green, despite lightgreen not being on the list of named colors in CSS2.1. It works because most web browsers recognize as many as 140 color names, including the standard 17. These extra colors are defined in the CSS3 Color specification, which is not covered in this book. The 17 standard colors (as of this writing) are likely to be more reliable than the longer list of 140 or so colors because the color values for these 17 are defined by CSS2.1. The extended list of 140 colors given in CSS3 is based on the standard X11 RGB values that have been in use for decades, so they are likely to be very well supported.

Fortunately, there are more detailed and precise ways to specify colors in CSS. The advantage is that, with these methods, you can specify any color in the color spectrum, not just 17 (or 140) named colors.

## Colors by RGB

Computers create colors by combining different levels of red, green, and blue, a combination that is often referred to as RGB color. In fact, if you were to open up an old CRT computer monitor and dig far enough into the projection tube, you would discover three "guns." (I don't recommend trying to find the guns, though, if you're worried about voiding the monitor's warranty.) These guns shoot out electron beams at varying intensities at each point on the screen. Then, the brightness of each beam combines at those points on your screen, forming all of the colors you see. Each point is known as a pixel, which is a term we'll return to later in this chapter. Even though most monitors these days don't use electron guns, their color output is still based on RGB mixtures.

Given the way colors are created on a monitor, it makes sense that you should have direct access to those colors, determining your own mixture of the three for maximum control. That solution is complex, but possible, and the payoffs are worth it because there are very few limits on which colors you can produce. There are four ways to affect color in this manner.

## Functional RGB colors

There are two color value types that use functional RGB notation as opposed to hexadecimal notation. The generic syntax for this type of color value is $\mathrm{rgb}$ (color), where color is expressed using a triplet of either percentages or integers. The percentage values can be in the range $0 \%-100 \%$, and the integers can be in the range $0-255$.

Thus, to specify white and black, respectively, using percentage notation, the values would be:

$$
\operatorname{rgb}(100 \%, 100 \%, 100 \%)
$$

$\operatorname{rgb}(0 \%, 0 \%, 0 \%)$

Using the integer-triplet notation, the same colors would be represented as:

$\operatorname{rgb}(255,255,255)$

$\operatorname{rgb}(0,0,0)$

Assume you want your h1 elements to be a shade of red that lies between the values for red and maroon. red is equivalent to $\operatorname{rgb}(100 \%, 0 \%, 0 \%)$, whereas maroon is equal to $(50 \%, 0 \%, 0 \%)$. To get a color between those two, you might try this:

h1 $\{$ color: $\operatorname{rgb}(75 \%, 0 \%, 0 \%)$; \}

This makes the red component of the color lighter than maroon, but darker than red. If, on the other hand, you want to create a pale red color, you would raise the green and blue levels:

h1 $\{$ color: $\operatorname{rgb}(75 \%, 50 \%, 50 \%)$; \}

The closest equivalent color using integer-triplet notation is:

h1 \{color: $\operatorname{rgb}(191,127,127)$; \}

The easiest way to visualize how these values correspond to color is to create a table of gray values. Besides, grayscale printing is all we can afford for this book, so that's what we'll do in Figure 4-2:

p.one $\{$ color: $\operatorname{rgb}(0 \%, 0 \%, 0 \%) ;\}$

p.two $\{$ color: $\operatorname{rgb}(20 \%, 20 \%, 20 \%) ;\}$

p.three $\{$ color: $\operatorname{rgb}(40 \%, 40 \%, 40 \%) ;\}$

p.four $\{$ color: $\operatorname{rgb}(60 \%, 60 \%, 60 \%) ;\}$

p.five $\{$ color: $\operatorname{rgb}(80 \%, 80 \%, 80 \%) ;\}$

p.six $\{$ color: $\operatorname{rgb}(0,0,0)$; $\}$

p.seven \{color: $\operatorname{rgb}(51,51,51) ;\}$

p.eight \{color: $\operatorname{rgb}(102,102,102) ;\}$

p.nine \{color: $\operatorname{rgb}(153,153,153) ;\}$

p.ten $\{$ color: $\operatorname{rgb}(204,204,204)$; \}



Figure 4-2. Text set in shades of gray

Of course, since we're dealing in shades of gray, all three RGB values are the same in each statement. If any one of them were different from the others, then a color would start to emerge. If, for example, $\operatorname{rgb}(50 \%, 50 \%, 50 \%)$ were modified to be $\operatorname{rgb}(50 \%, 50 \%, 60 \%)$, the result would be a medium-dark color with just a hint of blue.

It is possible to use fractional numbers in percentage notation. You might, for some reason, want to specify that a color be exactly 25.5 percent red, 40 percent green, and 98.6 percent blue:

h2 \{color: $\operatorname{rgb}(25.5 \%, 40 \%, 98.6 \%)$; \}

A user agent that ignores the decimal points (and some do) should round the value to the nearest integer, resulting in a declared value of $\operatorname{rgb}(26 \%, 40 \%, 99 \%)$. In integer triplets, of course, you are limited to integers.

Values that fall outside the allowed range for each notation are "clipped" to the nearest range edge, meaning that a value that is greater than $100 \%$ or less than $0 \%$ will default to those allowed extremes. Thus, the following declarations would be treated as if they were the values indicated in the comments:

P.one $\{$ color: $\operatorname{rgb}(300 \%, 4200 \%, 110 \%) ;\} \quad / * \quad 100 \%, 100 \%, 100 \% \quad * /$

P.two $\{$ color: $\operatorname{rgb}(0 \%,-40 \%,-5000 \%) ;\} \quad / * 0 \%, 0 \%, 0 \% * /$

p.three $\{$ color: $\operatorname{rgb}(42,444,-13) ;\} \quad / * 42,255,0 * /$

Conversion between percentages and integers may seem arbitrary, but there's no need to guess at the integer you want-there's a simple formula for calculating them. If you know the percentages for each of the RGB levels you want, then you need only apply them to the number 255 to get the resulting values. Let's say you have a color of 25 percent red, 37.5 percent green, and 60 percent blue. Multiply each of these percentages by 255 , and you get $63.75,95.625$, and 153 . Round these values to the nearest integers, and voilà: $\operatorname{rgb}(64,96,153)$.

Of course, if you already know the percentage values, there isn't much point in converting them into integers. Integer notation is more useful for people who use programs such as Photoshop, which can display integer values in the "Info" dialog, or for those who are so familiar with the technical details of color generation that they normally think in values of $0-255$. Then again, such people are probably more familiar with thinking in hexadecimal notation, which is our next topic.

## Hexadecimal RGB colors

CSS allows you to define a color using the same hexadecimal color notation so familiar to HTML web authors:



Computers have been using "hex notation" for quite some time now, and programmers are typically either trained in its use or pick it up through experience. Their familiarity with hexadecimal notation likely led to its use in setting colors in oldschool HTML. The practice was simply carried over to CSS.

Here's how it works: by stringing together three hexadecimal numbers in the range 00 through FF, you can set a color. The generic syntax for this notation is \#RRGGBB. Note that there are no spaces, commas, or other separators between the three numbers.

Hexadecimal notation is mathematically equivalent to the integer-pair notation discussed in the previous section. For example, $\operatorname{rgb}(255,255,255)$ is precisely equivalent to \#FFFFFF, and $\operatorname{rgb}(51,102,128)$ is the same as \#336680. Feel free to use whichever notation you prefer-it will be rendered identically by most user agents. If you have a calculator that converts between decimal and hexadecimal, making the jump from one to the other should be pretty simple.

For hexadecimal numbers that are composed of three matched pairs of digits, CSS permits a shortened notation. The generic syntax of this notation is \#RGB:



As you can see from the markup, there are only three digits in each color value. However, since hexadecimal numbers between 00 and FF need two digits each, and you have only three total digits, how does this method work?

The answer is that the browser takes each digit and replicates it. Therefore, \#F00 is equivalent to \#FF0000, \#6FA would be the same as \#66FFAA, and \#FFF would come out \#FFFFFF, which is the same as white. Obviously, not every color can be represented in this manner. Medium gray, for example, would be written in standard hexadecimal notation as \#808080. This cannot be expressed in shorthand; the closest equivalent would be \#888, which is the same as \#888888.

## Bringing the colors together

Table 4-1 presents an overview of some of the colors we've discussed. These color keywords might not be recognized by browsers and, therefore, they should be defined with either RGB or hex-pair values (just to be safe). In addition, there are some shortened hexadecimal values that do not appear at all. In these cases, the longer (six-digit) values cannot be shortened because they do not replicate. For example, the value \#880 expands to \#888800, not \#808000 (otherwise known as olive). Therefore, there is no shortened version of $\# 808000$, and the appropriate entry in the table is blank.

Table 4-1. Color equivalents

| Color | Percentage | Numeric | Hexadecimal | Short hex |
| :--- | :--- | :--- | :--- | :--- |
| red | $\operatorname{rgb}(100 \%, 0 \%, 0 \%)$ | $\operatorname{rgb}(255,0,0)$ | \#FF0000 | \#F00 |
| orange | $\operatorname{rgb}(100 \%, 40 \%, 0 \%)$ | $\operatorname{rgb}(255,102,0)$ | \#FF6600 | \#F60 |
| yellow | $\operatorname{rgb}(100 \%, 100 \%, 0 \%)$ | $\operatorname{rgb}(255,255,0)$ | \#FFFF00 | \#FF0 |
| green | $\operatorname{rgb}(0 \%, 50 \%, 0 \%)$ | $\operatorname{rgb}(0,128,0)$ | \#008000 |  |
| blue | $\operatorname{rgb}(0 \%, 0 \%, 100 \%)$ | $\operatorname{rgb}(0,0,255)$ | \#0000FF | \#00F |

Table 4-1. Color equivalents (continued)

| Color | Percentage | Numeric | Hexadecimal | Short hex |
| :--- | :--- | :--- | :--- | :--- |
| aqua | $\operatorname{rgb}(0 \%, 100,100 \%)$ | $\operatorname{rgb}(0,255,255)$ | \#00FFFF | \#OFF |
| black | $\operatorname{rgb}(0 \%, 0 \%, 0 \%)$ | $\operatorname{rgb}(0,0,0)$ | \#000000 | \#000 |
| fuchsia | $\operatorname{rgb}(100 \%, 0 \%, 100)$ | $\operatorname{rgb}(255,0,255)$ | \#FF00FF | \#FOF |
| gray | $\operatorname{rgb}(50 \%, 50 \%, 50 \%)$ | $\operatorname{rgb}(128,128,128)$ | \#808080 |  |
| lime | $\operatorname{rgb}(0 \%, 100,0 \%)$ | $\operatorname{rgb}(0,255,0)$ | \#00FF00 | \#OF0 |
| maroon | $\operatorname{rgb}(50 \%, 0 \%, 0 \%)$ | $\operatorname{rgb}(128,0,0)$ | \#800000 |  |
| navy | $\operatorname{rgb}(0 \%, 0 \%, 50 \%)$ | $\operatorname{rgb}(0,0,128)$ | \#000080 |  |
| olive | $\operatorname{rgb}(50 \%, 50 \%, 0 \%)$ | $\operatorname{rgb}(128,128,0)$ | \#808000 |  |
| purple | $\operatorname{rgb}(50 \%, 0 \%, 50 \%)$ | $\operatorname{rgb}(128,0,128)$ | \#800080 |  |
| silver | $\operatorname{rgb}(75 \%, 75 \%, 75 \%)$ | $\operatorname{rgb}(192,192,192)$ | \#C0C0C0 |  |
| teal | $\operatorname{rgb}(0 \%, 50 \%, 50 \%)$ | $\operatorname{rgb}(0,128,128)$ | \#008080 |  |
| white | $\operatorname{rgb}(100 \%, 100 \%, 100 \%)$ | $\operatorname{rgb}(255,255,255)$ | \#FFFFFF | \#FFF |

## Web-safe colors

The "web-safe" colors are those colors that generally avoid dithering on 256-color computer systems. Web-safe colors can be expressed in multiples of the RGB values $20 \%$ and 51 , and the corresponding hex-pair value 33 . Also, $0 \%$ or 0 is a safe value. So, if you use RGB percentages, make all three values either $0 \%$ or a number divisible by 20 -for example, $\operatorname{rgb}(40 \%, 100 \%, 80 \%)$ or $\operatorname{rgb}(60 \%, 0 \%, 0 \%)$. If you use RGB values on the $0-255$ scale, the values should be either 0 or divisible by 51 , as in $\operatorname{rgb}(0,204,153)$ or $\operatorname{rgb}(255,0,102)$.

With hexadecimal notation, any triplet that uses the values $00,33,66,99, \mathrm{CC}$, and FF is considered to be web-safe. Examples are \#669933, \#00CC66, and \#FF00FF. This means the shorthand hex values that are web-safe are $0,3,6,9, C$, and F; therefore, \#693, \#0C6, and \#FOF are examples of web-safe colors.

## Length Units

Many CSS properties, such as margins, depend on length measurements to properly display various page elements. It's no surprise, then, that there are a number of ways to measure length in CSS.

All length units can be expressed as either positive or negative numbers followed by a label (although some properties will accept only positive numbers). You can also use real numbers-that is, numbers with decimal fractions, such as 10.5 or 4.561. All length units are followed by a two-letter abbreviation that represents the actual unit of length being specified, such as in (inches) or pt (points). The only exception to this rule is a length of 0 (zero), which need not be followed by a unit.

These length units are divided into two types: absolute length units and relative length units.

## Absolute Length Units

We'll start with absolute units because they're easiest to understand, despite the fact that they're almost unusable in web design. The five types of absolute units are as follows:

## Inches (in)

As you might expect, this notation refers to the inches you'd find on a ruler in the United States. (The fact that this unit is in the specification, even though almost the entire world uses the metric system, is an interesting insight into the pervasiveness of U.S. interests on the Internet-but let's not get into virtual sociopolitical theory right now.)

Centimeters (cm)

Refers to the centimeters that you'd find on rulers the world over. There are 2.54 centimeters to an inch, and one centimeter equals 0.394 inches.

## Millimeters ( $\mathrm{mm}$ )

For those Americans who are metric-challenged, there are 10 millimeters to a centimeter, so an inch equals 25.4 millimeters, and a millimeter equals 0.0394 inches.

Points (pt)

Points are standard typographical measurements that have been used by printers and typesetters for decades and by word-processing programs for many years. Traditionally, there are 72 points to an inch (points were defined before widespread use of the metric system). Therefore, the capital letters of text set to 12 points should be one-sixth of an inch tall. For example, $p$ \{font-size: 18pt;\} is equivalent to $p$ \{font-size: 0.25 in; $\}$.

Picas (pc)

Picas are another typographical term. A pica is equivalent to 12 points, which means there are 6 picas to an inch. As just shown, the capital letters of text set to 1 pica should be one-sixth of an inch tall. For example, $p$ \{font-size: $1.5 p c ;\}$ would set text to the same size as the example declarations found in the definition of points.

Of course, these units are really useful only if the browser knows all the details of the monitor on which your page is displayed, the printer you're using, or whatever other user agent might apply. On a web browser, display is affected by the size of the monitor and the resolution to which the monitor is set-and there isn't much that you, as the author, can do about these factors. You can only hope that, if nothing else, the measurements will be consistent in relation to each other-that is, that a setting of 1.0in will be twice as large as 0.5in, as shown in Figure 4-3.



Figure 4-3. Setting absolute-length left margins

## Working with absolute lengths

If a monitor's resolution is set to 1,024 pixels wide by 768 pixels tall, its screen size is exactly 14.22 inches wide by 10.67 inches tall, and it is filled entirely by the display area, then each pixel will be 1/72 of an inch wide and tall. As you might guess, this scenario is a very, very rare occurrence (have you ever seen a monitor with those dimensions?). So, on most monitors, the actual number of pixels per inch (ppi) is higher than 72-sometimes much higher, up to 120 ppi and beyond.

As a Windows user, you might be able to set your display driver to make the display of elements correspond correctly to real-world measurements. To try, click Start $\rightarrow$ Settings $\rightarrow$ Control Panel. In the Control Panel, double-click Display. Click the Settings tab, and click Advanced to reveal a dialog box (which may differ on each PC). You should see a section labeled Font Size; select Other, and then hold a ruler up to the screen and move the slider until the onscreen ruler matches the physical ruler. Click OK until you're free of dialog boxes, and you're set.

If you're a Mac Classic user, there's no place to set this information in the operating system - the Mac Classic OS (that is, any version previous to OS X) makes an assumption about the relationship between on-screen pixels and absolute measurements by declaring your monitor to have 72 pixels to the inch. This assumption is totally wrong, but it's built into the operating system, and therefore pretty much unavoidable. As a result, on many Classic Mac-based web browsers, any point value will be equivalent to the same length in pixels: 24pt text will be 24 pixels tall, and 8pt text will be 8 pixels tall. This is, unfortunately, slightly too small to be legible. Figure 4-4 illustrates the problem.

## This paragraph has 24-point text.

## Tusperagyent bas-pesters.

Figure 4-4. Teensy text makes for difficult reading

In OS X, the built-in assumed ppi value is closer to Windows: 96ppi. This doesn't make it any more correct, but it's at least consistent with Windows machines.

The Classic Mac display problem is an excellent example of why points should be strenuously avoided when designing for the Web. Ems, percentages, and even pixels are all preferable to points where browser display is concerned.



Beginning with Internet Explorer 5 for Macintosh and Gecko-based browsers such as Netscape $6+$, the browser itself contains a prefer: ence setting for setting ppi values. You can pick the standard Macintosh ratio of 72ppi, the common Windows ratio of 96ppi, or a value that matches your monitor's ppi ratio. This last option works similarly to the Windows setting just described, where you use a sliding scale to compare to a ruler and thus get an exact match between your monitor and physical-world distances.

Despite all we've seen, let's make the highly suspect assumption that your computer knows enough about its display system to accurately reproduce real-world measurements. In that case, you could make sure every paragraph has a top margin of half an inch by declaring $p$ \{margin-top: 0.5 in; $\}$. Regardless of font size or any other circumstances, a paragraph will have a half-inch top margin.

Absolute units are much more useful in defining style sheets for printed documents, where measuring things in terms of inches, points, and picas is common. As you've seen, attempting to use absolute measurements in web design is perilous at best, so let's turn to some more useful units of measure.

## Relative Length Units

Relative units are so called because they are measured in relation to other things. The actual (or absolute) distance they measure can change due to factors beyond their control, such as screen resolution, the width of the viewing area, the user's preference settings, and a whole host of other things. In addition, for some relative units, their size is almost always relative to the element that uses them and will thus change from element to element.

There are three relative length units: em, ex, and px. The first two stand for "emheight" and "x-height," which are common typographical measurements; however, in CSS, they have meanings you might not expect if you are familiar with typography. The last type of length is px, which stands for "pixels." A pixel is one of the dots you can see on your computer's monitor if you look closely enough. This value is defined as relative because it depends on the resolution of the display device, a subject we'll soon cover.

## em and ex units

First, however, let's consider em and ex. In CSS, one "em" is defined to be the value of font-size for a given font. If the font-size of an element is 14 pixels, then for that element, $1 \mathrm{em}$ is equal to 14 pixels.

Obviously, this value can change from element to element. For example, let's say you have an h1 with a font size of 24 pixels, an h2 element with a font size of 18 pixels, and a paragraph with a font size of 12 pixels. If you set the left margin of all three at 1em, they will have left margins of 24 pixels, 18 pixels, and 12 pixels, respectively:



When setting the size of the font, on the other hand, the value of em is relative to the font size of the parent element, as illustrated by Figure 4-5.

| Left margin $=24$ pixels |
| :--- |
| Left margin $=18$ pixels |
| Left margin $=12$ pixels |

Figure 4-5. Using em for margins and font sizing

ex, on the other hand, refers to the height of a lowercase $x$ in the font being used. Therefore, if you have two paragraphs in which the text is 24 points in size, but each paragraph uses a different font, then the value of ex could be different for each paragraph. This is because different fonts have different heights for $x$, as you can see in Figure 4-6. Even though the examples use 24-point text-and therefore, each example's em value is 24 points- the $\mathrm{x}$-height for each is different.

## Practical issues with em and ex

Of course, everything I've just explained is completely theoretical. I've outlined what is supposed to happen, but in practice, many user agents get their value for ex by taking the value of em and dividing it in half. Why? Apparently, most fonts don't have the value of their ex height built-in, and it's a very difficult thing to compute. Since most fonts have lowercase letters that are about half as tall as uppercase letters, it's a convenient fiction to assume that $1 \mathrm{ex}$ is equivalent to $0.5 \mathrm{em}$.

A few browsers, including Internet Explorer 5 for Mac, actually attempt to determine the $\mathrm{x}$-height of a given font by internally rendering a lowercase $x$ and counting pixels to determine its height compared to that of the font-size value used to create the character. This is not a perfect method, but it's much better than simply making 1 ex equal to $0.5 \mathrm{em}$. We CSS practitioners can hope that, as time goes on, more user agents will start using real values for ex and the half-em shortcut will fade into the past.

$$
\begin{array}{r}
\text { Times: } \mathrm{x} \\
\text { Garamond: } \mathrm{x} \\
\text { Helvetica: } \mathrm{x} \\
\text { Arial: } \mathrm{x} \\
\text { Impact: } \mathbf{x} \\
\text { Courier: } \mathrm{x}
\end{array}
$$

Figure 4-6. Varying $x$-heights

## Pixel lengths

On the face of things, pixels are straightforward. If you look at a monitor closely enough, you can see that it's broken up into a grid of tiny little boxes. Each box is a pixel. If you define an element to be a certain number of pixels tall and wide, as in the following markup:

$\langle\mathrm{p}\rangle$

The following image is 20 pixels tall and wide: <img src="test.gif" style="width: 20px; height: 20px;" alt="" />

</p>

then it follows that the element will be that many monitor elements tall and wide, as shown in Figure 4-7.

The following image is 20 pixels tall and wide:

Figure 4-7. Using pixel lengths

Unfortunately, there is a potential drawback to using pixels. If you set font sizes in pixels, then users of Internet Explorer for Windows previous to IE7 cannot resize the text using the Text Size menu in their browser. This can be a problem if your text is too small for a user to comfortably read. If you use more flexible measurements, such as em, the user can resize text. (If you're exceedingly protective of your design, you might call that a drawback, of course.)

On the other hand, pixel measurements are perfect for expressing the size of images, which are already a certain number of pixels tall and wide. In fact, the only time you would not want pixels to express image size is if you want them scaled along with the size of the text. This is an admirable and occasionally useful approach, and one that would really make sense if you were using vector-based images instead of pixelbased images. (With the adoption of Scalable Vector Graphics, look for more on this in the future.)

## Pixel theory

So why are pixels defined as relative lengths? I've explained that the tiny boxes of color in a monitor are pixels. However, how many of those boxes equals one inch? This may seem like a non sequitur, but bear with me for a moment.

In its discussion of pixels, the CSS specification recommends that in cases where a display type is significantly different than 96ppi, user agents should scale pixel measurements to a "reference pixel." CSS2 recommended 90ppi as the reference pixel, but CSS2.1 recommends 96ppi-a measurement common to Windows machines and adopted by modern Macintosh browsers such as Safari.

In general, if you declare something like font-size: $18 \mathrm{px}$, a web browser will almost certainly use actual pixels on your monitor-after all, they're already there-but with other display devices, like printers, the user agent will have to rescale pixel lengths to something more sensible. In other words, the printing code has to figure out how many dots there are in a pixel, and to do so, it may use the 96ppi reference pixel.



One example of problems with pixel measurements can be found in an early CSS1 implementation. In Internet Explorer 3.x, when a document was printed, IE3 assumed that $18 \mathrm{px}$ was the same as 18 dots, which on a 600dpi printer works out to be $18 / 600$, or $3 / 100$, of an inch—or, if you prefer, .03in. That's pretty small text!

Because of this potential for rescaling, pixels are defined as a relative unit of measurement, even though, in web design, they behave much like absolute units.

## What to do?

Given all the issues involved, the best measurements to use are probably the relative measurements, most especially em, and also px when appropriate. Because ex is, in most currently used browsers, basically a fractional measurement of em, it's not all
that useful for the time being. If more user agents support real x-height measurements, ex might come into its own. In general, ems are more flexible because they scale with font sizes, so elements and element separation will stay more consistent.

Other element aspects may be more amenable to the use of pixels, such as borders or the positioning of elements. It all depends on the situation. For example, in designs that traditionally use spacer GIFs to separate pieces of a design, pixel-length margins will produce an identical effect. Converting that separation distance to ems would allow the design to grow or shrink as the text size changes - which might or might not be a good thing.

## URLS

If you've written web pages, you're obviously familiar with URLs (or, in CSS2.1, URIs). Whenever you need to refer to one-as in the @import statement, which is used when importing an external style sheet-the general format is:

url(protocol://server/pathname)

This example defines what is known as an absolute URL. By absolute, I mean a URL that will work no matter where (or rather, in what page) it's found, because it defines an absolute location in web space. Let's say that you have a server called www.waffles.org. On that server, there is a directory called pix, and in this directory is an image waffle22.gif. In this case, the absolute URL of that image would be:

http://www.waffles.org/pix/waffle22.gif

This URL is valid no matter where it is found, whether the page that contains it is located on the server www.waffles.org or web.pancakes.com.

The other type of URL is a relative URL, so named because it specifies a location that is relative to the document that uses it. If you're referring to a relative location, such as a file in the same directory as your web page, then the general format is:

url(pathname)

This works only if the image is on the same server as the page that contains the URL. For argument's sake, assume that you have a web page located at http:// www.waffles.org/syrup.html and that you want the image waffle22.gif to appear on this page. In that case, the URL would be:

## pix/waffle22.gif

This path works because the web browser knows that it should start with the place it found the web document and then add the relative URL. In this case, the pathname pix/waffle22.gif added to the server name http://www.waffles.org equals http:// www.waffles.org/pix/waffle22.gif. You can almost always use an absolute URL in place of a relative URL; it doesn't matter which you use, as long as it defines a valid location.

In CSS, relative URLs are relative to the style sheet itself, not to the HTML document that uses the style sheet. For example, you may have an external style sheet that imports another style sheet. If you use a relative URL to import the second style sheet, it must be relative to the first style sheet. As an example, consider an HTML document at http://www.waffles.org/toppings/tips.html, which has a link to the style sheet http://www.waffles.org/styles/basic.css:

<link rel="stylesheet" type="text/css"

href="http://www.waffles.org/styles/basic.css">

Inside the file basic.css is an @import statement referring to another style sheet:

@import url(special/toppings.css);

This @import will cause the browser to look for the style sheet at http://www.waffles.org/ styles/special/toppings.css, not at http://www.waffles.org/toppings/special/toppings.css. If you have a style sheet at the latter location, then the @import in basic.css should read:

@import url(http://www.waffles.org/toppings/special/toppings.css);



Netscape Navigator 4 interprets relative URLs in relation to the HTML document, not the style sheet. If you have a lot of NN4.x visitors or want to make sure NN4.x can find all of your style sheets and background images, it's generally easiest to make all of your URLs absolute, since Navigator handles those correctly.

Note that there cannot be a space between the url and the opening parenthesis:

body \{background: url(http://www.pix.web/picture1.jpg);\} /* correct */

body $\{$ background: url (images/picture2.jpg);\} /* INCORRECT */

If the space isn't omitted, the entire declaration will be invalidated and thus ignored.

## Keywords

For those times when a value needs to be described with a word of some kind, there are keywords. A very common example is the keyword none, which is distinct from 0 (zero). Thus, to remove the underline from links in an HTML document, you would write:

a:link, a:visited \{text-decoration: none;\}

Similarly, if you want to force underlines on the links, then you would use the keyword underline.

If a property accepts keywords, then its keywords will be defined only for the scope of that property. If two properties use the same word as a keyword, the behavior of the keyword for one property will not be shared with the other. As an example, normal, as defined for letter-spacing, means something very different than the normal defined for font-style.

## inherit

There is one keyword that is shared by all properties in CSS2.1: inherit. inherit makes the value of a property the same as the value of its parent element. In most cases, you don't need to specify inheritance, since most properties inherit naturally; however, inherit can still be very useful.

For example, consider the following styles and markup:

\#toolbar \{background: blue; color: white;\}

<div id="toolbar">

<a href="one.html">0ne</a> | <a href="two.html">Two</a> |

<a href="three.html">Three</a>

</div>

The div itself will have a blue background and a white foreground, but the links will be styled according to the browser's preference settings. They'll most likely end up as blue text on a blue background, with white vertical bars between them.

You could write a rule that explicitly sets the links in the "toolbar" to be white, but you can make things a little more robust by using inherit. You simply add the following rule to the style sheet:

\#toolbar a \{color: inherit; \}

This will cause the links to use the inherited value of color in place of the user agent's default styles. Ordinarily, directly assigned styles override inherited styles, but inherit can reverse that behavior.

## CSS2 Units

In addition to what we've covered in CSS2.1, CSS2 contains a few extra units, all of which are concerned with aural style sheets (employed by those browsers that are capable of speech). These units were not included in CSS2.1, but since they may be part of future versions of CSS, we'll briefly discuss them here:

## Angle values

Used to define the position from which a given sound should originate. There are three types of angles: degrees (deg), grads (grad), and radians (rad). For example, a right angle could be declared as 90deg, 100grad, or 1.57rad; in each case, the values are translated into degrees in the range 0 through 360 . This is also true of negative values, which are allowed. The measurement -90deg is the same as 270deg.

Time values

Used to specify delays between speaking elements. They can be expressed as either milliseconds (ms) or seconds (s). Thus, 100ms and $0.1 \mathrm{~s}$ are equivalent. Time values cannot be negative, as CSS is designed to avoid paradoxes.

## Frequency values

Used to declare a given frequency for the sounds that speaking browsers can produce. Frequency values can be expressed as hertz ( $\mathrm{Hz}$ ) or megahertz (MHz) and cannot be negative. The values' labels are case-insensitive, so $10 \mathrm{MHz}$ and $10 \mathrm{Mhz}$ are equivalent.

The only user agent known to support any of these values at this writing is Emacspeak, an aural style sheets implementation. See Chapter 14 for details on aural styles.

In addition to these values, there is also an old friend with a new name. A URI is a Uniform Resource Identifier, which is sort of another name for a Uniform Resource Locator (URL). Both the CSS2 and CSS2.1 specifications require that URIs be declared with the form $\operatorname{url}(\ldots)$, so there is no practical change.

## Summary

Units and values cover a wide spectrum of areas, from length units to special keywords that describe effects (such as underline) to color units to the location of files (such as images). For the most part, units are the one area that user agents get almost totally correct, but it's those few little bugs and quirks that can get you. Navigator 4.x's failure to interpret relative URLs correctly, for example, has bedeviled many authors and led to an overreliance on absolute URLs. Colors are another area where user agents almost always do well, except for a few little quirks here and there. The vagaries of length units, however, far from being bugs, are an interesting problem for any author to tackle.

These units all have their advantages and drawbacks, depending upon the circumstances in which they're used. We've already seen some of these circumstances, and their nuances will be discussed in the rest of the book, beginning with the CSS properties that describe ways to alter how text is displayed.

## CHAPTER 5

## Fonts

As the authors of the CSS specification clearly recognized, font selection is a popular (and crucial) feature. After all, how many pages are littered with dozens, or even hundreds, of <FONT FACE="..."> tags? In fact, the beginning of the "Font Properties" section of the specification begins with the sentence, "Setting font properties will be among the most common uses of style sheets."

Despite that importance, however, there currently isn't a way to ensure consistent font use on the Web because there isn't a uniform way of describing fonts and variants of fonts. For example, the fonts Times, Times New Roman, and TimesNR may be similar or even the same, but how would a user agent know that? An author might specify "TimesNR" in a document, but what happens when a user views the document without that particular font installed? Even if Times New Roman is installed, the user agent has no way to know that the two are effectively interchangeable. And if you're hoping to force a certain font on a reader, forget it.

Although CSS2 defined facilities for downloadable fonts, they weren't well implemented by web browsers, and a reader could always refuse to download fonts for performance reasons. CSS does not provide ultimate control over fonts any more than a word processor does; when someone else loads a Microsoft Office document you have created, its display will depend on that person's installed fonts. If she doesn't have the same fonts you do, then the document will look different. This is also true of documents designed using CSS.

The problem of font naming becomes especially confusing once you enter the realm of font variants, such as bold or italic text. Most people know what italic text looks like, but few can explain how it's different from slanted text, even though there are differences. "Slanted" is not the only other term for italic-style text, either-for example, you'll find oblique, incline (or inclined), cursive, and kursiv, among others. Thus, one font may have a variant called something like Timesitalic, whereas another uses something like GeorgiaOblique. Although the two may be effectively equivalent as the "italic form" of each font, they are labeled quite differently. Similarly, the font variant terms bold, black, and heavy may or may not mean the same thing.

CSS attempts to provide some resolution mechanisms for all of these font questions, although it cannot provide a complete solution. The most complicated parts of font handling in CSS are font-family matching and font-weight matching, with font-size calculations running a close third. The font aspects addressed by CSS are font styles, such as italics, and font variants, such as small caps; these are much more straightforward, relatively speaking. These various aspects of font styling are all brought together in a single property, font, which we'll discuss later in this chapter. First, let's discuss font families, since they're the most basic step in choosing the right font for your document.

## Font Families

Although there are, as discussed earlier, a number of ways to label what is effectively the same font, CSS makes a valiant attempt to help user agents sort out the mess. After all, what we think of as a "font" may be composed of many variations to describe boldfacing, italic text, and so forth. For example, you're probably familiar with the font Times. However, Times is actually a combination of many variants, including TimesRegular, TimesBold, TimesItalic, TimesOblique, TimesBoldItalic, TimesBoldOblique, and so on. Each of these variants of Times is an actual font face, but Times, as we usually think of it, is a combination of all these variant faces. In other words, Times is actually a font family, not just a single font, even though most of us think about fonts as being single entities.

In addition to each specific font family such as Times, Verdana, Helvetica, or Arial, CSS defines five generic font families:

## Seriffonts

These fonts are proportional and have serifs. A font is proportional if all characters in the font have different widths due to their various sizes. For example, a lowercase $i$ and a lowercase $m$ are different widths. (This book's paragraph font is proportional, for example.) Serifs are the decorations on the ends of strokes within each character, such as little lines at the top and bottom of a lowercase $l$, or at the bottom of each leg of an uppercase $A$. Examples of serif fonts are Times, Georgia, and New Century Schoolbook.

## Sans-seriffonts

These fonts are proportional and do not have serifs. Examples of sans-serif fonts are Helvetica, Geneva, Verdana, Arial, and Univers.

## Monospace fonts

Monospace fonts are not proportional. These generally are used to emulate typewritten text, the output from an old dot-matrix printer, or an even older videodisplay terminal. In these fonts, each character is exactly the same width as all the others, so a lowercase $i$ is the same width as a lowercase $m$. These fonts may or may not have serifs. If a font has uniform character widths, it is classified as monospace, regardless of the presence of serifs. Examples of monospace fonts are Courier, Courier New, and Andale Mono.

## Cursive fonts

These fonts attempt to emulate human handwriting. Usually, they are composed largely of curves and have stroke decorations that exceed those found in serif fonts. For example, an uppercase $A$ might have a small curl at the bottom of its left leg or be composed entirely of swashes and curls. Examples of cursive fonts are Zapf Chancery, Author, and Comic Sans.

Fantasy fonts

Such fonts are not really defined by any single characteristic other than our inability to easily classify them in one of the other families. A few such fonts are Western, Woodblock, and Klingon.

In theory, every font family a user could install will fall into one of these generic families. In practice, this may not be the case, but the exceptions (if any) are likely to be few and far between.

## Using Generic Font Families

You can employ any of these families in a document by using the property font-family.



If you want a document to use a sans-serif font, but you do not particularly care which one, then the appropriate declaration would be this:

body \{font-family: sans-serif; $\}$

This will cause the user agent to pick a sans-serif font family (such as Helvetica) and apply it to the body element. Thanks to inheritance, the same font choice will be applied to all the elements that descend from the body-unless a more specific selector overrides it, of course.

Using nothing more than these generic families, an author can create a fairly sophisticated style sheet. The following rule set is illustrated in Figure 5-1:



## An Ordinary Document

This is a mixture of elements such as you might find in a normal document. There are headings, paragraphs, code fragments, and many other inline elements. The fonts used for these various elements will depend on what the author has declared, what the browser's default styles happen to be, and how the two interleave.

## A Section Title

Here we have some preformatted text

just for the heck of it.

If you want to make changes to your startup script under DOS, you start by typing edit autoexec. bat. Of course, if you're running DOS, you probably already know that.

-- The Unknown Author

Figure 5-1. Various font families

Thus, most of the document will be in a serif font such as Times, including all paragraphs except those that have a class of signature, which will instead be rendered in a cursive font such as Author. Headings 1 through 4 will be in sans-serif font like Helvetica, while the elements code, pre, $t t$, and span.input will be in a monospace font like Courier-which, coincidentally, is how most of these elements are usually presented in this book.

## Specifying a Font Family

An author may, on the other hand, have more specific preferences for which font to use in the display of a document or element. In a similar vein, a user may want to create a user style sheet that defines the exact fonts that are used in the display of all documents. In either case, font-family is still the property to use.

Assume for the moment that all h1s should use Georgia as their font. The simplest rule for this would be the following:

h1 \{font-family: Georgia; \}

This will cause the user agent displaying the document to use Georgia for all h1s, as shown in Figure 5-2.

## A Heading-1 Element

Figure 5-2. An h1 element using Georgia

Of course, this rule assumes that the user agent has Georgia available for use. If it doesn't, the user agent will be unable to use the rule at all. It won't ignore the rule,
but if it can't find a font called "Georgia," it can't do anything but display h1 elements using the user agent's default font.

All is not lost, however. By combining specific font names with generic font families, you can create documents that come out, if not exact, at least close to your intentions. To continue the previous example, the following markup tells a user agent to use Georgia if it's available, and to use another serif font if it's not.

h1 \{font-family: Georgia, serif; \}

If a reader doesn't have Georgia installed but does have Times, the user agent might use Times for h1 elements. Even though Times isn't an exact match to Georgia, it's probably close enough.

For this reason, I strongly encourage you to always provide a generic family as part of any font-family rule. By doing so, you provide a fallback mechanism that lets user agents pick an alternative when they can't provide an exact font match. Such a backup measure is especially helpful since, in a cross-platform environment, there is no way to know who has which fonts installed. Sure, every Windows machine in the world may have Arial and Times New Roman installed, but some Macintoshes (particularly older ones) don't, and the same is probably true of Unix machines. Conversely, while MarkerFelt and Charcoal are common to all recent Macintoshes, it's unlikely that Windows and Unix users will have either font installed, and it is even less likely that they'll have both. Here are a few more examples:



If you're familiar with fonts, you might have a number of similar fonts in mind for displaying a given element. Let's say that you want all paragraphs in a document to be displayed using Times, but you would also accept TimesNR, Georgia, New Century Schoolbook, and New York (all of which are serif fonts). First, decide the order of preference for these fonts, and then string them together with commas:

p \{font-family: Times, TimesNR, 'New Century Schoolbook', Georgia, 'New York', serif; \}

Based on this list, a user agent will look for the fonts in the order they're listed. If none of the listed fonts are available, then it will simply pick a serif font that is available.

## Using quotation marks

You may have noticed the presence of single quotes in the previous example, which we haven't seen before. Quotation marks are needed in a font-family declaration only if a font name has one or more spaces in it, such as New York, or if the font
name includes symbols such as \# or $\$$. In both cases, the entire font name should be enclosed in quotation marks to keep the user agent from getting confused about what the name really is. (You might think the commas would suffice, but they don't.) Thus, a font called Karrank $\%$ should probably be quoted:

h2 \{font-family: Wedgie, 'Karrank\%', Klingon, fantasy; \}

If you leave off the quotation marks, there is a chance that user agents will ignore that particular font name altogether, although they'll still process the rest of the rule. Note that the quoting of a font name containing a symbol is not actually required by the CSS2.1 specification. Instead, it's recommended, which is as close to describing "best practices" as the CSS specification ever really gets. Similarly, it is recommended that you quote a font name containing spaces. As it turns out, the only required quotation is for font names that match accepted keywords. Thus, if you call for a font whose actual name is "cursive," you'll need to quote it.

Obviously, font names that use a single word-one that doesn't conflict with any of the keywords for font-family-need not be quoted, and generic family names (serif, monospace, etc.) should never be quoted when they refer to the actual generic families. If you quote a generic name, then the user agent will assume that you are asking for a specific font with that name (for example, "serif"), not a generic family.

As for which quotation marks to use, both single and double quotes are acceptable. Remember that if you place a font-family rule in a style attribute, you'll need to use whichever quotes you didn't use for the attribute itself. Therefore, if you use double quotes to enclose the font-family rule, then you'll have to use single quotes within the rule, as in the following markup:



If you use double quotes in such a circumstance, they interfere with the attribute syntax, as you can see in Figure 5-3.

## Greetings! This paragraph is supposed to use either 'New Century Schoolbook', Times, or an alternate serif font for its display. <br> Greetings! This paragraph is also supposed to use either 'New Century Schoolbook', Times, or an alternate serif font for its display.

Figure 5-3. The perils of incorrect quotation marks

## Font Weights

Even though you may not realize it, you're already familiar with font weights; boldfaced text is a very common example of an increased font weight. CSS gives you more control over weights, at least in theory, with the property font-weight.

| font-weight |  |
| :--- | :--- |
| Values: | normal $\mid$ bold $\mid$ bolder $\mid$ lighter $\|100\| 200\|300\| 400\|500\| 600\|700\|$ |
|  | $800\|900\|$ inherit |
| Initial value: | normal |
| Applies to: | All elements |
| Inherited: | Yes |
| Computed value: | One of the numeric values (100, etc.), or one of the numeric values plus |
|  | one of the relative values (bolder or lighter) |
|  |  |

Generally speaking, the heavier a font weight becomes, the darker and "more bold" a font appears. There are a great many ways to label a heavy font face. For example, the font family known as Zurich has a number of variants, such as Zurich Bold, Zurich Black, Zurich UltraBlack, Zurich Light, and Zurich Regular. Each of these uses the same basic font, but each has a different weight.

So let's say that you want to use Zurich for a document, but you'd like to make use of all those different heaviness levels. You could refer to them directly through the font-family property, but you really shouldn't have to do that. Besides, it's no fun having to write a style sheet like this:



Aside from the obvious tedium of writing such a style sheet, it works only if everyone has these fonts installed, and it's a pretty safe bet that most people don't. It would make far more sense to specify a single font family for the whole document and then assign different weights to various elements. You can do this, in theory, using the various values for the property font-weight. This is a fairly obvious fontweight declaration:

b \{font-weight: bold; \}

This declaration says, simply, that the b element should be displayed using a boldface font; or, to put it another way, a font that is heavier than the normal font for the document. This is what we're used to, of course, since $b$ does cause text to be boldfaced.

However, what's really happening is that a heavier variant of the font is used for displaying a $b$ element. Thus, if you have a paragraph displayed using Times, and part of it is boldfaced, then there are really two variants of the same font in use: Times and TimesBold. The regular text is displayed using Times, and the boldfaced text is displayed using TimesBold.

## How Weights Work

To understand how a user agent determines the heaviness, or weight, of a given font variant, not to mention how weight is inherited, it's easiest to start by talking about the keywords 100 through 900 . These number keywords were defined to map to a relatively common feature of font design in which a font is given nine levels of weight. OpenType, for example, employs a numeric scale with nine values. If a font has these weight levels built-in, then the numbers are mapped directly to the predefined levels, with 100 as the lightest variant on the font and 900 as the heaviest.

In fact, there is no intrinsic weight in these numbers. The CSS specification says only that each number corresponds to a weight at least as heavy as the number that precedes it. Thus, 100, 200, 300, and 400 might all map to the same relatively lightweight variant; 500 and 600 could correspond to the same heavier font variant; and 700,800, and 900 could all produce the same very heavy font variant. As long as no keyword corresponds to a variant that is lighter than the variant assigned to the previous keyword, everything will be all right.

As it happens, these numbers are defined to be equivalent to certain common variant names, not to mention other values for font-weight. 400 is defined to be equivalent to normal, and 700 corresponds to bold. The other numbers do not match up with any other values for font-weight, but they can correspond to common variant names. If there is a font variant labeled something such as "Normal," "Regular," "Roman," or "Book," then it is assigned to the number 400 and any variant with the label "Medium" is assigned to 500. However, if a variant labeled "Medium" is the only variant available, it is not assigned to 500 but instead to 400 .

A user agent has to do even more work if there are fewer than nine weights in a given font family. In this case, it must fill in the gaps in a predetermined way:

- If the value 500 is unassigned, it is given the same font weight as that assigned to 400.
- If 300 is unassigned, it is given the next variant lighter than 400. If no lighter variant is available, 300 is assigned the same variant as 400 . In this case, it will usually be "Normal" or "Medium." This method is also used for 200 and 100.
- If 600 is unassigned, it is given the next variant darker than 500. If no darker variant is available, 600 is assigned the same variant as 500. This method is also used for 700,800 , and 900 .

To illustrate this weighting scheme more clearly, let's look at three examples of font weight assignment. In the first example, assume that the font family Karrank\% is an OpenType font, so it has nine weights already defined. In this case, the numbers are assigned to each level, and the keywords normal and bold are assigned to the numbers 400 and 700 , respectively.

In our second example, consider the font family Zurich, which was discussed near the beginning of this section. Hypothetically, its variants might be assigned numeric values for font-weight, as shown in Table 5-1.

Table 5-1. Hypothetical weight assignments for a specific font family

| Font face | Assigned keyword | Assigned number(s) |
| :--- | :--- | :--- |
| Zurich Light |  | $100,200,300$ |
|  |  |  |
| Zurich Regular | normal | 400 |
| Zurich Medium |  | 500 |
|  |  |  |
| Zurich Bold | bold | 600,700 |
| Zurich Black |  | 800 |
| Zurich UltraBlack | 900 |  |

The first three number values are assigned to the lightest weight. The "Regular" face gets the keyword normal, as expected, and the number weight 400 . Since there is a "Medium" font, it's assigned to the number 500. There is nothing to assign to 600 , so it's mapped to the "Bold" font face, which is also the variant to which 700 and bold are assigned. Finally, 800 and 900 are assigned to the "Black" and "UltraBlack" variants, respectively. Note that this last assignment would happen only if those faces had the top two weight levels already assigned. Otherwise, the user agent might ignore them and assign 800 and 900 to the "Bold" face instead, or it might assign them both to one or the other of the "Black" variants.

Finally, let's consider a stripped-down version of Times. In Table 5-2, there are only two weight variants: "TimesRegular" and "TimesBold."

Table 5-2. Hypothetical weight assignments for "Times"

| Font face | Assigned keyword | Assigned numbers |
| :--- | :--- | :--- |
| TimesRegular | normal | $100,200,300,400,500$ |
| TimesBold | bold | $600,700,800,900$ |

The assignment of the keywords normal and bold is straightforward enough, of course. As for the numbers, 100 through 300 are assigned to the "Regular" face because there isn't a lighter face available. 400 is assigned to "Regular" as expected, but what about 500? It is assigned to the "Regular" (or normal) face because there isn't a "Medium" face available; thus, it is assigned the same font face as 400. As for the rest, 700 goes with bold as always, while 800 and 900 , lacking a heavier face, are assigned to the next-lighter face, which is the "Bold" font face. Finally, 600 is assigned to the next-heavier face, which is, of course, the "Bold" face.

font-weight is inherited, so if you set a paragraph to be bold:

p.one $\{$ font-weight: bold; $\}$

then all of its children will inherit that boldness, as we see in Figure 5-4.

## Within this paragraph we find some italicized text, a bit of underlined text, and the occasional stretch of hyperlinked text for our viewing pleasure.

Figure 5-4. Inherited font-weight

This isn't unusual, but the situation gets interesting when you use the last two values we have to discuss: bolder and lighter. In general terms, these keywords have the effect you'd anticipate: they make text more or less bold compared to its parent's font weight. First, let's consider bolder.

## Getting Bolder

If you set an element to have a weight of bolder, then the user agent first must determine what font-weight value was inherited from the parent element. It then selects the lowest number, which corresponds to a font weight darker than what was inherited. If none is available, then the user agent sets the element's font weight to the next numerical value, unless the value is already 900, in which case the weight remains at 900 . Thus, you might encounter the following situations, illustrated in Figure 5-5:



In the first example, the user agent moves up the weight ladder from normal to bold; in numeric terms, it jumps from 400 to 700 . In the second example, h1 text is already

## This H1 contains bold text.

Meanwhile, this DIV tag has some strong text but it shouldn't look much different, at least in terms of font weight.

Figure 5-5. Text trying to be bolder

set to bold. If there is no bolder face available, then the user agent sets the weight of $b$ text within an $\mathrm{h} 1$ to 800 , since that is the next step up from 700 (the numeric equivalent of bold). Since 800 is assigned to the same font face as 700 , there is no visible difference between normal h1 text and boldfaced h1 text, but the weights are different nonetheless.

In the last example, paragraphs are set to be the lightest possible font weight, which we assume exists as a "Light" variant. Furthermore, the other faces in this font family are "Regular" and "Bold." Any em text within a paragraph will evaluate to normal since that is the next-heaviest face within the font family. However, what if the only faces in the font are "Regular" and "Bold"? In that case, the declarations would evaluate like this:

/* assume only two faces for this example: 'Regular' and 'Bold' */

p \{font-weight: 100; \} /* looks the same as 'normal' text */

p span \{font-weight: bolder; \} /* maps to '700' */

As you can see, the weight 100 is assigned to the normal font face, but the value of font-weight is still 100. Thus, any span text that is descended from a p element will inherit the value of 100 and then evaluate to the next-heaviest face, which is the "Bold" face with a numerical weight of 700.

Let's take this one step further and add two more rules, plus some markup, to illustrate how all of this works (see Figure 5-6 for the results):



This paragraph contains elements of increasing weight: there is a span element that contains a strongly emphasized element, and that contains a boldface element.

Figure 5-6. Moving up the weight scale

In the last two nested elements, the computed value of font-weight is increased because of the liberal use of the keyword bolder. If you were to replace the text in the paragraph with numbers representing the font-weight of each element, you would get the results shown here:



The first two weight increases are large because they represent jumps from 100 to 400 and from 400 to bold (700). From 700, there is no heavier face, so the user agent simply moves the value of font-weight one notch up the numeric scale (800). Furthermore, if you were to insert a strong element into the b element, it would come out like this:



If there were yet another $b$ element inserted into the innermost strong element, its weight would also be 900, since font-weight can never be higher than 900. Assuming that there are only two font faces available, then the text would appear to be either Regular or Bold, as you can see in Figure 5-7:

$\langle p>$

regular <span> regular <strong> bold <b> bold

<strong> bold </strong></b></strong></span>.

$\langle/ p>$

regular regular bold bold bold .

Figure 5-7. Visual weight, with descriptors

## Lightening Weights

As you might expect, lighter works in just the same way, except it causes the user agent to move down the weight scale instead of up. With a quick modification of the previous example, you can see this very clearly:


$\langle p>$

bold <span> bold <strong> regular <b> regular

<strong> regular </strong></b></strong></span>.

</p>

Ignoring the fact that this would be entirely counterintuitive, what you see in Figure 5-8 is that the main paragraph text has a weight of 900 . When the strong text is set to be lighter, it evaluates to the next-lighter face, which is the regular face, or 400 (the same as normal) on the numeric scale. The next step down is to 300 , which is the same as normal since no lighter faces exist. From there, the user agent can reduce the weight only one numeric step at a time until it reaches 100 (which it doesn't do in the example). The second paragraph shows which text will be bold and which will be regular.

900700400300200 .

bold bold regular regular regular .

Figure 5-8. Making text lighter

## Font Size

The methods for determining font size are both very familiar and very different.



In a fashion very similar to the font-weight keywords bolder and lighter, the property font-size has relative-size keywords called larger and smaller. Much like what we saw with relative font weights, these keywords cause the computed value of fontsize to move up and down a scale of size values, which you'll need to understand before you can explore larger and smaller. First, though, we need to examine how fonts are sized in the first place.

In fact, the actual relation of the font-size property to what you see rendered is determined by the font's designer. This relationship is set as an em square (some call it an em box) within the font itself. This em square (and thus the font size) doesn't have to refer to any boundaries established by the characters in a font. Instead, it refers to the distance between baselines when the font is set without any extra leading (line-height in CSS). It is quite possible for fonts to have characters that are taller than the default distance between baselines. For that matter, a font might be defined such that all of its characters are smaller than its em square, as many fonts do. Some hypothetical examples are shown in Figure 5-9.

## $\mathcal{A}$ font with an em square smafter than some characters.

## A font with an em square taller than all characters.

## A font with an em square which is exactly large enough to contain all characters.

Figure 5-9. Font characters and em squares

Thus, the effect of font-size is to provide a size for the em box of a given font. This does not guarantee that any of the actual displayed characters will be this size.

## Absolute Sizes

Having established all of that, we turn now to the absolute-size keywords. There are seven absolute-size values for font-size: xx-small, x-small, small, medium, large, xlarge, and $x x$-large. These are not defined precisely, but are relative to each other, as Figure 5-10 demonstrates:



## This parograph (class 'one') has a font size of 'xx-small.' <br> This paragraph (clas 'toro') has a font size of 'x-small.' <br> This paragraph (olass 'three') has a font size of 'small.' <br> This paragraph (class 'four') has a font size of 'medium.' <br> This paragraph (class 'five') has a font size of 'large.' <br> This paragraph (class 'six') has a font size of 'x-large.' <br> This paragraph (class 'seven') has a font size of 'xx-large.'

Figure 5-10. Absolute font sizes

According to the CSS1 specification, the difference (or scaling factor) between one absolute size and the next should be about 1.5 going up the ladder, or 0.66 going down. Thus, if medium is the same as 10px, then large should be the same as 15px. On the other hand, the scaling factor does not have to be 1.5 ; not only might it be different for different user agents, but it was changed to a factor somewhere between 1.0 and 1.2 in CSS2.

Working from the assumption that medium equals $16 \mathrm{px}$, for different scaling factors, we get the absolute sizes shown in Table 5-3. (The following values are approximations, of course.)

Table 5-3. Scaling factors translated to pixels

| Keyword | Scaling: $\mathbf{1 . 5}$ | Scaling: $\mathbf{1 . 2}$ |
| :--- | :--- | :--- |
| xx-small | $5 p x$ | $9 p x$ |
| x-small | $7 p x$ | $11 p x$ |
| small | $11 p x$ | $13 p x$ |
| medium | $16 p x$ | $16 p x$ |
| large | $24 p x$ | $19 p x$ |
| x-large | $36 p x$ | $23 p x$ |
| xx-large | $54 p x$ | $28 p x$ |

Further complicating the situation is the fact that different user agents have assigned the "default" font size to different absolute keywords. Take the Version 4 browsers as an example: Navigator 4 makes medium the same size as unstyled text, whereas Internet Explorer 4 assumes that small text is equivalent in size to unstyled text. Despite the fact that the default value for font-style is supposed to be medium, IE4's behavior may be wrong, but not quite so wrong as it might first appear." Fortunately, IE6 fixed the problem, at least when the browser is in standards mode, and treats medium as the default.

## Relative Sizes

Comparatively speaking, the keywords larger and smaller are simple: they cause the size of an element to be shifted up or down the absolute-size scale, relative to their parent element, using the same scaling factor employed to calculate absolute sizes. In other words, if the browser used a scaling factor of 1.2 for absolute sizes, then it should use the same factor when applying relative-size keywords:



Unlike the relative values for weight, the relative-size values are not necessarily constrained to the limits of the absolute-size range. Thus, a font's size can be pushed beyond the sizes for $x x$-small and $x x$-large. For example:

h1 \{font-size: xx-large; \}

em \{font-size: larger; $\}$

<h1>A Heading with <em>Emphasis</em> added</h1>

<p>This paragraph has some <em>emphasis</em> as well.</p>

As you can see in Figure 5-11, the emphasized text in the h1 element is slightly larger than $x x$-large. The amount of scaling is left up to the user agent, with the scaling factor of 1.2 being preferred. The em text in the paragraph, of course, is shifted one slot up the absolute-size scale (large).[^1]

## A Heading with Emphasis added

This paragraph has some emphasis as well.

## $\mathrm{xx}$-large $x \mathrm{x}$-large $\mathrm{xx}$-large

medium large medium

Figure 5-11. Relative font sizing at the edges of the absolute sizes



## Percentages and Sizes

In a way, percentage values are very similar to the relative-size keywords. A percentage value is always computed in terms of whatever size is inherited from an element's parent. Percentages, unlike the relative-size keywords, permit much finer control over the computed font size. Consider the following example, illustrated in Figure 5-12:


This paragraph contains both emphasis and strong emphasis, both of which are larger than their parent element. The smalltest, on the other hand, is smaller by a quarter.

This is a 'footnote' and is smaller than regular text.

$12 \mathrm{px} 14.4 \mathrm{px} 12 \mathrm{px} 16.2 \mathrm{px} 12 \mathrm{px} 9 \mathrm{px} 12 \mathrm{px}$

$10.5 \mathrm{px}$

Figure 5-12. Throwing percentages into the mix

In this example, the exact pixel size values are shown. In practice, a web browser would very likely round the values off to the nearest whole-number pixel, such as $14 \mathrm{px}$, although advanced user agents may approximate fractional pixels through antialiasing or when printing the document. For other font-size values, the browser may (or may not) preserve fractions.

Incidentally, CSS defines the length value em to be equivalent to percentage values, in the sense that $1 \mathrm{em}$ is the same as $100 \%$ when sizing fonts. Thus, the following would yield identical results (assuming both paragraphs have the same parent element):

p.one \{font-size: $166 \%$;

p.two \{font-size: $1.6 \mathrm{em} ;\}$

When using em measurements, the same principles apply as with percentages, such as the inheritance of computed sizes, and so forth.

## Font Size and Inheritance

Figure 5-12 also demonstrates that, although font-size is inherited in CSS, it is the computed values that are inherited, not percentages. Thus, the value inherited by the strong element is $12 \mathrm{px}$, and this value is modified by the declared value $135 \%$ to arrive at $16.2 \mathrm{px}$ (which will probably be rounded off to $16 \mathrm{px}$ ). For the "footnote" paragraph, the percentage is calculated in relation to the font-size value that's inherited from the body element, which is 15 px. Multiplying that value by $75 \%$ yields 11.25 px.

As with the relative-size keywords, percentages are effectively cumulative. Thus, the following markup is displayed as shown in Figure 5-13:



This pargraph contains both emphasis and strong ellplhasis, both of which are larger than the paragraph text.

${ }_{12 \mathrm{px}}$ 14.4px 19.44px ${ }_{12 \mathrm{px}}$

Figure 5-13. The issues of inheritance

The size value for the strong element shown in Figure 5-13 is computed as follows:

$12 \mathrm{px} \times 120 \%=14.4 \mathrm{px}$

$14.4 \mathrm{px} \times 135 \%=19.44 \mathrm{px}$ (possibly rounded to $19 \mathrm{px}$ )

There is an alternative scenario, however, in which the final value is slightly different. In this scenario, the user agent rounds off pixel size, and these rounded values
are then inherited normally by any child elements. Although this behavior would be incorrect according to the specification, let's assume that the work agent does it. Therefore, you would have:

$$
\begin{aligned}
& 12 p x \times 120 \%=14.4 p x[14.4 p x \approx 14 p x] \\
& 14 p x \times 135 \%=18.9 p x[18.9 p x \approx 19 p x]
\end{aligned}
$$

If one assumes that the user agent is rounding off at each step, then the end result of both this calculation and the previous one is the same: 19 pixels. However, as more and more percentages are multiplied together, the rounding errors will begin to accumulate.

The problem of runaway scaling can go the other direction, too. Consider for a moment a document that is nothing but a series of unordered lists, many of them nested inside other lists. Some of these lists are four nested levels deep. Imagine the effect of the following rule on such a document:

ul \{font-size: 80\%;

Assuming a four-level deep nesting, the most deeply nested unordered list would have a computed font-size value 40.96 percent the size of the parent of the top-level list. Every nested list would have a font size 80 percent as big as its parent list, causing each level to become harder and harder to read. A similar problem can happen if you have a document that uses nested tables for layout. You would then write a rule such as:

td \{font-size: $0.8 \mathrm{em} ;\}$

Either way, you're likely to end up with a page that's nearly impossible to read.

## Using Length Units

The font-size can be set using any of the length values discussed in detail in Chapter 4. All of the following font-size declarations should be equivalent:



The display in Figure 5-14 assumes that the user agent knows how many dots per inch are used in the display medium. Different user agents make different assumptions - some based on the operating system, some based on preferences settings, and some based on the assumptions of the programmer who wrote the user agent. However, the five lines should always be the same size. So, while the result may not exactly match reality (for example, the actual size of p.three may not be half an inch), the measurements should all be consistent with one another.

## 36-point font size

## 3-pica font size

## 0.5 -inch font size

### 1.27-centimeter font size

## 12.7-millimeter font size

Figure 5-14. Various font sizes

There is one more value that is potentially the same as those shown in Figure 5-14, and that's $36 \mathrm{px}$, which would be the same physical distance if the display medium is 72 pixels-per-inch (ppi). However, there are very few monitors with that setting anymore. Most are much higher, in the range of 96 ppi to 120ppi. Many very old Macintosh web browsers treat points and pixels as though they are equivalent, so the values 14pt and 14px may look the same on them. This is not, however, the case for Windows and other platforms, including Mac OS X, which is one of the primary reasons why points can be a very difficult measurement to use in document design.

Because of these variations between operating systems, many authors choose to use pixel values for font sizes. This approach is especially attractive when mixing text and images on a web page, since text can (in theory) be set to the same height as graphic elements on the page by declaring font-size: 11px; or something similar, as illustrated by Figure 5-15.



GREETINGS! This text is set to a size of $1_{\mathrm{PX}}$ so that it's close to the same size as the contents of the image-- which allows for a certain consistency in appearance. This approach is often used to make sure the body of a document is similar in size to the graphic buttons used in the design, even though this raises some accessibility and legbility issues.

Figure 5-15. Keeping text and graphics in scale with pixel sizes

Using pixel measurements for font-size is certainly one way to get "consistent" results with font-size (and, indeed, with any length at all), but there is a major
drawback. Internet Explorer for Windows up through Version 6.0 does not allow users to easily resize text that has been set with pixels. Other browsers, including Mozilla, Netscape 6+, IE5+/Mac, Opera, and even IE7, allow the user to resize text no matter how it's been set. Thus, using pixels to size text is no more of a guarantee that it will stay the same size than is any other method. The other approaches discussed in this chapter, such as keywords and percentages, are a much more robust (and user-friendly) way to go, as they can be used to scale text from the user's default font size.

## Styles and Variants

Compared with everything we've covered so far, this section is practically a nobrainer. The properties discussed herein are so straightforward, and the complexities are so minimal, that this discussion will probably come as a great relief. First, we'll talk about font-style, and then move on to font-variant before wrapping up with the font properties.

## Fonts with Style

font-style is very simple: it's used to select between normal text, italic text, and oblique text. That's it! The only complication is in recognizing the difference between italic and oblique text and in understanding why browsers don't always give you a choice.

## font-style

Values: $\quad$ italic $\mid$ oblique $\mid$ normal $\mid$ inherit

Initial value: normal

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: As specified

The default value of font-style is, as you can see, normal. This refers to "upright" text, which is probably best described as "text that is not italic or otherwise slanted." The vast majority of text in this book is upright, for instance. That leaves only an explanation of the difference between italic and oblique text. For that, it's easiest to refer to Figure 5-16, which illustrates the differences very clearly.

Basically, italic text is a separate font face, with small changes made to the structure of each letter to account for the altered appearance. This is especially true of serif

## italic text sample

## oblique text sample

Figure 5-16. Italic and oblique text in detail

fonts, where, in addition to the fact that the text characters "lean," the serifs may be altered in an italic face. Oblique text, on the other hand, is simply a slanted version of the normal, upright text. Font faces with labels like "Italic," "Cursive," and "Kursiv" are usually mapped to the italic keyword, while oblique is often assigned faces with labels such as "Oblique," "Slanted," and "Incline."

If you want to make sure that a document uses italic text in familiar ways, you could write a style sheet like this:

p \{font-style: normal; $\}$

em, i \{font-style: italic; \}

These styles would make paragraphs use an upright font, as usual, and cause the em and i elements to use an italic font-again, as usual. On the other hand, you might decide that there should be a subtle difference between em and i:



If you look closely at Figure 5-17, you'll see there is no apparent difference between the em and i elements. In practice, not every font is so sophisticated as to have both an italic face and an oblique face, and even fewer web browsers are sophisticated enough to tell the difference when both faces do exist.

This paragraph has a 'font-style' of 'normal', which is why it looks... normal. The exception is those elements that have been given a different style, such as the 'em' element and the 'i' element, which get to be oblique and italic, respectively.

Figure 5-17. More font styles

If either of these is the case, then there are a few things that can happen. If there is no "Italic" face, but there is an "Oblique" face, then the latter can be used for the former. If the situation is reversed - an "Italic" face exists, but there is no defined "Oblique" face- the user agent may not substitute the former for the latter, according to the specification. Finally, the user agent can simply generate the oblique face by computing a slanted version of the upright font. In fact, this is what most often happens in a digital world, where it's fairly simple to slant a font using a simple computation.

Furthermore, you may find that in some operating systems, a given font that has been declared as italic may switch from being italic to oblique depending on the actual size of the font. The display of Times on a Macintosh running the Classic OS (Mac OS 9), for example, is shown in Figure 5-18, and the only difference is a single pixel in size.

This paragraph contains is steptsh of fitluizized hast within.

This paragraph contains a stretch of italicized text within.

Figure 5-18. Same font, same style, different sizes

There isn't much that can be done about this, unfortunately, except better font handling by operating systems, such as that found in Mac OS X and Windows XP. Usually, the italic and oblique fonts look exactly the same in web browsers.

Still, font-style can be useful. For example, it is a common typographic convention that a block quote should be italicized, but that any specially emphasized text within the quote should be upright. To employ this effect, which is illustrated in Figure 5-19, you would use these styles:

blockquote \{font-style: italic; \}

blockquote em, blockquote i \{font-style: normal;\}

Once upon a time, on a 'net not so far away, someone was heard to say:

Of course, workarounds, compatibility charts, and "bug list" pages are just a symptom of the problem, not the solution. Suffice it to say that, in light of all our problems, the only real solution is this: browsers must become conformant with the CSS specifications. Otherwise, we'll be stuck with a Web so fragmented it will hurt. A lot.

Figure 5-19. Common typographical conventions through CSS

## Font Variations

In addition to sizes and styles, fonts can also have variants. CSS offers a way to address one very common variant.

## font-variant

Values: $\quad$ small-caps $\mid$ normal $\mid$ inherit

Initial value: normal

Applies to: All elements

Inherited: Yes

Computed value: As specified

As for font-variant, it has only two non-inherit values: the default of normal, which describes ordinary text, and small-caps, which calls for the use of small-caps text. If you aren't familiar with such an effect, IT LOOKS SOMETHING LIKE THIS. Instead of upper- and lowercase letters, a small-caps font employs uppercase letters of different sizes. Thus, you might see something like that shown in Figure 5-20:



## THE UsES OF font-variant ON THE WEB

The property font-var iant is very interesting.

Figure 5-20. The small-caps value in use

As you may notice, in the display of the h1 element, there is a larger uppercase letter wherever an uppercase letter appears in the source and a small uppercase letter wherever there is a lowercase letter in the source. This is very similar to text-transform: uppercase, with the only real difference being that, here, the uppercase letters are of different sizes. However, the reason that small-caps is declared using a font property is that some fonts have a specific small-caps face, which a font property is used to select.

What happens if no such face exists? There are two options provided in the specification. The first is for the user agent to create a small-caps face by scaling uppercase letters on its own. The second is simply to make all letters uppercase and the same size, exactly as if the declaration text-transform: uppercase; had been used instead. This is obviously not an ideal solution, but it is permitted.


Internet Explorer for Windows took the all-caps route before IE6. Most other browsers display small-caps text when asked to do so.

## Stretching and Adjusting Fonts

There are two font properties that appear in CSS2, but not in CSS2.1. They've been dropped from CSS2.1 because, despite being in the specification for years, no browser has bothered to implement either one. The first allows for the horizontal stretching of fonts, and the second allows for intelligent scaling of substituted fonts when the author's first choice is not available. First, let's look at stretching.

## font-stretch

Values: normal $\mid$ wider $\mid$ narrower $\mid$ ultra-condensed $\mid$ extra-condensed condensed | semi-condensed I semi-expanded | expanded | extraexpanded | ultra-expanded $\mid$ inherit

Initial value: normal

Applies to: $\quad$ All elements

Inherited: $\quad$ Yes

As you might expect from the value names, this property is used to make a font's characters fatter or skinnier. It behaves very much like the absolute-size keywords (e.g., xxlarge) for the font-size property, with a range of absolute values and two values that let the author alter a font's stretching up or down. For example, an author might decide to stress the text in a strongly emphasized element by stretching the font characters to be wider than their parent element's font characters, as shown in Figure 5-21:

strong \{font-stretch: wider; \}

If there's one thing I can't stress enough, it's the value of Photoshop in producing a book like this one.

Figure 5-21. Stretching font characters



Figure 5-21 was altered using Photoshop, since web browsers do not support font-stretch as of this writing.

ar:

The similarly unimplemented process of adjusting font size is a little more complicated.

|  | font-size-adjust |
| :--- | :--- | :--- |
| Values: | <number> $\mid$ none $\mid$ inherit |
| Initial value: | none |
| Applies to: | All elements |
| Inherited: | Yes |

The goal of this property is to preserve legibility when the font used is not the author's first choice. Because of the differences in font appearance, one font may be legible at a certain size, while another font at the same size is difficult or impossible to read.

The factors that influence a font's legibility are its size and its x-height. The number that results from dividing the $\mathrm{x}$-height by the font-size is referred to as the aspect value. Fonts with higher aspect values tend to be legible as the font's size is reduced; conversely, fonts with low aspect values become illegible more quickly.

A good example is to compare the common fonts Verdana and Times. Consider Figure 5-22 and the following markup, which shows both fonts at a font-size of 10px:

p \{font-size: 10px; \}

p.cl1 \{font-family: Verdana, sans-serif; \}

p.cl2 \{font-family: Times, serif; \}



Figure 5-22. Comparing Verdana and Times

The text in Times is much harder to read than the Verdana text. This is partly due to the limitations of pixel-based display, but it is also because Times simply becomes harder to read at smaller font sizes.

As it turns out, the ratio of $x$-height to character size in Verdana is 0.58 , whereas in Times it is 0.46 . What you can do in this case is declare the aspect value of Verdana, and the user agent will adjust the size of the text that's actually used. This is accomplished using the formula:

Declared font-size $\times($ font-size-adjust value $\div$ aspect value of available font $)=$ Adjusted font-size

So, in a situation where Times is used instead of Verdana, the adjustment is as follows:

$10 p x \times(0.58 \div 0.46)=12.6 p x$

which leads to the result shown in Figure 5-23:

p \{font: 10px Verdana, sans-serif; font-size-adjust: $0.58 ;\}$

p.cl2 \{font-family: Times, serif; \}[^2]

Figure 5-23. Adjusting Times



Figure 5-23 was altered using Photoshop, since very few web browsers

Of course, to allow a user agent to intelligently make size adjustments, you have to know the aspect value of your first-choice font. There is no way in CSS2 to simply get the value from the font, and many fonts may not have the information available in the first place.

## The font Property

All of these properties are very sophisticated, of course, but using them all could get a little tedious:

h1 \{font-family: Verdana, Helvetica, Arial, sans-serif; font-size: 30px;

font-weight: 900; font-style: italic; font-variant: small-caps; \}

h2 \{font-family: Verdana, Helvetica, Arial, sans-serif; font-size: 24px;

font-weight: bold; font-style: italic; font-variant: normal;\}

Some of this problem could be solved by grouping selectors, but wouldn't it be easier to combine everything into a single property? Enter font, which is the shorthand property for all the other font properties (and a little more besides).

| font |  |
| :--- | :--- |
| Values: | $[[<$ font-style $>\|\|<$ font-variant $>\\|<$ font-weight $>]$ ? $<$ font-size> |
|  | $[/<$ line-height $>]$ ? $<$ font-family $>] \mid$ caption $\mid$ icon $\mid$ menu $\mid$ |
|  | message-box $\mid$ small-caption $\mid$ status-bar $\mid$ inherit |
| Initial value: | Refer to individual properties |
| Applies to: | All elements |
| Inherited: | Yes |
| Percentages: | Calculated with respect to the parent element for $<$ font-size $>$ and with <br> respect to the element's $<$ font-size $>$ for $<$ line-height $>$ |
| Computed value: | See individual properties $($ font-style, etc. $)$ |

Generally speaking, a font declaration can have any one value from each of the listed font properties, or else a "system font" value (described in the section "Using System Fonts"). Therefore, the preceding example could be shortened as follows:

h1 \{font: italic 900 small-caps 30px Verdana, Helvetica, Arial, sans-serif;\}

h2 \{font: bold normal italic 24px Verdana, Helvetica, Arial, sans-serif; \}

and have exactly the same effect (illustrated by Figure 5-24).

## This is a Heading-1 element <br> This is a Heading-2 element

Figure 5-24. Typical font rules

I say that the styles "could be" shortened in this way because there are a few other possibilities, thanks to the relatively loose way in which font can be written. If you look closely at the preceding example, you'll see that the first three values don't occur in the same order. In the h1 rule, the first three values are the values for fontstyle, font-weight, and font-variant, in that order, whereas in the second, they're ordered font-weight, font-variant, and font-style. There is nothing wrong here because these three can be written in any order. Furthermore, if any of them has a value of normal, that can be left out altogether. Therefore, the following rules are equivalent to the previous example:

h1 \{font: italic 900 small-caps 30px Verdana, Helvetica, Arial, sans-serif;\}

h2 \{font: bold italic 24px Verdana, Helvetica, Arial, sans-serif; \}

In this example, the value of normal was left out of the h2 rule, but the effect is exactly the same as in the preceding example.

It's important to realize, however, that this free-for-all situation applies only to the first three values of font. The last two are much stricter in their behavior. Not only must font-size and font-family appear in that order as the last two values in the declaration, but both must always be present in a font declaration. Period, end of story. If either is left out, then the entire rule will be invalidated and very likely ignored completely by a user agent. Thus, the following rules will get you the result shown in Figure 5-25:

h1 \{font: normal normal italic 30px sans-serif; \} /*no problem here */

h2 \{font: 1.5 em sans-serif; \} /* also fine; omitted values set to 'normal' */

h3 $\{$ font: sans-serif; \} /* INVALID--no 'font-size' provided */

h4 \{font: lighter 14px; \} /* INVALID--no 'font-family' provided */

## This is a Heading-1 element

## This is a Heading-2 element

## This is a Heading-3 element

This is a Heading-4 element

Figure 5-25. The necessity of both size and family

## Adding the Line Height

So far, we've treated font as though it has only five values, which isn't quite true. It is also possible to set the line-height using font, despite that fact that line-height is a text property, not a font property. It's done as a sort of addition to the font-size value, separated from it by a forward slash (/):

body \{font-size: $12 \mathrm{px}$; $\}$

h2 \{font: bold italic 200\%/1.2 Verdana, Helvetica, Arial, sans-serif; \}

These rules, demonstrated in Figure 5-26, set all h2 elements to be bold and italic (using face for one of the sans-serif font families), set the font-size to $24 p x$ (twice the body's size), and set the line-height to $28.8 \mathrm{px}$.

## This is a Heading-2 element that has had a 'line-height' of '1.2' set for it.

Figure 5-26. Adding line height to the mix

This addition of a value for line-height is entirely optional, just as the first three font values are. If you do include a line-height, remember that the font-size always comes before line-height, never after, and the two are always separated by a slash.

This may seem repetitive, but it's one of the most common errors made by CSS authors, so I can't say it enough: the required values for font are font-size and fontfamily, in that order. Everything else is strictly optional.



## Using Shorthands Properly

It is important to remember that font, being a shorthand property, can act in unexpected ways if you are careless with its use. Consider the following rules, which are illustrated in Figure 5-27:

h1, h2, h3 \{font: italic small-caps $250 \%$ sans-serif;\}

h2 \{font: $200 \%$ sans-serif; $\}$

h3 \{font-size: $150 \%$;

<h1>This is an h1 element</h1>

<h2>This is an h2 element</h2>

<h3>This is an h3 element</h3>

## THIS IS AN H1 ELEMENT This is an h2 element

THIS IS AN H3 ELEMENT

Figure 5-27. Shorthand changes

Did you notice that the h2 element is neither italicized nor small-capped, and that none of the elements are boldfaced? This is the correct behavior. When the shorthand property font is used, any omitted values are reset to their defaults. Thus, the previous example could be written as follows and still be exactly equivalent:

h1, h2, h3 \{font: italic normal small-caps $250 \%$ sans-serif; \}

h2 \{font: normal normal normal $200 \%$ sans-serif; $\}$

h3 $\{$ font-size: $150 \%$;

This sets the h2 element's font style and variant to normal, and the font-weight of all three elements to normal. This is the expected behavior of shorthand properties. The h3 does not suffer the same fate as the h2 because you used the property font-size, which is not a shorthand property and therefore affects only its own value.

## Using System Fonts

In situations where you want to make a web page "blend in" with the user's operating system, the system font values of font come in very handy. These are used to take the font size, family, weight, style, and variant of elements of the operating system, and apply them to an element. The values are as follows:

caption

Used for captioned controls, such as buttons

icon

Used to label icons

menu

Used in menus-that is, drop-down menus and menu lists

message-box

Used in dialog boxes

small-caption

Used for labeling small controls

status-bar

Used in window status bars

For example, you might want to set the font of a button to be the same as that of the buttons found in the operating system. For example:

button \{font: caption; \}

With these values, it is possible to create web-based applications that look very much like applications native to the user's operating system.

Note that system fonts may only be set as a whole; that is, the font family, size, weight, style, etc., are all set together. Therefore, the button text from our previous example will look exactly the same as button text in the operating system, whether or not the size matches any of the content around the button. You can, however, alter the individual values once the system font has been set. Thus, the following rule will make sure the button's font is the same size as its parent element's font:

button \{font: caption; font-size: $1 \mathrm{em}$; $\}$

If you call for a system font and no such font exists on the user's machine, the user agent may try to find an approximation, such as reducing the size of the caption font to arrive at the small-caption font. If no such approximation is possible, then the user agent should use a default font of its own. If it can find a system font but can't read all of its values, then it should use the default value. For example, a user agent may be able to find a status-bar font but not get any information about whether the font is smallcaps. In that case, the user agent will use the value normal for the small-caps property.



User interface styles are discussed in more detail in Chapter 13.

## Font Matching

As we've seen, CSS allows for the matching of font families, weights, and variants. This is all accomplished through font matching, which is a vaguely complicated procedure. Understanding it is important for authors who want to help user agents make good font selections when displaying their documents. I left it for the end of the chapter because it's not really necessary to understand how the font properties work, and some readers will probably want to skip this part and go on to the next chapter. If you're still interested, here's how font matching works.

1. The user agent creates, or otherwise accesses, a database of font properties. This database lists the various CSS properties of all of the fonts to which the user agent has access. Typically, this will be all fonts installed on the machine, although there could be others (for example, the user agent could have its own built-in fonts). If the user agent encounters two identical fonts, it will simply ignore one of them.
2. The user agent takes apart an element to which font properties have been applied and constructs a list of font properties necessary for the display of that element. Based on that list, the user agent makes an initial choice of a font family to use in
displaying the element. If there is a complete match, then the user agent can use that font. Otherwise, it needs to do a little more work.

a. A font is first matched against the font-style. The keyword italic is matched by any font that is labeled as either "italic" or "oblique." If neither is available, then the match fails.

b. The next match attempt is on font-variant. Any font that is not labeled "small-caps" is assumed to be normal. A font can be matched to small-caps by any font that is labeled as "small-caps," by any font that allows the synthesis of a small-caps style, or by any font where lowercase letters are replaced by uppercase letters.

c. The next match is to font-weight, which can never fail thanks to the way font-weight is handled in CSS (explained earlier in the chapter).

d. Then, font-size is tackled. This must be matched within a certain tolerance, but that tolerance is defined by the user agent. Thus, one user agent might allow matching within a 20 percent margin of error, whereas another might allow only 10 percent differences between the size specified and the size that is actually used.

3. If there was no font match in Step 2, the user agent looks for alternate fonts within the same font family. If it finds any, then it repeats Step 2 for that font.
4. Assuming a generic match has been found, but it doesn't contain everything needed to display a given element- the font is missing the copyright symbol, for instance - then the user agent goes back to Step 3, which entails a search for another alternate font and another trip through Step 2.
5. Finally, if no match has been made and all alternate fonts have been tried, then the user agent selects the default font for the given generic font family and does the best it can to display the element correctly.

The whole process is long and tedious, but it helps to understand how user agents pick the fonts they do. For example, you might specify the use of Times or any other serif font in a document:

body \{font-family: Times, serif; \}

For each element, the user agent should examine the characters in that element and determine whether Times can provide characters to match. In most cases, it can do so with no problem. Assume, however, that a Chinese character has been placed in the middle of a paragraph. Times has nothing that can match this character, so the user agent has to work around the character or look for another font that can fulfill the needs of displaying that element. Of course, any Western font is highly unlikely to contain Chinese characters, but should one exist (let's call it AsiaTimes), the user agent could use it in the display of that one element-or simply for the single character. Thus, the whole paragraph might be displayed using AsiaTimes, or everything in the paragraph might be in Times except for the single Chinese character, which is displayed in AsiaTimes.

## Font-Face Rules

CSS2 introduced a way to exert much greater control over font matching through an @font-face rule. Since no web browsers had fully implemented this rule as of spring 2003, @font-face was removed from CSS2.1. I will not spend much time on it, as the aspects of this rule are very complicated and could probably fill a chapter (or a book!) of their own.

There are four ways to arrive at a font to be used in the document. We'll look briefly at each, since future versions of CSS may use this mechanism, and most SVG renderers at least partially support the font-face matching described in CSS2. If you are in a situation where you need to implement @font-face, please refer to the CSS2 specification, or whatever the latest version of CSS might be (such as the CSS3 Web Fonts module); the following descriptions are incomplete at best.

## Font-name matching

To match the font name, the user agent uses an available font that has the same family name as the requested font. The font's appearance and metrics might not be the same. This is the method described earlier in this section.

## Intelligent font matching

In this case, the user agent uses an available font that is the closest match in appearance to the requested font. The two may not match exactly, but they should be as close as possible.

The information used to match the two fonts includes the kind of font (text or symbol), nature of serifs, weight, cap height, x-height, ascent, descent, slant, and so on. For example, an author could request that a certain font be as close as possible to a certain slant by writing:

$$
\text { @font-face \{font-style: normal; font-family: "Times"; slope: }-5 ;\}
$$

It would then be up to the user agent to find a serif normal (upright) font with a slope as close to five degrees to the right as possible, if Times does not fit the bill. There are a great many font aspects described in CSS2, all of which can be used to drive the matching process in a user agent that supports them.

## Font synthesis

It's also possible that a user agent would choose to actually generate, on the fly, a font whose appearance and metrics match the description given in the @font-face rule. CSS2 has this to say about the process:

In this case, the user agent creates a font that is not only a close match in appearance, but also matches the metrics of the requested font. The synthesizing information includes the matching information and typically requires more accurate values for the parameters than are used for some matching schemes. In particular, synthesis requires accurate width metrics and character to glyph substitution and position information if all the layout characteristics of the specified font are to be preserved.

If this makes sense to you, then you probably don't need my help to explain it. If not, you probably won't ever need to worry about it.

## Font download

In this approach, the user agent may download a remote font for use in the document. To declare a font for downloading, you might write something like this:

@font-face \{font-family: "Scarborough Fair";

src: $\operatorname{url}($ http://www.example.com/fonts/ps/scarborough.ps);\}

You could then use that font throughout the document.

Even in a user agent that permits font downloading, it may take some time to retrieve the font file (such files can be quite large), which would delay the rendering of the document or at least delay the final rendering.

## Summary

Although authors cannot count on a specific font being used in a document, they can very easily specify generic font families to be used. This particular behavior is very well supported, since any user agent that didn't let authors (or even readers) assign fonts would quickly find itself out of favor.

As for the other areas of font manipulation, support varies. Changing the size of fonts usually works well, but 20th-century implementations ranged from frustratingly simplistic to very nearly correct in this area. The frustration for authors is usually not the way in which font sizing is supported, but rather, in how a unit they want to use (points) can yield very different results in different media, or even in different operating systems and user agents. The dangers of using points are many, and using length units for web design is generally not a good idea. Percentages, em units, and ex units are usually best for changing font sizes, since these scale very well in all common display environments.

The other frustration is likely the continued lack of a mechanism to specify fonts for downloading and use in a document. This means that authors are still dependent on the fonts available to the user, and therefore, they cannot predict what appearance that text will take.

Speaking of styling text, there are ways to do it that don't involve fonts, which the next chapter will address.

## CHAPTER 6

## Text Properties

Sure, a lot of web design involves picking the right colors and getting the coolest look for your pages, but when it comes right down to it, you probably spend more of your time worrying about where text will go and how it will look. Such concerns gave rise to HTML tags such as <FONT> and 〈CENTER>, which allow you some measure of control over the appearance and placement of text.

Because text is so important, there are many CSS properties that affect it in one way or another. What is the difference between text and fonts? Simply, text is the content, and fonts are used to display that content. Using text properties, you can affect the position of text in relation to the rest of the line, superscript it, underline it, and change the capitalization. You can even simulate, to a limited degree, the use of a typewriter's Tab key.

## Indentation and Horizontal Alignment

Let's start with a discussion of how you can affect the horizontal positioning of text within a line. Think of these basic actions as the same types of steps you might take to create a newsletter or write a report.

## Indenting Text

Indenting the first line of a paragraph on a web page is one of the most sought-after text-formatting effects. (Eliminating the blank line between paragraphs, which is discussed in Chapter 7, is a close second.) Some sites create the illusion of indented text by placing a small transparent image before the first letter in a paragraph, which shoves over the text. Other sites use the utterly nonstandard SPACER tag. Thanks to CSS, there's a better way to indent text, called text-indent.

Using text-indent, the first line of any element can be indented by a given lengtheven if that length is negative. The most common use for this property is, of course, to indent the first line of paragraphs:

p \{text-indent: 3 em; $\}$



This rule will cause the first line of any paragraph to be indented three ems, as shown in Figure 6-1.

This is a paragraph element, which means that the first line will be indented a quarter-inch. The other lines in the paragraph will not be indented, no matter how long the paragraph may be.

Figure 6-1. Text indenting

In general, you can apply text-indent to any block-level element. You can't apply it to inline elements or on replaced elements such as images. However, if you have an image within the first line of a block-level element, like a paragraph, it will be shifted over with the rest of the text in the line.



If you want to "indent" the first line of an inline element, you can create the effect with left padding or margin.

You can also set negative values for text-indent, a technique that leads to a number of interesting effects. The most common use is a "hanging indent," where the first line hangs out to the left of the rest of the element:

p \{text-indent: $-4 \mathrm{em} ;\}$

Be careful when setting a negative value for text-indent: the first three words ("This is a") may be chopped off by the left edge of the browser window. To avoid display problems, I recommend you use a margin or some padding to accommodate the negative indentation:

p \{text-indent: -4em; padding-left: $4 \mathrm{em} ;\}$

Negative indents can, however, be used to your advantage. Consider the following example, demonstrated in Figure 6-2, which adds a floated image to the mix:

p.hang \{text-indent: $-25 \mathrm{px}$;

<img src="star.gif" style="width: 60px; height: 60px;

float: left;" alt="An image of a five-pointed star."/>

<p class="hang"> This paragraph has a negatively indented first

line, which overlaps the floated image that precedes the text. Subsequent

lines do not overlap the image, since they are not indented in any way.</p>

This paragraph has a negatively indented first line, which

$\sum \sqrt{3}$

overlaps the floated image that precedes the text.

Subsequent lines do not overlap the image, since they are not indented in any way.

Figure 6-2. A floated image and negative text indenting

A variety of interesting designs can be achieved using this simple technique.

Any unit of length, including percentage values, may be used with text-indent. In the following case, the percentage refers to the width of the parent element of the element being indented. In other words, if you set the indent value to $10 \%$, the first line of an affected element will be indented by 10 percent of its parent element's width, as shown in Figure 6-3:

div $\{$ width: $400 \mathrm{px} ;\}$

p \{text-indent: $10 \%$;

<div>

<p>This paragraph is contained inside a DIV, which is 400px wide, so the

first line of the paragraph is indented $40 \mathrm{px}(400 * 10 \%=40)$. This is

because percentages are computed with respect to the width of the element.</p>

</div>

This paragraph is contained inside a DIV that is 400px

wide, so the first line of the paragraph is indented 40px ( 400 *

$10 \%=40$ ). This is because percentages are computed with

respect to the width of the element.

Figure 6-3. Text indenting with percentages

Note that this indentation only applies to the first line of an element, even if you insert line breaks. The interesting part about text-indent is that because it's inherited, it can have unexpected effects. For example, consider the following markup, which is illustrated in Figure 6-4:

div\#outer \{width: 500px; \}

div\#inner $\{$ text-indent: $10 \%$; $\}$

p \{width: 200px; \}
<div id="outer">

<div id="inner">

This first line of the DIV is indented by 50 pixels.

<p>

This paragraph is 200px wide, and the first line of the paragraph

is indented 50px. This is because computed values for 'text-indent'

are inherited, instead of the declared values.

$\langle/ p>$

</div>

</div>

This first line of the DIV is indented by 50 pixels.

This paragraph is $200 \mathrm{px}$

wide, and the first line of the paragraph is indented $50 \mathrm{px}$. This is because computed values for 'text-indent' are inherited, instead of the declared values.

Figure 6-4. Inherited text indenting



In versions of CSS prior to 2.1, text-indent always inherited the computed value, not the declared value.

## Horizontal Alignment

Even more basic than text-indent is the property text-align, which affects how the lines of text in an element are aligned with respect to one another. The first three values are pretty straightforward, but the fourth and fifth have a few complexities.

## text-align

CSS2.1 values: $\quad$ left $\mid$ center $\mid$ right $\mid$ justify $\mid$ inherit

CSS2 values: $\quad$ left $\mid$ center $\mid$ right $\mid$ justify $\mid$ <string> $\mid$ inherit

Initial value: User agent-specific; may also depend on writing direction

Applies to: Block-level elements

Inherited: Yes

Computed value: As specified

Note: $\quad$ CSS2 included a <string> value that was dropped from CSS2. 1 due to a lack of implementation

The quickest way to understand how these values work is to examine Figure 6-5.

This paragraph assumes the style text-al ign: 1 eft $;$, which causes the line boxes within the element to line up along the left inner content edge of the paragraph

This paragraph assumes the style text-al ign: right $_{i}$, which causes the line: boxes within the element to line up along the right inner content edge of the paragraph.

This paragraph assumes the style text-al ign: center $;$, which causes the line boxes within the element to line up their centers with the center of the content area of the paragraph

This paragraph assumes the style text-al ign: justify $\boldsymbol{i}$, which causes the line boxes within the element to align their left and right edges to the left and right inner content edges of the paragraph. The exception is the last line box, whose right edge does not align with the right content edge of the paragraph. In right-to-left languages, the left edge of the last line box would not be so aligned.)

Figure 6-5. Behaviors of the text-align property

Obviously, the values left, right, and center cause the text within elements to be aligned exactly as described. Because text-align applies only to block-level elements, such as paragraphs, there's no way to center an anchor within its line without aligning the rest of the line (nor would you want to, since that would likely cause text overlap).

For Western languages, which are read from left to right, the default value of textalign is left. The text aligns on the left margin and has a ragged right margin (otherwise known as "left-to-right" text). Languages such as Hebrew and Arabic default to right since they are read right to left. As expected, center causes each line of text to be centered within the element.



Centering block-level or table elements is accomplished by properly setting the left and right margins on those elements. See Chapter 7 for details.

Although you may be tempted to believe that text-align: center is the same as the <CENTER> element, it's actually quite different. <CENTER> affected not only text, but also centered whole elements, such as tables. text-align does not control the alignment of elements, only their inline content. Figure 6-5 illustrates this clearly. The actual elements are not shifted from one side to the other. Only the text within them is affected.



One of the more pernicious bugs in IE/Win up through IE6 is that it actually does treat text-align: center as if it were the 〈CENTER> element, and centers elements as well as text. This does not happen in standards mode in IE6 and later, but it persists in IE5.x and earlier.

The last horizontal alignment property is justify, which raises some issues of its own. In justified text, both ends of a line of text are placed at the inner edge of the parent element, as Figure 6-6 shows. Then, the spacing between words and letters is adjusted so that each line is precisely the same length. Justified text is common in the print world (for example, in this book), but under CSS, a few extra considerations come into play.

## This is a paragraph of justified text. Notice that the spacing between words, or even between individual letters, depends greatly on the number of words in each line. Intraword and intracharacter spacing is adjusted to create the justification effect, so it can effectively override values for properties such as word-spacing and letter-spacing.

Figure 6-6. Justified text

The user agent-not CSS-determines how justified text should be stretched to fill the space between the left and right edges of the parent. Some browsers, for example, might add extra space only between words, while others might distribute the extra space between letters (although the CSS specification specifically states that "user agents may not further increase or decrease the inter-character space" if the property letter-spacing has been assigned a length value). Other user agents may reduce space on some lines, thus mashing the text together a bit more than usual. All of these possibilities will affect the appearance of an element, and may even change its height, depending on how many lines of text result from the user agent's justification choices.

CSS also doesn't specify how hyphenation should be handled." Most justified text uses hyphenation to break long words across two lines, thus reducing the space between words and improving the appearance of lines. However, since CSS defines no hyphenation behavior, user agents are unlikely to perform any automatic hyphenation. As a result, justified text looks much less attractive under CSS than it does in print, especially when elements become so narrow that only a few words can fit on each line. You can still use narrow design elements, of course, but be aware of the drawbacks.[^3]

## Vertical Alignment

Now that we've covered horizontal alignment, let's move on to vertical alignment. Since the construction of lines is covered in much more detail in Chapter 7, I'll just stick to a quick overview here.

## The Height of Lines

The line-height property refers to the distance between the baselines of lines of text rather than the size of the font, and it determines the amount by which the height of each element's box is increased or decreased. In the most basic cases, specifying line-height is a way to increase (or decrease) the vertical space between lines of text, but this is a misleadingly simple way of looking at how line-height works. lineheight controls the leading, which is the extra space between lines of text above and beyond the font's size. In other words, the difference between the value of lineheight and the size of the font is the leading.



When applied to a block-level element, line-height defines the minimum distance between text baselines within that element. Note that it defines a minimum, not an absolute value, and baselines of text can wind up being pushed further apart than the value of line-height. line-height does not affect layout for replaced elements, but it still applies to them. (This subtle mystery is explained in Chapter 7.)

## Constructing a line

Every element in a line of text generates a content area, which is determined by the size of the font. This content area in turn generates an inline box that is, in the absence of any other factors, exactly equal to the content area. The leading generated by lineheight is one of the factors that increases or decreases the height of each inline box.

To determine the leading for a given element, simply subtract the computed value of font-size from the computed value of line-height. That value is the total amount of
leading. And remember, it can be a negative number. The leading is then divided in half, and each half-leading is applied to the top and bottom of the content area. The result is the inline box for that element.

As an example, let's say the font-size (and therefore the content area) is 14 pixels tall, and the line-height is computed to 18 pixels. The difference (four pixels) is divided in half, and each half is applied to the top and bottom of the content area. This creates an inline box that is 18 pixels tall, with 2 extra pixels above and below the content area. This sounds like a roundabout way to describe how line-height works, but there are excellent reasons for the description.

Once all of the inline boxes have been generated for a given line of content, they are then considered in the construction of the line box. A line box is exactly as tall as needed to enclose the top of the tallest inline box and the bottom of the lowest inline box. Figure 6-7 shows a diagram of this process.



Figure 6-7. Line box diagram

## Assigning values to line-height

Let's now consider the possible values of line-height. If you use the default value of normal, the user agent must calculate the vertical space between lines. Values can vary by user agent, but they're generally 1.2 times the size of the font, which makes line boxes taller than the value of font-size for a given element.

Most values are simple length measures (e.g., 18px or 2em). Be aware that even if you use a valid length measurement, such as $4 \mathrm{~cm}$, the browser (or the operating system) may be using an incorrect metric for real-world measurements, so the line height may not show up as exactly four centimeters on your monitor. For more details, see Chapter 4.

em, ex, and percentage values are calculated with respect to the font-size of the element. The markup is relatively straightforward, and the results are shown in Figure 6-8:

body \{line-height: 14px; font-size: 13px; \}

p.cl1 \{line-height: $1.5 \mathrm{em} ;\}$

p.cl2 \{font-size: 10px; line-height: $150 \%$;

p.cl3 \{line-height: 0.33 in; $\}$

<p>This paragraph inherits a 'line-height' of $14 p x$ from the body, as well as

a 'font-size' of $13 \mathrm{px} .</ p>$

<p class="cl1">This paragraph has a 'line-height' of $19.5 \mathrm{px}(13 * 1.5)$, so

it will have slightly more line-height than usual.</p>

<p class="cl2">This paragraph has a 'line-height' of $15 p x(10 * 150 \%)$, so

it will have slightly more line-height than usual.</p>

<p class="cl3">This paragraph has a 'line-height' of 0.33 in, so it will have

slightly more line-height than usual.</p>

This paragraph inherits a 'line-height' of $14 \mathrm{px}$ from the body, as well as a 'font-size' of $13 \mathrm{px}$.

This paragraph has a 'line-height' of $21 \mathrm{px}(14 * 1.5)$, so it will have slightly more line-height than usual.

This paragrymh has a 'line-height' of $15 \mathrm{px}(10 * 150 \%)$, so it will have slightly more lime-height than usual.

This paragraph has a 'line-height' of 0.33in, so it will have slightly more line-height than usual

Figure 6-8. Simple calculations with the line-height property

## Line height and inheritance

When the line-height is inherited by one block-level element from another, things get a bit trickier. line-height values inherit from the parent element as computed from the parent, not the child. The results of the following markup are shown in Figure 6-9. It probably wasn't what the author had in mind:



This paragraph's ' font size' is 18 px , but the inherited line-hight viner by

Figure 6-9. Small line-height, large font-size, slight problem

Why are the lines so close together? Because the computed line-height value of 10px was inherited by the paragraph from its parent div. One solution to the small lineheight problem depicted in Figure 6-9 is to set an explicit line-height for every element, but that's not very practical. A better alternative is to specify a number, which actually sets a scaling factor:

body \{font-size: $10 \mathrm{px}$; $\}$

div $\{$ line-height: 1 ; $\}$

p \{font-size: 18px; \}

When you specify a number, you cause the scaling factor to be an inherited value instead of a computed value. The number will be applied to the element and all of its child elements, so that each element has a line-height calculated with respect to its own font-size (see Figure 6-10):

div \{line-height: $1.5 ;\}$

p \{font-size: $18 \mathrm{px}$; $\}$

<div>

<p>This paragraph's 'font-size' is 18px, and since the 'line-height'

set for the parent div is 1.5, the 'line-height' for this paragraph

is $27 \mathrm{px}(18 * 1.5) .\langle/ \mathrm{p}\rangle$

</div>

This paragraph's 'font-size' is $18 \mathrm{px}$, and since the 'line-height' set for the parent div is 1.5 , the 'line-height' for this paragraph is $27 \mathrm{px}$ (18

* 1.5 ).

Figure 6-10. Using line-height factors to overcome inheritance problems

Though it seems like line-height distributes extra space both above and below each line of text, it actually adds (or subtracts) a certain amount from the top and bottom of an inline element's content area to create an inline box. Assume that the default font-size of a paragraph is 12pt and consider the following:

p \{line-height: $16 p t ;\}$

Since the "inherent" line height of 12-point text is 12 points, the preceding rule will place an extra 4 points of space around each line of text in the paragraph. This extra amount is divided in two, with half going above each line and the other half below. You now have 16 points between the baselines, which is an indirect result of how the extra space is apportioned.

If you specify the value inherit, then the element will use the computed value for its parent element. This isn't really any different than allowing the value to inherit naturally, except in terms of specificity and cascade resolution. See Chapter 3 for details on these topics.

Now that you have a basic grasp of how lines are constructed, let's talk about vertically aligning elements relative to the line box.

## Vertically Aligning Text

If you've ever used the elements sup and sub (the superscript and subscript elements), or used an image with markup such as <img src="foo.gif" align="middle">, then you've done some rudimentary vertical alignment. In CSS, the vertical-align property applies only to inline elements and replaced elements such as images and form inputs. vertical-align is not an inherited property.

## vertical-align

Values: $\quad$ baseline $\mid$ sub $\mid$ super $\mid$ top $\mid$ text-top $\mid$ middle $\mid$ bottom $\mid$ text-bottom $\mid$ <percentage> $\mid$ <ength> $\mid$ inherit

Initial value: baseline

Applies to: $\quad$ Inline elements and table cells

Inherited: No

Percentages: Refer to the value of line-height for the element

Computed value: For percentage and length values, the absolute length; otherwise, as specified

Note: $\quad$ When applied to table cells, only the values baseline, top, middle, and bottom are recognized

vertical-align accepts any one of eight keywords, a percentage value, or a length value. The keywords are a mix of the familiar and unfamiliar: baseline (the default value), sub, super, bottom, text-bottom, middle, top, and text-top. We'll examine how each keyword works in relation to inline elements.



Remember: vertical-align does not affect the alignment of content within a block-level element. You can, however, use it to affect the vertical alignment of elements within table cells. See Chapter 11 for details.

## Baseline alignment

vertical-align: baseline forces the baseline of an element to align with the baseline of its parent. Browsers, for the most part, do this anyway, since you'd obviously expect the bottoms of all text elements in a line to be aligned.

If a vertically aligned element doesn't have a baseline-that is, if it's an image, a form input, or another replaced element-then the bottom of the element is aligned with the baseline of its parent, as Figure 6-11 shows:

img \{vertical-align: baseline; \}

<p>The image found in this paragraph <img src="dot.gif" alt="A dot" /> has its bottom edge aligned with the baseline of the text in the paragraph.</p>

The image found in this paragraph $\bullet$ has its bottom edge aligned with the baseline of the paragraph

Figure 6-11. Baseline alignment of an image

This alignment rule is important because it causes some web browsers to always put a replaced element's bottom edge on the baseline, even if there is no other text in the line. For example, let's say you have an image in a table cell all by itself. The image may actually be on a baseline, but in some browsers, the space below the baseline causes a gap to appear beneath the image. Other browsers will "shrink-wrap" the image with the table cell, and no gap will appear. The gap behavior is correct, according to the CSS Working Group, despite its lack of appeal to most authors.



See my article "Images, Tables, and Mysterious Gaps" at http:// developer.mozilla.org/en/docs/Images,_Tables,_and_Mysterious_Gaps for

explation of gap around it. Chapter 7 also covers this aspect of inline layout in more detail.

## Superscripting and subscripting

The declaration vertical-align: sub causes an element to be subscripted, meaning that its baseline (or bottom, if it's a replaced element) is lowered with respect to its parent's baseline. The specification doesn't define the distance the element is lowered, so it may vary depending on the user agent.

super is the opposite of sub; it raises the element's baseline (or bottom of a replaced element) with respect to the parent's baseline. Again, the distance the text is raised depends on the user agent.

Note that the values sub and super do not change the element's font size, so subscripted or superscripted text will not become smaller (or larger). Instead, any text in the sub- or superscripted element should be, by default, the same size as text in the parent element, as illustrated by Figure 6-12:

span.raise \{vertical-align: super; \}

span.lower \{vertical-align: sub;\}

<p>This paragraph contains <span class="raise">superscripted</span>

and <span class="lower">subscripted</span> text.</P>

This paragraph contains superscripted and subscripted $^{\text {text. }}$

Figure 6-12. Superscript and subscript alignment



If you wish to make super- or subscripted text smaller than the text of its parent element, you can do so using the property font-size, which is covered in Chapter 5.

## Bottom feeding

vertical-align: bottom aligns the bottom of the element's inline box with the bottom of the line box. For example, the following markup results in Figure 6-13:

.feeder \{vertical-align: bottom;\}

<p>This paragraph, as you can see quite clearly, contains

a <img src="tall.gif" alt="tall" class="feeder" /> image and

a <img src="short.gif" alt="short" class="feeder" /> image,

and then some text that is not tall.</p>

This paragraph, as you can see quite clearly,

contains a $\begin{gathered}T \\ A \\ L \\ L\end{gathered}$ image and $a_{\text {[SमorT }}$ image, and then some text that is not tall.

Figure 6-13. Bottom alignment

The second line of the paragraph in Figure 6-13 contains two inline elements, whose bottom edges are aligned with each other. They're also below the baseline of the text. vertical-align: text-bottom refers to the bottom of the text in the line. For the purposes of this value, replaced elements, or any other kinds of non-text elements, are ignored. Instead, a "default" text box is considered. This default box is derived from the font-size of the parent element. The bottom of the aligned element's inline box is then aligned with the bottom of the default text box. Thus, given the following markup, you get a result like the one shown in Figure 6-14:

img.tbot \{vertical-align: text-bottom; \}

<p>Here: a <img src="tall.gif" style="vertical-align: middle;" alt="tall" />

image, and then a <img src="short.gif" class="tbot" alt="short" /> image.</p>



Figure 6-14. Text-bottom alignment

## Getting on top

Employing vertical-align: top has the opposite effect of bottom. Likewise, verticalalign: text-top is the reverse of text-bottom. Figure 6-15 shows how the following markup would be rendered:

.up $\{$ vertical-align: top; $\}$

.textup \{vertical-align: text-top; $\}$

<p>Here: a <img src="tall.gif" alt="tall image"> tall image, and then <span class="up">some text</span> that's been vertically aligned.</p> <p>Here: a <img src="tall.gif" class="textup" alt="tall"> image that's been vertically aligned, and then a <img src="short.gif" class="textup" alt="short" /> image that's similarly aligned.</p>



Figure 6-15. Aligning with the top and text-top of a line

Of course, the exact position of this alignment will depend on which elements are in the line, how tall they are, and the size of the parent element's font.

## In the middle

There's the value middle, which is usually (but not always) applied to images. It does not have the exact effect you might assume given its name. middle aligns the middle of an inline element's box with a point that is 0.5 ex above the baseline of the parent element, where $1 \mathrm{ex}$ is defined relative to the font-size for the parent element. Figure 6-16 shows this in more detail.



Figure 6-16. Precise detail of middle alignment

Since most user agents treat $1 \mathrm{ex}$ as one-half em, middle usually aligns the vertical midpoint of an element with a point one-quarter em above the parent's baseline. Don't rely on this happening, however, since some user agents actually calculate the exact $\mathrm{x}$-height for each element. (See Chapter 5 for more details on $\mathrm{x}$-height.)

## Percentages

Percentages don't let you simulate align="middle" for images. Instead, setting a percentage value for vertical-align raises or lowers the baseline of the element (or the bottom edge of a replaced element) by the amount declared, with respect to the
parent's baseline. (The percentage you specify is calculated as a percentage of lineheight for the element, not its parent.) Positive percentage values raise the element, and negative values lower it. Depending on how the text is raised or lowered, it can appear to be placed in adjacent lines, as shown in Figure 6-17, so take care when using percentage values:

sub $\{$ vertical-align: $-100 \%$;

sup $\{$ vertical-align: $100 \%$;

<p>We can either <sup>soar to new heights</sup> or, instead, <sub>sink into despair...</sub></p>

We can either soar to new heights or, instead, sink into despair...

Figure 6-17. Percentages and fun effects

Let's consider percentage values in more detail. Assume the following:

<div style="font-size: 14px; line-height: 18px;">

I felt that, if nothing else, I deserved a

<span style="vertical-align: 50\%;">raise</span> for my efforts.

</div>

The 50\%-aligned span element has its baseline raised nine pixels, which is half of the element's inherited line-height value of 18px, not seven pixels.

## Length alignment

Finally, let's consider vertical alignment with a specific length. vertical-align is very straightforward: it shifts an element up or down by the declared distance. Thus, vertical-align: $5 \mathrm{px}$; will shift an element upward five pixels from its unaligned placement. Negative length values shift the element downward. This simple form of alignment did not exist in CSS1, but it was added in CSS2.

It's important to realize that vertically aligned text does not become part of another line, nor does it overlap text in other lines. Consider Figure 6-18, in which some vertically aligned text appears in the middle of a paragraph.

## This paragraph contains a lot of text to be dislpayed, and a part of that boldfaced text <br> text is some which is raised up $100 \%$. This makes it look as though the boldfaced text is on a preceding line, but notice that the line is actually taller than ordinary.

Figure 6-18. Vertical alignments can cause lines to get taller

As you can see, any vertically aligned element can affect the height of the line. Recall the description of a line box, which is exactly as tall as necessary to enclose the top of the tallest inline box and the bottom of the lowest inline box. This includes inline boxes that have been shifted up or down by vertical alignment.

## Word Spacing and Letter Spacing

Now that we've dealt with alignment, let's look at manipulating word and letter spacing. As usual, these properties have some nonintuitive issues.

## Word Spacing

The word-spacing property accepts a positive or negative length. This length is added to the standard space between words. In effect, word-spacing is used to modify interword spacing. Therefore, the default value of normal is the same as setting a value of zero (0).



If you supply a positive length value, then the space between words will increase. Setting a negative value for word-spacing brings words closer together:

p.spread \{word-spacing: $0.5 \mathrm{em} ;\}$

p.tight $\{$ word-spacing: $-0.5 \mathrm{em} ;\}$

p.base $\{$ word-spacing: normal; $\}$

p.norm $\{$ word-spacing: $0 ;\}$

$<p$ class="spread">The spaces between words in this paragraph will be increased by $0.5 \mathrm{em} .\langle/ p\rangle$

<p class="tight">The spaces between words in this paragraph will be decreased by $0.5 \mathrm{em} .</ p>$

<p class="base">The spaces between words in this paragraph will be normal.</p>

<p class="norm">The spaces between words in this paragraph will be normal.</p>

Manipulating these settings has the effect shown in Figure 6-19.



The spaces between words in this paragraph will be increased by $0.5 \mathrm{em}$.

Thespacebetweenwordsthiparagraphwilb edecrease by $0.5 \mathrm{em}$.

The spaces between words in this paragraph will be normal.

The spaces between words in this paragraph will be normal.

Figure 6-19. Changing the space between words

So far, I haven't actually given you a precise definition of "word." In the simplest CSS terms, a "word" is any string of nonwhitespace characters that is surrounded by whitespace of some kind. This definition has no real semantic meaning; it simply assumes that a document contains words surrounded by one or more whitespace characters. A CSS-aware user agent cannot be expected to decide what is a valid word in a given language and what isn't. This definition, such as it is, means wordspacing is unlikely to work in any languages that employ pictographs, or non-Roman writing styles. The property allows you to create very unreadable documents, as Figure 6-20 makes clear. Use word-spacing with care.

| The | spaces | between | words |
| :--- | :---: | :---: | :---: |
| in | this | paragraph | will |
| be | increased | by | one |
| inch. |  |  |  |

Figure 6-20. Really wide word spacing

## Letter Spacing

Many of the issues you encounter with word-spacing also occur with letter-spacing. The only real difference between the two is that letter-spacing modifies the space between characters, or letters.

## letter-spacing

Values: $\quad<$ length $>\mid$ normal $\mid$ inherit

Initial value: normal

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: For length values, the absolute length; otherwise, normal

As with the word-spacing property, the permitted values of letter-spacing include any length. The default keyword is normal (making it the same as letter-spacing: 0 ). Any length value you enter will increase or decrease the space between letters by that amount. Figure 6-21 shows the results of the following markup:

p \{letter-spacing: $0 ;\}$ /* identical to 'normal' */

p.spacious $\{$ letter-spacing: $0.25 \mathrm{em} ;\}$

p.tight \{letter-spacing: $-0.25 \mathrm{em} ;\}$

<p>The letters in this paragraph are spaced as normal.</p>

<p class="spacious">The letters in this paragraph are spread out a bit.</p>

<p class="tight">The letters in this paragraph are a bit smashed together.</p>

The letters in this paragraph are spaced as normal.

The letters in this paragraph are spread out a bit.

Thingingsodretghah

Figure 6-21. Various kinds of letter spacing

Using letter-spacing to increase emphasis is a time-honored technique. You might write the following declaration and get an effect like the one shown in Figure 6-22:

strong \{letter-spacing: $0.2 \mathrm{em}$; $\}$

<p>This paragraph contains <strong>strongly emphasized text</strong>

that is spread out for extra emphasis.</p>

This paragraph contains strongly emphasized text that is spread out for extra emphasis.

Figure 6-22. Using letter-spacing to increase emphasis

## Spacing and Alignment

The value of word-spacing may be influenced by the value of the property text-align. If an element is justified, the spaces between letters and words may be altered to fit the text along the full width of the line. This may in turn alter the spacing declared by the author with word-spacing. If a length value is assigned to letter-spacing, then it cannot be changed by text-align, but if the value of letter-spacing is normal, then inter-character spacing may be changed in order to justify the text. CSS does not specify how the spacing should be calculated, so user agents simply fill it in.

As usual, the child of an element inherits the computed value of that element. You cannot define a scaling factor for word-spacing or letter-spacing to be inherited in place of the computed value (as is the case with line-height). As a result, you may run into problems such as those shown in Figure 6-23:
p \{letter-spacing: $0.25 \mathrm{em}$; font-size: $20 \mathrm{px}$; $\}$

small \{font-size: $50 \%$;

<p>This spacious paragraph features <small>tiny text that is just

as spacious</small>, even though the author probably wanted the

spacing to be in proportion to the size of the text.</p>

## This spacious paragraph features tiny text that is just as spacious, even though the author probably wanted the spacing to be in proportion to the size of the text.

Figure 6-23. Inherited letter spacing

The only way to achieve letter spacing that's in proportion to the size of the text is to set it explicitly, as follows:

p \{letter-spacing: $0.25 \mathrm{em} ;\}$

small \{font-size: $50 \%$; letter-spacing: $0.25 \mathrm{em}$;

## Text Transformation

Now let's look at ways to manipulate the capitalization of text using the property text-transform.

## text-transform

Values: $\quad$ uppercase $\mid$ lowercase $\mid$ capitalize $\mid$ none $\mid$ inherit

Initial value: none

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: As specified

The default value none leaves the text alone and uses whatever capitalization exists in the source document. As their names imply, uppercase and lowercase convert text into all upper- or lowercase characters. Finally, capitalize capitalizes only the first letter of each word. Figure 6-24 illustrates each of these settings in a variety of ways:

h1 \{text-transform: capitalize; \}

strong \{text-transform: uppercase; $\}$

p.cummings \{text-transform: lowercase; \}

p.raw $\{$ text-transform: none; $\}$

<h1>The heading-one at the beginninG</h1>

$\langle p\rangle$



## The Heading-one At The BeginninG

By default, text is displayed in the capitalization it has in the source document, but IT IS POSSIBLE TO CHANGE THIS using the property 'text-transform'.

for example, one could create text such as might have been written by the late poet e.e.cummings.

If you feel the need to Explicitly Declare the transformation of text to be 'none', that can be done as well.

Figure 6-24. Various kinds of text transformation

Different user agents may have different ways of deciding where words begin and, as a result, which letters are capitalized. For example, the text "heading-one" in the h1 element, shown in Figure 6-24, could be rendered in one of two ways: "Headingone" or "Heading-One." CSS does not say which is correct, so either is possible.

You probably also noticed that the last letter in the h1 element in Figure 6-24 is still uppercase. This is correct: when applying a text-transform of capitalize, CSS only requires user agents to make sure the first letter of each word is capitalized. They can ignore the rest of the word.

As a property, text-transform may seem minor, but it's very useful if you suddenly decide to capitalize all your h1 elements. Instead of individually changing the content of all your h1 elements, you can just use text-transform to make the change for you:

h1 \{text-transform: uppercase; \}

<h1>This is an H1 element</h1>

The advantages of using text-transform are twofold. First, you only need to write a single rule to make this change, rather than changing the h1 itself. Second, if you decide later to switch from all capitals back to initial capitals, the change is even easier, as Figure 6-25 shows:

h1 \{text-transform: capitalize; \}

<h1>This is an H1 element</h1>

## This Is An H1 Element

Figure 6-25. Transforming an H1 element

## Text Decoration

Next we come to text-decoration, which is a fascinating property that offers a whole truckload of interesting behaviors.

|  | text-decoration |
| :--- | :--- |
| Values: | none \| [ underline || overline || line-through || blink ] | inherit |
| Initial value: | none |
| Applies to: | All elements |
| Inherited: | No |
| Computed value: | As specified |

As you might expect, underline causes an element to be underlined, just like the $U$ element in HTML. overline causes the opposite effect-drawing a line across the top of the text. The value line-through draws a line straight through the middle of the text, which is also known as strikethrough text and is equivalent to the $S$ and strike elements in HTML. blink causes the text to blink on and off, just like the much-maligned blink tag supported by Netscape. Figure 6-26 shows examples of each of these values:

p.emph \{text-decoration: underline; $\}$

p.topper \{text-decoration: overline; $\}$

p.old \{text-decoration: line-through; \}

p.annoy \{text-decoration: blink; \}

p.plain \{text-decoration: none; \}



It's impossible to show the effect of blink in print, of course, but it's easy enough to imagine (perhaps all too easy). Incidentally, user agents are not required to support blink, and as of this writing, Internet Explorer never has.

The value none turns off any decoration that might otherwise have been applied to an element. Usually, undecorated text is the default appearance, but not always. For example, links are usually underlined by default. If you want to suppress the underlining of hyperlinks, you can use the following CSS rule to do so:

a $\{$ text-decoration: none; $\}$

The text of this paragraph, which has a class of 'emph', is underlined.

The text of this paragraph, which has a class of 'topper', is overlined.

The tex of this paragraph, whieh has a class of 'old', is strieken (fine-through).

The text of this paragraph, which has a class of 'annoy', is blinking (trust us).

The text of this paragraph, which has a class of 'plain', has no decoration of any kind.

Figure 6-26. Various kinds of text decoration

If you explicitly turn off link underlining with this sort of rule, the only visual difference between the anchors and normal text will be their color (at least by default, though there's no ironclad guarantee that there will be a difference in their colors).



Although I personally don't have a problem with it, many users are annoyed when they realize you've turned off link underlining. It's a

: matter of opinion, so let your own tastes be your guide, but remember: if your link colors aren't sufficiently different from normal text, users may have a hard time finding hyperlinks in your documents.

You can also combine decorations in a single rule. If you want all hyperlinks to be both underlined and overlined, the rule is:

a:link, a:visited \{text-decoration: underline overline; \}

Be careful, though: if you have two different decorations matched to the same element, the value of the rule that wins out will completely replace the value of the loser. Consider:

h2.stricken \{text-decoration: line-through;\}

h2 \{text-decoration: underline overline; \}

Given these rules, any h2 element with a class of stricken will have only a linethrough decoration. The underline and overline decorations are lost, since shorthand values replace one another instead of accumulating.

## Weird Decorations

Now, let's look into the unusual side of text-decoration. The first oddity is that text-decoration is not inherited. No inheritance implies that any decoration lines
drawn with the text-under, over, or through it-will be the same color as the parent element. This is true even if the descendant elements are a different color, as depicted in Figure 6-27:

p \{text-decoration: underline; color: black; \}

strong \{color: gray; \}

<p>This paragraph, which is black and has a black underline, also contains <strong>strongly emphasized text</strong> which has the black underline beneath it as well.</p>

This paragraph, which is black and has a black underline, also contains strongly emphasized text which has the black underline beneath it as well.

Figure 6-27. Color consistency in underlines

Why is this so? Because the value of text-decoration is not inherited, the strong element assumes a default value of none. Therefore, the strong element has no underline. Now, there is very clearly a line under the strong element, so it seems silly to say that it has none. Nevertheless, it doesn't. What you see under the strong element is the paragraph's underline, which is effectively "spanning" the strong element. You can see it more clearly if you alter the styles for the boldface element, like this:



The result is identical to the one shown in Figure 6-27, since all you've done is to explicitly declare what was already the case. In other words, there is no way to turn off underlining (or overlining or a line-through) generated by a parent element.

When text-decoration is combined with vertical-align, even stranger things can happen. Figure 6-28 shows one of these oddities. Since the sup element has no decoration of its own, but it is elevated within an overlined element, the overline cuts through the middle of the sup element:

p \{text-decoration: overline; font-size: 12pt;\}

sup \{vertical-align: $50 \%$; font-size: 12 pt; $\}$

年)

This paragraph, which is black and has a black overline, also contains stperscripted text through which the overline will cut.

Figure 6-28. Correct, although strange, decorative behavior

By now you may be vowing never to use text decorations because of all the problems they could create. In fact, I've given you the simplest possible outcomes since we've
explored only the way things should work according to the specification. In reality, some web browsers do turn off underlining in child elements, even though they aren't supposed to. The reason browsers violate the specification is simple enough: author expectations. Consider this markup:



Figure 6-29 shows the display in a web browser that has switched off the underlining for the strong element.

This paragraph, which is black and has a black underline, also contains boldfaced text which does not have black unclerline beneath it.

Figure 6-29. How some browsers really behave

The caveat here is that many browsers do follow the specification, and future versions of existing browsers (or any other user agents) might one day follow the specification precisely. If you depend on using none to suppress decorations, it's important to realize that it may come back to haunt you in the future, or even cause you problems in the present. Then again, future versions of CSS may include the means to turn off decorations without using none incorrectly, so maybe there's hope.

There is a way to change the color of a decoration without violating the specification. As you'll recall, setting a text decoration on an element means that the entire element has the same color decoration, even if there are child elements of different colors. To match the decoration color with an element, you must explicitly declare its decoration, as follows:



In Figure 6-30, the strong element is set to be gray and to have an underline. The gray underline visually "overwrites" the parent's black underline, so the decoration's color matches the color of the strong element.

This paragraph, which is black and has a black underline, also contains strongly emphasized text which has the black underline beneath it as well, but whose gray underline overlays the black underline of its parent.

Figure 6-30. Overcoming the default behavior of underlines

## Text Shadows

CSS2 includes a property for adding drop shadows to text, but this property did not make it into CSS2.1 because no browser had implemented full support for it by the time CSS2.1 was completed. When you consider the effort necessary to make a web browser determine the outlines of text in an element and then compute one or more shadows-all of which would have to blend together without overlapping the text itself-the lack of drop shadows in the specification is perhaps understandable.



The obvious default is to not have a drop shadow for text. Otherwise, it's theoretically possible to define one or more shadows. Each shadow is defined by a color and three length values. The color sets the shadow's color, of course, so it's possible to define green, purple, or even white shadows.

The first two length values determine the offset distance of the shadow from the text, and the optional third length value defines the "blur radius" for the shadow. To define a green shadow offset five pixels to the right and half an em down from the text, with no blurring, you would write:

text-shadow: green $5 \mathrm{px} 0.5 \mathrm{em}$;

Negative lengths cause the shadow to be offset to the left and upward from the original text.

The blur radius is defined as the distance from the shadow's outline to the edge of the blurring effect. A radius of two pixels would result in blurring that fills the space between the shadow's outline and the edge of the blurring. The exact blurring method is not defined, so different user agents might employ different effects. As an example, the following styles might be rendered something like Figure 6-31:



## Keep your eye on the shadows. They move when you aren't watching.

If run between the shadows $=$ some are phantoms, some are real

Slipping through the dark streets and the echoes and the shadows...

Slipping through the dark streets and the echoes and the shadows...

Figure 6-31. Dropping shadows all over



## Handling Whitespace

Now that we've covered a variety of ways to style the text, let's talk about the property white-space, which affects the user agent's handling of space, newline, and tab characters within the document source.

| white-space |  |
| :--- | :--- |
| Values: | normal \| nowrap | pre | pre-wrap | pre-line | inherit |
| Initial value: | normal |
| Applies to: | All elements (CSS2.1); block-level elements (CSS1 and CSS2) |
| Inherited: | No |
| Computed value: | As specified |

Using this property, you can affect how a browser treats the whitespace between words and lines of text. To a certain extent, default XHTML handling already does this: it collapses any whitespace down to a single space. So given the following markup, the rendering in a web browser would show only one space between each word and ignore the linefeed in the elements.

$$
\begin{array}{cc}
\langle p\rangle \text { This } & \text { paragraph has } \\
\text { spaces } & \text { in it. }\langle/ p\rangle
\end{array}
$$

You can explicitly set this default behavior with the following declaration:

$$
\text { p }\{\text { white-space: normal; }\}
$$

This rule tells the browser to do as browsers have always done: discard extra whitespace. Given this value, linefeed characters (carriage returns) are converted into spaces, and any sequence of more than one space in a row is converted to a single space.

Should you set white-space to pre, however, the whitespace in an affected element is treated as though the elements were XHTML pre elements; whitespace is not ignored, as shown in Figure 6-32:

$$
\begin{aligned}
& \text { p }\{\text { white-space: pre; }\} \\
& \text { <p>This paragraph has many } \\
& \quad \text { spaces } \quad \text { in it.</p> }
\end{aligned}
$$

This paragraph has many

spaces in it

Figure 6-32. Honoring the spaces in markup

With a white-space value of pre, the browser will pay attention to extra spaces and even carriage returns. In this respect, and in this respect alone, any element can be made to act like a pre element.

The opposite value is nowrap, which prevents text from wrapping within an element, except wherever you use a br element. Using nowrap in CSS is much like setting a table cell not to wrap in HTML 4 with <td nowrap>, except the white-space value can be applied to any element. The effects of the following markup are shown in Figure 6-33:

<p style="white-space: nowrap;">This paragraph is not allowed to wrap,

which means that the only way to end a line is to insert a line-break

element. If no such element is inserted, then the line will go forever,

forcing the user to scroll horizontally to read whatever can't be

initially displayed <br/>in the browser window.</p>

This paragraph is not allowed to wrap, which means that the only way to end a line is tc in the browser window.

Figure 6-33. Suppressing line wrapping with the white-space property

You can actually use white-space to replace the nowrap attribute on table cells:

td \{white-space: nowrap; \}

| | | | | | | | | | | | |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| The contents of this cell are not wrapped. | Neither are the contents of this cell. | Nor this one, or any after it, or any other cell in this table. | <img height="1" src="spacer.gif" width="10"/> | <img class="block" height="1" src="spacer.gif" width="10"/> | 1-2 | 1-3 | 1-4 | 2-1 | 2-2 | 2-3 | 2-4 |


| $1-1$ | $1-2$ | $1-3$ | $1-4$ |
| :--- | :--- | :--- | :--- |
| $2-1$ | $2-2$ | $2-3$ | $2-4$ |
| $3-1$ | $3-2$ | $3-3$ | $3-4$ |
| $4-1$ | $4-2$ | $4-3$ | $4-4$ |

Figure 11-11. Fixed-width table layout

As you can see in Figure 11-11, the first column is 200 pixels wide, which happens to be half the 400-pixel width of the table. The second column is 75 pixels wide because the first-row cell within that column has been assigned an explicit width. The third and fourth columns are each 61 pixels wide. Why? Because the sum of the column widths for the first and second columns (275px), plus the various borders between columns ( $3 \mathrm{px}$ ), equals 278 pixels. 400 minus 278 is 122, and 122 divided in half is 61 , so that's how many pixels wide the third and fourth columns will be. What about the 500-pixel width for \#r2c3? It's ignored because that cell isn't in the first row of the table.

Note that it is not absolutely necessary for the table to have an explicit width to make use of the fixed-width layout model, although it definitely helps. For example, given the following, a user agent could calculate a width for the table that is 50 pixels narrower than the parent element's width. It would then use that calculated width in the fixed-layout algorithm:

table \{table-layout: fixed; margin: 0 25px;

width: auto; $\}$

This is not required, however. User agents are also permitted to lay out any table with an auto value for width using the automatic-width layout model.

## Automatic layout

The automatic-layout model, while not as fast as fixed layout, is probably much more familiar to you because it's essentially the same model that HTML tables have used for years. In most current user agents, this model's use will be triggered by a table having a width of auto, regardless of the value of table-layout, although this is not assured.

The reason automatic layout is slower is that the table cannot be laid out until the user agent has looked at all of its content. That is, automatic layout requires that the user agent lay out the entire table each time it gets a new cell. This generally requires the user agent to perform some calculations and then go back through the table to perform a second set of calculations. The cells' content has to be fully examined because, as with HTML tables, the table's layout is dependent on it. If there is a 400 pixel-wide image in a cell in the last row, it will force all of the cells above it (those in the same column) to be 400 pixels wide. Thus, the width of every cell has to be calculated, and adjustments must be made (possibly triggering another round of content-width calculations) before the table can be laid out.

The details of the model can be expressed in the following steps:

1. For each cell in a column, calculate both the minimum and maximum cell width.

a. Determine the minimum width required to display the content. Keep in mind that the content can flow to any number of lines, but it may not stick out of the cell's box. If the cell has a width value that is larger than the minimum possible width, then the minimum cell width is set to the value of width. If the cell's width value is auto, then the minimum cell width is set to the minimum content width.

b. For the maximum width, determine the width required to display the content without any line breaking other than that forced explicitly (e.g., the <br> element). That value is the maximum cell width.

2. For each column, calculate both the minimum and maximum column width.

a. The column's minimum width is determined by the largest minimum cell width of the cells within the column. If the column has been given an explicit width value that is larger than any of the minimum cell widths within the column, then the minimum column width is set to the value of width.
b. For the maximum width, take the largest maximum cell width of the cells within the column. If the column has been given an explicit width value that is larger than any of the maximum cell widths within the column, then the maximum column width is set to the value of width. These two behaviors recreate the traditional HTML table behavior of forcibly expanding any column to be as wide as its widest cell.

3. In cases where a cell spans more than one column, the sum of the minimum column widths must be equal to the minimum cell width for the spanning cell. Similarly, the sum of the maximum column widths must equal the spanning cell's maximum width. User agents should divide any changes in column widths equally among the spanned columns.

In addition, the user agent must take into account that when a column width has a percentage value for its width, the percentage is calculated in relation to the width of the table - even though it doesn't yet know what that will be! Instead, it must store the percentage value and use it in the next part of the algorithm.

At this point, the user agent will have determined how wide or narrow each column can be. With that information in hand, it can then proceed to actually figuring out the width of the table. This happens as follows:

1. If the computed width of the table is not auto, the computed table width is compared to the sum of all the column widths plus any borders and cell spacing. (Columns with percentage widths are likely calculated at this time.) The larger of the two is the final width of the table. If the table's computed width is larger than the sum of the column widths, borders, and cell spacing, then all columns are increased in width by an equal amount until they fit into the table.
2. If the computed width of the table is auto, the final width of the table is determined by adding the column widths, borders, and cell spacing. This means that the table will be only as wide as needed to display its content, just as with traditional HTML tables. Any columns with percentage widths use that percentage as a constraint-but one that a user agent does not have to satisfy.

Once the last step is completed, then — and only then — can the user agent actually lay out the table.

The following styles and markup, presented in Figure 11-12, help illustrate how this process works:

table \{table-layout: auto; width: auto; border-collapse: collapse; $\}$

td $\{$ border: $1 \mathrm{px}$ solid; $\}$

col\#c3 $\{$ width: $25 \%$; $\}$

\#r1c2 \{width: $40 \%$;

\#r2c2 \{width: $50 \mathrm{px} ;\}$

\#r2c3 \{width: 35px; \}

\#r4c1 \{width: 100px; \}

\#r4c4 \{width: 1px;\}



| $1-1$ | $1-2$ | $1-3$ | $1-4$ |
| :--- | :--- | :--- | :--- |
| $2-1$ | $2-2$ | $2-3$ | $2-4$ |
| $3-1$ | $3-2$ | $3-3$ | $3-4$ |
| $4-1$ | $4-2$ | $4-3$ | $4-4$ |

Figure 11-12. Automatic table layout

Let's consider what happened for each of the columns, in turn:

- For the first column, the only explicit cell or column width is that of cell 4-1, which was given a width of $100 \mathrm{px}$. Because the content is so short, the minimum and maximum column width becomes 100px. (If there were a cell in the column with several sentences of text, it would have increased the maximum column width to whatever width was necessary to display all of the text without line breaking.)
- For the second column, two widths were declared: cell 1-2 was given a width of $40 \%$, and cell 2-2 was given a width of 50px. The minimum width of this column is 50px, and the maximum width is 40 percent of the final table width.
- For the third column, only cell 3-3 had an explicit width (35px), but the column itself was given a width of $25 \%$. Therefore, the minimum column width is $35 \mathrm{px}$, and the maximum width is 25 percent of the final table width.
- For the fourth column, only cell 4-4 was given an explicit width (1px). This is smaller than the minimum content width, so both the minimum and maximum column widths are equal to the minimum content width of the cells. This turns out to be a computed 25 pixels.

The user agent now knows that the four columns have minimum and maximum widths as follows:

1. $\min 100 \mathrm{px} / \max 100 \mathrm{px}$
2. $\min 50 \mathrm{px} / \max 40 \%$
3. $\min 35 \mathrm{px} / \max 25 \%$
4. $\min 25 \mathrm{px} / \max 25 \mathrm{px}$

Thus, the table's minimum width is the sum of all the column minima plus the borders, which totals 215 pixels. The table's maximum width is $130 \mathrm{px}+65$ percent, which works out to 371.42857143 pixels (given that 130px represents 35 percent of the overall table width). Let's assume this is, after rounding the fractional number to 371 pixels, the width value user agents will actually use. Thus, the second column will be 148 pixels wide, and the third column will be 93 pixels wide. User agents are not required to actually use the maximum value; they may choose another course of action.

Of course, this was (although it may not seem like it) a very simple and straightforward example: all of the content was basically the same width, and most of the declared widths were pixel lengths. In a situation where a table contains spacer GIFs, paragraphs of text, form elements, and so forth, the process of figuring out the table's layout will likely be a great deal lengthier.

## Height

After all of the effort expended in determining the width of the table, you might well wonder how much more complicated height calculation will be. Actually, in CSS terms, it's pretty simple, although browser developers probably don't think so.

The easiest situation to describe is one in which the height is explicitly set via the height property. In such cases, the height of the table is defined by the value of height. This means that a table may be taller or shorter than the sum of its row heights, although the 11 April 2006 draft of the CSS 2.1 specification states that height is treated as a minimum height for table boxes. In such cases, the CSS2.1 specification explicitly refuses to define what should happen, instead noting that the issue may be resolved in future versions of CSS. A user agent could expand or shrink a table's rows to match its height, or leave blank space inside the table's box, or something completely different. It's up to each user agent to decide.

If the height of the table is auto, its height is the sum of the heights of all the rows within the table, plus any borders and cell spacing. To determine the height of each row, the user agent goes through a process similar to that used to find the widths of columns. It calculates a minimum and maximum height for the contents of each cell and then uses these to derive a minimum and maximum height for the row. After doing this for all the rows, the user agent figures out what each row's height should
be, stacks them all, and uses that calculation to determine the table's height. It's a lot like inline layout, only with less certainty in how things should be done.

In addition to what to do about tables with explicit heights and how to treat row heights within them, you can add the following to the list of things CSS2.1 does not define:

- The effect of a percentage height for table cells
- The effect of a percentage height for table rows and row groups
- How a row-spanning cell affects the heights of the rows that are spanned, except that the rows must contain the spanning cell

As you can see, height calculations in tables are largely left to user agents to determine. Historical evidence suggests that each user agent will likely do something different, so you should probably avoid setting heights as much as possible.

## Alignment

In a rather interesting turn of events, alignment of content within cells is much better defined than cell and row heights. This is true even for vertical alignment, which could quite easily affect the height of a row.

Horizontal alignment is the simplest. To align content within a cell, you use the text-align property. In effect, the cell is treated as a block-level box and all of the content within it is aligned as per the text-align value. (For details on text-align, see Chapter 6.)

To vertically align content in a table cell, vertical-align is the relevant property. It uses many of the same values that are used for vertically aligning inline content, but the meanings of those values change when applied to a table cell. To summarize the three simplest cases:

top

The top of the cell's content is aligned with the top of its row; in the case of rowspanning cells, the top of the cell's content is aligned with the top of the first row it spans.

bottom

The bottom of the cell's content is aligned with the bottom of its row; in the case of row-spanning cells, the bottom of the cell's content is aligned with the bottom of the last row it spans.

middle

The middle of the cell's content is aligned with the middle of its row; in the case of row-spanning cells, the middle of the cell's content is aligned with the middle of all the rows it spans.

These are illustrated in Figure 11-13, which uses the following styles and markup:

table \{table-layout: auto; width: 20em; border-collapse: separate; border-spacing: $3 \mathrm{px} ;\}$

td \{border: 1px solid; background: silver; padding: $0 ;\}$

div \{border: $1 \mathrm{px}$ dashed gray; background: white; \}

\#r1c1 \{vertical-align: top; height: 10em; \}

\#r1c2 \{vertical-align: middle; $\}$

\#r1c3 \{vertical-align: bottom; $\}$

| |
| :--- |
| <br><div><br><br>The contents of this cell are bottom-aligned.<br><br></div><br><br>$\langle/$ td $\rangle$<br><br>$<!--$ tr $-->$<br><br> |




Figure 11-13. Vertical alignment of cell contents

In each case, the alignment is carried out by automatically increasing the padding of the cell itself to achieve the desired effect. In the first cell in Figure 11-13, the bottom padding of the cell has been changed to equal the difference between the height of the cell's box and the height of the content within the cell. For the second cell, the top and bottom padding of the cell have been reset to be equal, thus vertically centering the content of the cell. In the last cell, the cell's top padding has been altered.

The fourth possible value alignment is baseline, and it's a little more complicated than the first three:

baseline

The baseline of the cell is aligned with the baseline of its row; in the case of rowspanning cells, the baseline of the cell is aligned with the baseline of the first row it spans.

It's easiest to provide an illustration (see Figure 11-14) and then discuss what's happening.



Figure 11-14. Baseline alignment of cell contents

A row's baseline is defined by the lowest initial cell baseline (that is, the baseline of the first line of text) out of all of its cells. Thus, in Figure 11-14, the row's baseline was defined by the third cell, which has the lowest initial baseline. The first two cells then have a baseline of their first line of text aligned with the row's baseline.

As with top, middle, and bottom alignment, baseline-aligned cell content is placed by altering the top and bottom padding of the cells. In cases where none of the cells in a row are baseline-aligned, the row does not even have a baseline-it doesn't really need one.

The detailed process for aligning cell contents within a row is as follows:

1. If any of the cells is baseline-aligned, the row's baseline is determined and the content of the baseline-aligned cells is placed.
2. Any top-aligned cell has its content placed. The row now has a provisional height, which is defined by the lowest cell bottom of the cells that have already had their content placed.
3. If any remaining cells are middle- or bottom-aligned, and the content height is taller than the provisional row height, the height of the row is increased to enclose the tallest of those cells.
4. All remaining cells have their content placed. In any cell whose contents are shorter than the row height, the cell's padding is increased to match the height of the row.

The vertical-align values sub, super, text-top, and text-bottom are ignored when applied to table cells. Thus, the following rule would have the same result as that shown in Figure 11-14:

th $\{$ vertical-align: text-top; $\}$

## Summary

Even if you're quite familiar with table layout from years of table-and-spacer design, the mechanisms driving such layout are rather complicated and not at all deterministic. Due to the legacy of HTML table construction, the CSS table model is row-centric, but it does, thankfully, accommodate columns and limited column styling. Thanks to new features that affect cell alignment and table width, you now have even more tools for presenting tables in a pleasing way.

The ability to apply table-related display values to arbitrary elements opens the door to creating table-like layouts using HTML elements such as div, or in XML languages where any element could be used to describe layout components. As of this writing, most browsers other than Internet Explorer support the application of table-related display values to arbitrary elements. Even in its current form, CSS makes presentation more sophisticated, as does the subject of the next chapter: generated content.

## CHAPTER 12

## Lists and Generated Content

In the realm of CSS layout, lists are an interesting case. The items in a list are simply block boxes, but with an extra bit that doesn't really participate in the document layout hanging off to one side. With an ordered list, that extra bit contains a series of increasing numbers (or letters) that are calculated and mostly formatted by the user agent, not the author. Taking a cue from the document structure, the user agent generates the numbers and their basic presentation.

None of this content generation could be described in CSS1 terms-and, therefore, it couldn't be controlled-but CSS2 introduced features that allow list-item numbering to be described. As a result, CSS now lets you, the author, define your own counting patterns and formats, and associate those counters with any element, not just ordered list items. Furthermore, this basic mechanism makes it possible to insert other kinds of content, including text strings, attribute values, or even external resources into a document. Thus, it becomes possible to use CSS to insert link icons, editorial symbols, and more into a design without having to create extra markup.

To see how all these list options fit together, we'll explore basic list styling before moving on to examine the generation of content and counters.

## Lists

In a sense, almost anything that isn't narrative text can be considered a list. The U.S. Census, the solar system, my family tree, a restaurant menu, and even all of the friends you've ever had can be represented as a list, or perhaps as a list of lists. These many variations make lists fairly important, which is why it's a shame that list styling in CSS isn't more sophisticated.

The simplest (and best-supported) way to affect a list's styles is to change its marker type. The marker of a list item is, for example, the bullet that appears next to each item in an unordered list. In an ordered list, the marker could be a letter, number, or a symbol from some other counting system. You can even replace the markers with images. All of these are accomplished using the different list-style properties.

## Types of Lists

To change the type of marker used for a list's items, use the property list-style-type.



That's quite a few keywords, I know; many of them were introduced in CSS2 but were then dropped in CSS2.1. Table 12-1 lists the keywords that exist in CSS2.1.

Table 12-1. Keywords of the list-style-type property in CSS2.1

| Keyword | Effect |
| :--- | :--- |
| disc | Uses a disc (usually a filled circle) for list-item markers |
| circle | Uses a circle (usually open) for markers |
| square | Uses a square (filled or open) for markers |
| decimal | $1,2,3,4,5, \ldots$ |
| decimal-leading-zero | $01,02,03,04,05, \ldots$ |
| upper-alpha <br> upper-latin | $\mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D}, \mathrm{E}, \ldots$ |
| lower-alpha <br> lower-latin | $\mathrm{a}, \mathrm{b}, \mathrm{c}, \mathrm{d}, \mathrm{e}, \ldots$ |
| upper-roman | $\mathrm{I}, \mathrm{Il}, \mathrm{III}, \mathrm{IV}, \mathrm{V}, \ldots$ |
| lower-roman | $\mathrm{i}, \mathrm{ii}, \mathrm{iii}, \mathrm{iv}, \mathrm{v}, \ldots$ |
| lower-greek | Lowercase classical Greek symbols |
| armenian | Traditional Armenian numbering |
| georgian | Traditional Georgian numbering |
| none | Uses no marker |

Table 12-2 lists those keywords that were introduced in CSS2 but that do not appear in CSS2.1.

Table 12-2. Keywords of the list-style-type property in CSS2

| Keyword | Effect |
| :--- | :--- |
| hebrew | Traditional Hebrew numbering |
| cjk-ideographic | Ideographic numbering |
| katakana | Japanese numbering $(\mathrm{A}, \mathrm{I}, \mathrm{U}, \mathrm{E}, \mathrm{O} \ldots)$ |
| katakana-iroha | Japanese numbering $(\mathrm{I}, \mathrm{RO}, \mathrm{HA}, \mathrm{NI}, \mathrm{HO} \ldots)$ |
| hiragana | Japanese numbering $(\mathrm{a}, \mathrm{i}, \mathrm{u}, \mathrm{e}, \mathrm{o} \ldots)$ |
| hiragana-iroha | Japanese numbering $(\mathrm{i}, \mathrm{ro}, \mathrm{ha}, \mathrm{ni}, \mathrm{ho} \ldots)$ |

A user agent should treat any value it does not recognize as decimal.

The list-style-type property, as well as all other list-related properties, can be applied only to an element that has a display of list-item, but CSS doesn't distinguish between ordered and unordered list items. Thus, you might be able to set an ordered list to use discs instead of numbers. In fact, the default value of list-styletype is disc, so you might theorize that without explicit declarations to the contrary, all lists (ordered or unordered) will use discs as the marker for each item. This would be logical, but, as it turns out, it's up to the user agent to decide. Even if the user agent doesn't have a predefined rule such as ol \{list-style-type: decimal; \}, it may prohibit ordered markers from being applied to unordered lists, and vice versa. You can't count on this, so be careful.

For the CSS2 values such as hebrew and georgian, the CSS2 specification doesn't state exactly how these counting systems work, nor how user agents should deal with them. This uncertainty resulted in a lack of widespread implementation, which is why the values in Table 12-2 do not appear in CSS2.1.

If you want to suppress the display of markers altogether, then none is the value you should use. none causes the user agent to refrain from putting anything where the marker would ordinarily be, although it does not interrupt the counting in ordered lists. Thus, the following markup would have the result shown in Figure 12-1:



list-style-type is inherited, so if you want to have different styles of markers in nested lists, you'll likely need to define them individually. You may also have to

| 1. Item the first |
| :--- | :--- |
| Item the second |
| 3. Item the third |
| Item the fourth |
| 5. Item the fifth |

Figure 12-1. Switching off list-item markers

explicitly declare styles for nested lists because the user agent's style sheet may have already defined them. For example, assume that a user agent has the following styles defined:

ul \{list-style-type: disc; \}

ul ul \{list-style-type: circle; \}

ul ul ul \{list-style-type: square; \}

If this is the case (and it's likely that it will be), you will have to declare your own styles to overcome the user agent's styles-inheritance won't be enough.

## List Item Images

Sometimes, a regular marker just won't do. You might prefer to use an image for each marker, which is possible with the property list-style-image.



Here's how it works:

ul li \{list-style-image: url(ohio.gif); \}

Yes, it's really that simple. One simple url( ) value, and you're putting images in for markers, as you can see in Figure 12-2.

| Item the first |
| :--- |
| Item the second |
| Item the third |
| Item the fourth |

Figure 12-2. Using images as markers

Of course, you should exercise care in the images you use, as the example shown in Figure 12-3 makes painfully clear:

ul li \{list-style-image: url(big-ohio.gif); \}



Figure 12-3. Using really big images as markers

It's generally a good idea to provide a fallback marker type in case your image doesn't load, gets corrupted, or is in a format that some user agents can't display. Do this by defining a backup list-style-type for the list:

ul li \{list-style-image: url(ohio.png); list-style-type: square;\}

The other thing you can do with list-style-image is set it to the default value of none. This is good practice because list-style-image is inherited, so any nested lists will pick up the image as the marker, unless you prevent that from happening:

ul \{list-style-image: url(ohio.gif); list-style-type: square;\}

ul ul \{list-style-image: none; \}

Since the nested list inherits the item type square but has been set to use no image for its markers, squares are used for the markers in the nested list, as shown in Figure 12-4.

Item the first
Item the second
Item the third
a Subitem one

- Subitem two
- Subitem three
Item the fourth

Figure 12-4. Switching off image markers in sublists

Remember that this scenario might not occur in the real world: a user agent may have already defined a list-style-type for ul ul, so the value of square won't be inherited after all. Your browser may vary.

## List-Marker Positions

There is one other thing you can do to influence the appearance of list items under CSS2.1: decide whether the marker appears outside or inside the content of the list item. This is accomplished with list-style-position.



If a marker's position is set to outside (the default), it will appear the way list items always have on the Web. Should you desire a slightly different appearance, though, you can pull the marker in toward the content by setting the value to inside. This causes the marker to be placed "inside" the list item's content. The exact way this happens is undefined, but Figure 12-5 shows one possibility:

li.first \{list-style-position: inside; \}

li.second \{list-style-position: outside; \}

- Item the first; the list marker for this list item is inside the content of the list item.
- Item the second; the list marker for this list item is outside the content of the list item (which is the traditional Web rendering).

Figure 12-5. Placing the markers inside and outside list items

## List Styles in Shorthand

For brevity's sake, you can combine the three list-style properties into a convenient single property: list-style.

| list-style |  |
| :--- | :--- |
| Values: | $[$ <list-style-type> $\\|$ <ist-style-image> $\\|$ <list-style-position> ] \| |
|  | inherit |
| Initial value: | Refer to individual properties |
| Applies to: | Elements whose display value is list-item |
| Inherited: | Yes |
| Computed value: | See individual properties |

For example:

li \{list-style: url(ohio.gif) square inside; \}

As you can see in Figure 12-6, all three values are applied to the list items.

Item the first; the list marker
for this list item is inside the
content of the list item.
Item the second; the list
marker for this list item is also
inside the content of the list item.

Figure 12-6. Bringing it all together

The values for list-style can be listed in any order, and any of them can be omitted. As long as one is present, the rest will fill in their default values. For instance, the following two rules will have the same visual effect:

li.norm \{list-style: url(img42.gif);\}

li.odd \{list-style: url(img42.gif) disc outside; \} /* the same thing */

They will also override any previous rules in the same way. For example:

li \{list-style-type: square; \}

li.norm \{list-style: url(img42.gif); \}

li.odd \{list-style: url(img42.gif) disc outside; \} /* the same thing */

The result will be the same as that in Figure 12-6 because the implied list-styletype value of disc for the rule li.norm will override the previous declared value of square, just as the explicit value of disc overrides it in rule li.odd.

## List Layout

Now that we've looked at the basics of styling list markers, let's consider how lists are laid out in various browsers. We'll start with a set of three list items devoid of any markers and not yet placed within a list, as shown in Figure 12-7.

Item the first

Item the second

Item the third

Figure 12-7. Three list items

The border around the list items shows them to be, essentially, like a block-level element. Indeed, the value list-item is defined to generate a block box. Now let's add markers, as illustrated in Figure 12-8.

- Item the first
- Item the second
- Item the third

Figure 12-8. Markers are added

The distance between the marker and the list item's content is not defined by CSS, and CSS2.1 does not provide a way to affect that distance. Interestingly, CSS2 does, which is a subject briefly covered in the sidebar "List-Marker Positioning."

With the markers outside the list items' content, they don't affect the layout of other elements, nor do they really even affect the layout of the list items themselves. They just hang a certain distance from the edge of the content, and wherever the content edge goes, the marker will follow. The behavior of the marker works much as though the marker were absolutely positioned in relation to the list-item content, something like position: absolute; left: $-1.5 \mathrm{em}$;. When the marker is inside, it acts like an inline element at the beginning of the content.

So far, you have yet to add an actual list container; in other words, there is neither a ul nor an ol element represented in the figures. You can add one to the mix, as shown in Figure 12-9 (it's represented by a dashed border).



Figure 12-9. Adding a list element

Like the list items, the list element is a block box, one that encompasses its descendant elements. As you can see, however, the markers are not only placed outside the list item contents, but also outside the content area of the list element. The usual "indentation" you expect from lists has not yet been specified.

Most browsers, as of this writing, indent list items by setting either padding or margins for the containing list element. For example, the user agent might apply a rule such as:

ul, ol \{margin-left: 40px; \}

This is the rule employed by Internet Explorer and Opera (see Figure 12-9). Most Gecko-based browsers, on the other hand, use a rule like this:

ul, ol \{padding-left: 40px; \}

Neither is incorrect, but the discrepancy can lead to problems if you want to eliminate the indentation of the list items. Figure 12-10 shows the difference between the two approaches.

| - ITtem the first |
| :--- |
| - TItem the second |
| - ITtem the third |
| - Item the first |
| - Item the second |
| - Item the third |

Figure 12-10. Margins and padding as indentation devices



The distance of 40px is a relic of early web browsers, which indented lists by a pixel amount. A better value would be something like 2.5em, since this scales the indentation along with changes in the text size.

For authors who want to change the indentation distance of lists, I strongly recommend that you specify both padding and margins to ensure cross-browser compatibility. For example, if you want to use padding to indent a list, use this rule:

ul \{margin-left: 0; padding-left: 1em; \}

If you prefer margins, write something like this instead:

ul \{margin-left: 1em; padding-left: 0 ; \}

In either case, remember that the markers will be placed relative to the contents of the list items, and may therefore "hang" outside the main text of a document, or even beyond the edge of the browser window.

## Generated Content

CSS2 and CSS2.1 include a new feature called generated content. This is content created by the browser but not represented either by markup or content.

For example, list markers are generated content. There is nothing in the markup of a list item that directly represents the markers, and you, the author, do not have to write the markers into your document's content. The browser simply generates the appropriate marker automatically. For unordered lists, the marker is a bullet of some kind, such as a circle, disc, or square. In ordered lists, the marker is a counter that increments by one for each successive list item.

## List-Marker Positioning

One feature many authors request is the ability to control the space between a marker and the content of a list item. CSS2 defined ways to do this, including a property called marker-offset and a display value of marker. Implementation experience revealed this to be a clumsy approach, and these features were removed in CSS2.1

As of this writing, the current working draft of the CSS3 Lists module defines a new and more compact way to affect marker placement, which is the ::marker pseudo-element. Assuming that the module does not change before becoming a full Recommendation, you may someday be able to write rules such as li::marker $\{$ margin-right: $0.125 \mathrm{~m} ;\}$ in order to get markers snugly against the content of list items without actually bringing them inside.

To understand how you can affect list markers and customize the counting of ordered lists (or anything else!), you must first look at more basic generated content.



As of this writing, no version of Internet Explorer supports generated content.

## Inserting Generated Content

To insert generated content into the document, use the :before and : after pseudoelements. These place generated content before or after the content of an element by way of the content property (described in the next section).

For example, you might want to precede every hyperlink with the text "(link)" to mark them for printing. This is accomplished with a rule like the following, which has the effect shown in Figure 12-11:

a[href]:before \{content: "(link)"; \}

(link)Jeffrey seems to be (link)very happy about (link)something, although I can't quite work out whether his happiness is over (link)OS X, (link)Chimera, the ability to run the Dock and (link)DragThing at the same time, the latter half of my (link)journal entry from yesterday, or (link)something else entirely.

Figure 12-11. Generating text content

Note that there isn't a space between the generated content and the element content. This is because the value of content in the previous example doesn't include a space. You could modify the declaration as follows to make sure there's a space between generated and actual content:

$$
\text { a[href]:before }\{\text { content: "(link) "; }\}
$$

It's a small difference but an important one.

In a similar manner, you might choose to insert a small icon at the end of links to PDF documents. The rule to accomplish this would look something like:

a.pdf-doc:after \{content: url(pdf-doc-icon.gif);\}

Suppose you want to further style such links by placing a border around them. This is done with a second rule:

a.pdf-doc \{border: 1px solid gray; \}

The result of these two rules is illustrated in Figure 12-12.


#### Abstract

Jeffrey seems to be very happy about something, although I can't quite work out whether his happiness is over OS X, Chimera, the ability to run the Dock and DragThing at the same time, the latter half of my journal entry from yesterday, or something else entirely


Figure 12-12. Generating icons

Notice how the link border extends around the generated content, just as the link underline extended under the "(link)" text in Figure 12-11. This happens because generated content is placed inside the element box of the element. As of CSS2.1, there isn't a way to place generated content outside the element box, other than list markers.

You might think that positioning would do the trick, except CSS2 and CSS2.1 specifically prohibit the floating or positioning of :before and : after content. List-style properties, along with table properties, are similarly prohibited. In addition, the following restrictions apply:

- If the subject of a :before or : after selector is a block-level element, then the property display can accept only the values none, inline, block, and marker. Any other value is treated as block.
- If the subject of a :before or : after selector is an inline-level element, then the property display can accept only the values none and inline. Any other value is treated as inline.

For example, consider:

em:after \{content: " (!) "; display: block; \}

Since em is an inline element, the generated content cannot be made block-level. The value block is therefore reset to inline. In this next example, however, the generated content is made block-level because the target element is also block-level:

h1:before \{content: "New Section"; display: block; color: gray;\}

The result is illustrated in Figure 12-13.

## New Section The Secret Life of Salmon

Figure 12-13. Generating block-level content

One interesting aspect of generated content is that it inherits values from the element to which it's been attached. Thus, given the following rules, the generated text will be green, the same as the content of the paragraphs:



If you want the generated text to be purple instead, a simple declaration will suffice:

p:before \{content: "::: "; color: purple;\}

Such value inheritance happens only with inherited properties, of course. This is worth noting because it influences how certain effects must be approached. Consider:



Since the generated content is placed inside the element box of the h1, it will be placed under the top border of the element. It would also be placed within any padding, as shown in Figure 12-14.

## New Section

## The Secret Life of Salmon

Figure 12-14. Taking placement into account

The bottom margin of the generated content, which has been made block-level, pushes the actual content of the element downward by half an em. In every sense, the effect of the generated content in this example is to break up the h1 element into two pieces: the generated-content box and the actual content box. This happens because the generated content has display: block. If you were to change it to display: inline, the effect would be as shown in Figure 12-15:

h1 \{border-top: 3px solid black; padding-top: 0.25em; \}

h1:before \{content: "New Section"; display: inline; color: gray;

border-bottom: 1 px dotted black; margin-bottom: $0.5 \mathrm{em} ;\}$

## New SectionThe Secret Life of Salmon

Figure 12-15. Changing the generated content to be inline

Note how the borders are placed and how the top padding is still honored. So is the bottom margin on the generated content, but since the generated content is now inline and margins don't affect line height, the margin has no visible effect.

With the basics of generating content established, let's take a closer look at the way the actual generated content is specified.

## Specifying Content

If you're going to generate content, you need a way to describe the content to be generated. As you've already seen, this is handled with the content property, but there's a great deal more to this property than you've seen thus far.



You've already seen string and URI values in action, and counters will be covered later in this chapter. Let's talk about strings and URIs in a little more detail before we take a look at the attr( ) and quote values.

String values are presented literally, even if they contain what would otherwise be markup of some kind. Therefore, the following rule would be inserted verbatim into the document, as shown in Figure 12-16:

h2:before \{content: "<em>\¶</em>"; color: gray;\}

## <em>\¶</em> Spawning

Figure 12-16. Strings are displayed verbatim

This means that if you want a newline (return) as part of your generated content, you can't use <br>. Instead, you use the string $\backslash \mathrm{A}$, which is the CSS way of representing a newline (based on the Unicode linefeed character, which is hexadecimal position A). Conversely, if you have a long string value and need to break it up over multiple lines, you escape out the linefeeds with the $\backslash$ character. These are both demonstrated by the following rule and illustrated in Figure 12-17:

h2:before \{content: "We insert this text before all H2 elements because 1

it is a good idea to show how these things work. It may be a bit long $\backslash$ but the point should be clearly made. "; color: gray; \}

## We insert this text before all $\mathrm{H} 2$ elements because it is a good idea to show how these things work. It may be a bit long but the point should be clearly made. Spawning

Figure 12-17. Inserting and suppressing newlines

You can also use escapes to refer to hexadecimal Unicode values, such as \ooAB.



As of this writing, support for inserting escaped content such as $\backslash A$ and $\backslash$ IOOAB is not very widespread, even among those browsers that support some generated content.

With URI values, you simply point to an external resource (an image, movie, sound clip, or anything else the user agent supports), which is then inserted into the document in the appropriate place. If the user agent can't support the resource you point it to for any reason-say, you try to insert an SVG image into a browser that doesn't understand SVG, or try to insert a movie into a document when it's being printedthen the user agent is required to ignore the resource completely, and nothing will be inserted.

## Inserting attribute values

There are situations where you might want to take the value of an element's attribute and make it a part of the document display. To pick a simple example, you can place the value of every link's href attribute immediately after the links, like this:

$$
a[\text { href }]: \text { after }\{\text { content: } \operatorname{attr}(\text { href); }\}
$$

Again, this leads to the problem of the generated content running smack into the actual content. To solve this, add some string values to the declaration, with the result shown in Figure 12-18:

$$
\text { a[href]:after }\{\text { content: " [" attr(href) "]";\} }
$$

Jeffrey [http://www.zeldman.com/] seems to be very happy [http://www.zeldman.com/daily/1202b.shtml\#joy] about something [http://www.zeldman.com//accessories/worthit.jpg], although I can't quite work out whether his happiness is over OS X [http://www.apple.com/macosx]], Chimera [http://chimera.mozdev.org/], the ability to run the Dock and DragThing [http://www.dragthing.com/] at the same time, the latter half of my journal entry from yesterday [http://www.meyerweb.com/eric/thoughts/2002b.htmi\#t20021227], or something else entirely [http://www.roguelibrarian.com/].

Figure 12-18. Inserting URLs

This can be useful for print style sheets, as an example. Any attribute value can be inserted as generated content: alt text, class or id values-anything. An author might choose to make the citation information explicit for a block quote, like this:



For that matter, a more complicated rule might reveal the text- and link-color values for a legacy document:



Note that if an attribute doesn't exist, an empty string is put in its place. This is what happens in Figure 12-19, in which the previous example is applied to a document whose body element has no alink attribute.



Figure 12-19. Missing attributes are skipped

The text "Active: " (including the trailing space) is inserted into the document, as you can see, but there is nothing following it. This is convenient in situations where you want to insert the value of an attribute only when it exists.



CSS2.x defines the returned value of an attribute reference as an unparsed string. Therefore, if the value of an attribute contains markup or character entities, they will be displayed verbatim.

## Generated quotes

A specialized form of generated content is the quotation mark, and CSS2.x provides a powerful way to manage both quotes and their nesting behavior. This is possible due to the pairing of content values like open-quote and the property quotes.

|  | quotes |
| :--- | :--- |
| Values: | $[<$ string $><$ string $>]+\mid$ none $\mid$ inherit |
| Initial value: | User agent-dependent |
| Applies to: | All elements |
| Inherited: | Yes |
| Computed value: | As specified |

Upon studying the value syntax, we find that other than the keywords none and inherit, the only valid value is one or more pairs of strings. The first string of the pair defines the open-quote symbol, and the second defines the close-quote symbol. Therefore, of the following two declarations, only the first is valid:

quotes: '"' "'"; /* valid */

quotes: '"'; /* NOT VALID */

The first rule also illustrates one way to put string quotes around the strings themselves. The double quotation marks are surrounded by single quotation marks, and vice versa.

Let's look at a simple example. Suppose you're creating an XML format to store a list of favorite quotations. Here's one entry in the list:

<quotation>

<quote>I hate quotations.</quote>

<quotee>Ralph Waldo Emerson</quotee>

</quotation>

To present the data in a useful way, you could employ the following rules, with the result shown in Figure 12-20:



## "I hate quotations." (Ralph Waldo Emerson)

Figure 12-20. Inserting quotes and other content

The values open-quote and close-quote are used to insert whatever quoting symbols are appropriate (since different languages have different quotation marks). They use the value of quotes to determine how they should work. Thus, the quotation begins and ends with a double quotation mark.

If you want to use "curly quotes" instead of the plain vertical-line quotation marks, as is common in most print media, the quote rule would read:

quote \{quotes: '\201C' '\201D';\}

This uses the hexadecimal Unicode positions for the "curly quote" symbols and, if applied to the previous quotation, would surround Emerson's quote with curly quotes instead of the straight quotes in Figure 12-20.

With quotes, you can define quotation patterns to as many nesting levels as you like. In English, for example, a common practice is to start out with a double quotation mark, and a quotation nested inside the first one gets single quotation marks. This can be recreated with "curly" quotation marks using the following rules:

quotation: display: block;\}

quote \{quotes: '\201C' '\2010' ' 22018 ' '\2019';\}

quote:before, q:before\{content: open-quote; \}

quote:after, q:after \{content: close-quote; \}

When applied to the following markup, these rules will have the effect shown in Figure 12-21:

<quotation>

<quote> In the beginning, there was nothing. And God said: <q>Let there be light!</q> And there was still nothing, but you could see it.</quote> </quotation>

"In the beginning, there was nothing. And God said: 'Let there be light!' And there was still nothing, but you could see it."

Figure 12-21. Nested curly quotes

In a case where the nested level of quotation marks is greater than the number of defined pairs, the last pair is reused for the deeper levels. Thus, if you had applied the following rule to the markup shown in Figure 12-21, the inner quote would have had double quotation marks, the same as the outer quote:

quote \{quotes: '\201C' '\201D';\}

Generated quotes make possible one other common typographic effect. In situations where there are several paragraphs of quoted text, the close-quote of each paragraph is often omitted; only the opening quote marks are shown, with the exception of the last paragraph. This can be recreated using the no-close-quote value:

blockquote \{quotes: '"' '"' "''" "'" '"' '"'';

blockquote p:before \{content: open-quote;\}

blockquote p:after \{content: no-close-quote; \}

This will start each paragraph with a double quotation mark but no closing mark. This is true of the last paragraph as well, so if you need to add a closing quote mark, you'd need to class the final paragraph and declare a close-quote for its : after content.

This value is important because it decrements the quotation nesting level without actually generating a symbol. This is why each paragraph starts with a double quotation mark, instead of alternating between double and single marks until the third paragraph is reached. no-close-quote closes the quotation nesting at the end of each paragraph, and thus every paragraph starts at the same nesting level.

This is significant because, as the CSS2.1 specification notes, "Quoting depth is independent of the nesting of the source document or the formatting structure." In other words, when you start a quotation level, it persists across elements until a closequote is encountered, and the quote nesting level is decremented.

For the sake of completeness, there is a no-open-quote keyword, which has a symmetrical effect to no-close-quote. This keyword increments the quotation nesting level by one but does not generate a symbol.

## Counters

We're all familiar with counters; for example, the markers of the list items in ordered lists are counters. In CSS1, there was no way to affect them, largely because there was no need: HTML defined its own counting behaviors for ordered lists, and that was that. With the rise of XML, it's now important to provide a method by which counters can be defined. CSS2 was not content to simply provide for the kind of simple counting found in HTML, however. Two properties and two content values make it possible to define almost any counting format, including subsection counters employing multiple styles, such as "VII.2.c."

## Resetting and incrementing

The basis of creating counters is the ability to set both the starting point for a counter and to increment it by some amount. The former is handled by the property counter-reset.

## counter-reset

Values: $\quad[<$ identifier> <integer>? ]+ $\mid$ none $\mid$ inherit

Initial value: User agent-dependent

Applies to: All elements

Inherited: No

Computed value: As specified

A counter identifier is simply a label created by the author. For example, you might name your subsection counter subsection, subsec, ss, or bob. The simple act of resetting (or incrementing) an identifier is sufficient to call it into being. In the following rule, the counter chapter is defined as it is reset:

h1 \{counter-reset: chapter; \}

By default, a counter is reset to zero. If you want to reset to a different number, you can declare the number following the identifier:

h1\#ch4 \{counter-reset: chapter 4; \}

You can also reset multiple identifiers all at once in identifier-integer pairs. If you leave out an integer, then it defaults to zero:

h1 \{counter-reset: chapter 4 section -1 subsec figure $1 ;\}$ /* 'subsec' is reset to 0 */

As you can see from the previous example, negative values are permitted. It would be perfectly legal to set a counter to -32768 and count up from there.



CSS does not define what user agents should do with negative counter values in nonnumeric counting styles. For example, there is no defined behavior for what to do if a counter's value is -5 but its display style is upper-alpha.

To count up, you'll need a property to indicate that an element increments a counter. Otherwise, the counter would remain at whatever value it was given with a counterreset declaration. The property in question is, not surprisingly, counter-increment.



Like counter-reset, counter-increment accepts identifier-integer pairs, and the integer portion of these pairs can be zero or negative as well as positive. The difference is that if an integer is omitted from a pair in counter-increment, it defaults to 1 , not 0 .

As an example, here's how a user agent might define counters to recreate the traditional 1, 2, 3 counting of ordered lists:

ol \{counter-reset: ordered;\} /* defaults to 0 */

ol li counter-increment: ordered; \} /* defaults to 1 */

On the other hand, an author might want to count backward from zero so that the list items use a rising negative system. This would require only a small edit:

ol \{counter-reset: ordered; \} /* defaults to 0 */

ol li \{counter-increment: ordered -1 ; \}

The counting of lists would then be $-1,-2,-3$ and so on. If you replaced the integer -1 with -2 , then lists would count $-2,-4,-6$ and so on.

# Using counters 

To actually display the counters, though, you need to use the content property in conjunction with one of the counter-related values. To see how this works, let's use an XML-based ordered list like this:



By applying the following rules to XML employing this structure, you would get the result shown in Figure 12-22:

list[type="ordered"] \{counter-reset: ordered;\} /* defaults to 0 */

list[type="ordered"] item \{display: block; \}

list[type="ordered"] item:before \{counter-increment: ordered;

content: counter(ordered) ". "; margin: $0.25 \mathrm{em} \mathrm{0; \}}$

\author{

1. First item <br> 2. Item two <br> 3. The third item
}

Figure 12-22. Counting the items

Note that the generated content is, as usual, placed as inline content at the beginning of the associated element. Thus, the effect is similar to an HTML list with liststyle-position: inside; declared.

Note also that the item elements are ordinary elements generating block-level boxes, which means that counters are not restricted only to elements with a display of listitem. In fact, any element can make use of a counter. Consider the following rules:



These rules would have the effect shown in Figure 12-23.

## 1. The Secret Life of Salmon

### 1.1. Introduction

### 1.2. Habitats

### 1.2.1. Ocean

### 1.2.2. Rivers

### 1.3. Spawning

### 1.3.1. Fertilization

### 1.3.2. Gestation

### 1.3.3. Hatching

Figure 12-23. Adding counters to headings

Figure 12-23 illustrates some important points about counter resetting and incrementing. Notice how the h1 element uses the counter chapter, which defaults to zero and has a "1." before the element's text. When a counter is incremented and used by the same element, the incrementation happens before the counter is displayed. In a similar way, if a counter is reset and shown in the same element, the reset happens before the counter is displayed. Consider:



The first h1 element in the document would be preceded by the text "1.0.0." because the counters section and subsec were reset, but not incremented. This means that if you want the first displayed instance of an incremented counter to be 0 , then you need to reset that counter to -1 , as follows:

body \{counter-reset: chapter $-1 ;\}$

h1:before \{counter-increment: chapter; content: counter(chapter) ". "; \}

You can do some interesting things with counters. Consider the following XML:

<code type="BASIC">

<line>PRINT "Hello world!"</line>

<line>REM This is what the kids are calling a "comment"</line>

<line>GOTO 10</line>

</code>

You can recreate the traditional format of a BASIC program listing with the following rules:



It's also possible to define a list style for each counter as part of the counter( ) format. You can do this by adding a comma-separated list-style-type keyword after the counter's identifier. The following modification of the heading-counter example is illustrated in Figure 12-24:

h1:before \{counter-reset: section subsec;

counter-increment: chapter;

content: counter(chapter, upper-alpha) ". ";\}

h2:before \{counter-reset: subsec;

counter-increment: section;

content: counter(chapter,upper-alpha)"." counter(section) ". "; \}

h3:before \{counter-increment: subsec;

content: counter(chapter,upper-alpha) "." counter(section) "."

counter(subsec, lower-roman) ". "; \}

## A. The Secret Life of Salmon

## A.1. Introduction

A.2. Habitats

## A.2.i. Ocean

A.2.ii. Rivers

## A.3. Spawning

## A.3.i. Fertilization

## A.3.ii. Gestation

A.3.iii. Hatching

Figure 12-24. Changing counter styles

Notice that the counter section was not given a style keyword, so it defaulted to the decimal counting style. You can even set counters to use the styles disc, circle, square, and none if you so desire.

One interesting point to note is that elements with a display of none do not increment counters, even if the rule seems to indicate otherwise. In contrast, elements with a visibility of hidden do increment counters:



## Counters and scope

So far, we've seen how to string multiple counters together to create section-andsubsection counting. Often, this is something authors desire for nested ordered lists as well, but it would quickly become clumsy to try to create enough counters to cover deep nesting levels. Just to get it working for five-level-deep nested lists would require a bunch of rules like this:

ol ol ol ol ol li:before \{counter-increment: ord1 ord2 ord3 ord4 ord5;

content: counter(ord1) "." counter(ord2) "." counter(ord3) "." counter(ord4) "." counter(ord5) ".";\}

Imagine writing enough rules to cover nesting up to 50 levels! (I'm not saying you should nest ordered lists 50 deep. Just follow along for the moment.)

Fortunately, CSS2.x described the concept of scope when it comes to counters. Stated simply, every level of nesting creates a new scope for any given counter. Scope is what makes it possible for the following rules to cover nested-list counting in the usual HTML way:



These rules will all make ordered lists, even those nested inside others, start counting from 1 and increment each item by one-exactly how it's been done in HTML from the beginning.

This works because a new instance of the counter ordered is created at each level of nesting. So, for the first ordered list, an instance of ordered is created. Then, for every list nested inside the first one, another new instance is created, and the counting starts anew with each list.

However, you want ordered lists to count so that each level of nesting creates a new counter appended to the old: 1, 1.1, 1.2, 1.2.1, 1.2.2, 1.3, 2, 2.1, and so on. This can't be done with counter( ), but it can be done with counters( ). What a difference an "s" makes.

To create the nested-counter style shown in Figure 12-25, you need these rules:

ol \{counter-reset: ordered; \}

ol li:before \{counter-increment: ordered;

content: counters(ordered,".") " - ";\}



Figure 12-25. Nested counters

Basically, the keyword counters(ordered,".") displays the ordered counter from each scope with a period appended, and strings together all of the scoped counters for a given element. Thus, an item in a third-level-nested list would be prefaced with the ordered value for the outermost list's scope, the scope of the list between the outer and current list, and the current list's scope, with each of those followed by a period. The rest of the content value causes a space, hyphen, and space to be added after all of those counters.

As with counter( ), you can define a list style for nested counters, but the same style applies to all of the counters. Thus, if you changed your previous CSS to read as follows, the list items in Figure 12-25 would all use lowercase letters for the counters instead of numbers:

ol li:before \{counter-increment: ordered; content: counters(ordered, ".",lower-alpha) ": "; $\}$

## Summary

Even though list styling isn't as sophisticated as we might like, and browser support for generated content is somewhat spotty (as of this writing, anyway), the ability to style lists is still highly useful. One relatively common use is to take a list of links, remove the markers and indentation, and thus create a navigation sidebar. The combination of simple markup and flexible layout is difficult to resist. With the anticipated enhancements to list styling in CSS3, I expect that lists will become more and more useful.

For now, in situations where a markup language doesn't have intrinsic list elements, generated content can be an enormous help-say, for inserting content such as icons to point to certain types of links (PDF files, Word documents, or even just links to another web site). Generated content also makes it easy to print out link URLs, and its ability to insert and format quotation marks leads to true typographic joy. It's safe to say that the usefulness of generated content is limited only by your imagination. Even better, thanks to counters, you can now associate ordering information to elements that are not typically lists, such as headings or code blocks. Now, if you want to support such features with design that mimics the appearance of the user's operating system, read on. The next chapter will discuss ways to use system colors and fonts in CSS design.

## CHAPTER 13

## User Interface Styles

The vast majority of CSS is concerned with styling documents, but it offers a passel of useful interface-styling tools for more than just documents. For example, Mozilla's developers created its browser's interface (and that of many Mozilla clones) using a language called XUL. XUL employs CSS and CSS-like declarations to present the navigation buttons, sidebar tabs, dialog boxes, status boxes, and other pieces of the chrome itself.

Similarly, you can reuse aspects of the user's default environment to style a document's fonts and colors; it's even possible to exert influence over focus highlighting and the mouse cursor. CSS2's interface capabilities can make the user's experience more enjoyable — or more confusing, if you aren't careful.

## System Fonts and Colors

There may be times when you want your document to mimic the user's computing environment as closely as possible. An obvious example is if you're creating webbased applications, where the goal is to make the web component seem like a part of the user's operating system. While CSS2 doesn't make it possible to reuse every last aspect of the operating system's appearance in your documents, you can choose from a wide variety of colors and a short list of fonts.

## System Fonts

Let's say you've created an element that functions as a button (via JavaScript, for example). By making the control look just like a button in the user's computing environment, you meet the user's expectations of how a control should look and thus make it more usable.

To accomplish the given example, simply write a rule like this:

a.widget \{font: caption; \}

This will set the font of any a element with a class of widget to use the same font family, size, weight, style, and variant as the text found in captioned controls, such as a button.

CSS2 defines six system font keywords. These are described in the following list: caption

The font styles used for captioned controls, such as buttons and drop-downs icon

The font styles used to label operating system icons, such as hard drives, folders, and files

menu

The font styles used for text in drop-down menus and menu lists message-box

The font styles used to present text in dialog boxes

## small-caption

The font styles used for labeling small captioned controls status-bar

The font styles used for text in window status bars

It's important to realize that these values can be used only with the font property and are their own form of shorthand. For example, let's assume that a user's operating system shows icon labels as 10-pixel Geneva with no boldfacing, italicizing, or small-caps effects. This means that the following three rules are all equivalent, and have the result shown in Figure 13-1:



So a simple value like icon actually embodies a whole lot of other values. This is fairly unique in CSS, and it makes working with these values just a little more complex than usual.

As an example, suppose you want to use the same font styling as icon labels, but you want the font to be boldfaced even if icon labels are not boldfaced on a user's system. You'd need a rule with the declarations in the order shown:

body \{font: icon; font-weight: bold; \}

By writing the declarations in this order, you cause the user agent to set the body element's font to match icon labels with the first declaration, and then modify the

## Cascading Style Sheets: The Definitive Guide




what its properties and values mean, and how authors can use them in the real world. A synthesis of browser support charts, the wisdom of Web design and usability experts, and the author's unique perspective on CSS, this book tells designers how CSS is supposed to work, how browsers treat it, and what paths allow for a safe threading between theory and reality.


arfinifise lruite is the best way to crack open the world of proper style for the Web.

Figure 13-1. Making text look like an icon label

weight of that font with the second. If the order were reversed, then the font declaration's value would override the font-weight value from the second declaration, and the boldfacing would be lost. This is similar to the way shorthand properties (like font itself) must be handled.

You may be wondering about the lack of a generic font family, since it's usually recommended that the author write something like Geneva, sans-serif; (in case a user's browser doesn't support the specified font). CSS won't let you "tack on" a generic font family, but in this case, it isn't needed. If the user agent manages to extract the font family used to display something in the computing environment, then it's a pretty safe bet the same font is available for the browser to use.

If the requested system font style is not available or can't be determined, the user agent is allowed to guess at an appropriate set of font styles. For example, smallcaption might be approximated by taking the styles for caption and reducing the font's size. If no such guess can be made, the user agent should use a "user agent default font" instead.

## System Colors



As of this writing, the working draft of the CSS3 Color module deprecates the system color keywords in favor of the new property appearance. Similarly, CSS2.1 deprecates these keywords in anticipation of changes in CSS3. Authors are strongly encouraged not to use the system colors, as they are not likely to appear in future versions of CSS. This information is included because some currently available browsers do support system colors.

If you want to reuse the colors specified in the user's operating system, CSS2 defines a series of system color keywords. These are values that can be used in any circumstance where a <color> value is allowed. For example, you could match the background of an element with the user's desktop color by declaring:

div\#test \{background-color: Background; \}

Thus, for example, you could give a document the system's default text and background color like this:

body \{color: WindowText; background: Window; \}

Such customization increases the odds that the user will be able to read the document, since he has presumably configured his operating system to be usable. (If not, he deserves whatever he gets!)

There are 28 system color keywords in total, although CSS does not explicitly define them. Instead, there are some generic (and very short) descriptions of each keyword's meaning. The following list describes all 28 keywords. In cases where there is a direct analog with the options in the "Appearance" tab of the Display control panel in Windows 2000, it is noted parenthetically after the description.

## ActiveBorder

The color applied to the outside border of an active window (the first color in "Active Windows Border").

ActiveCaption

The background color of the caption of the currently active window (the first color in "Active Title Bar").

## AppWorkspace

The background color used in an application that allows multiple documents-

e.g., the background color "behind" the open documents in Microsoft Word (the first color in "Application Background").

Background

The background color for the desktop (the first color in "Desktop").

## ButtonFace

The color used on the "face" of a three-dimensional button.

## ButtonHighlight

The highlight color found on the edges of three-dimensional display elements that face away from the virtual light source. Thus, if the virtual light source is located in the upper left, this would be the highlight color used on the right and bottom edges of the display element.

## ButtonShadow

The shadow color for three-dimensional display elements.

## ButtonText

The color of text found on push buttons (the font color in "3D Objects").

## CaptionText

The color of text found in captions, the size box, and the symbol in a scrollbar arrow box (the font color in "Active Title Bar").

GrayText

The grayed (disabled) text. This keyword is interpreted as \#000 if the current display driver does not support a solid gray color.

Highlight

The color of item(s) selected in a control (the first color in "Selected Items").

HighlightText

The text color of item(s) selected in a control (the font color in "Selected Items").

InactiveBorder

The color applied to the outside border of an inactive window (the first color in "Inactive Window Border").

InactiveCaption

The background color of the caption of an inactive window (the first color in "Inactive Title Bar").

InactiveCaptionText

The color of text in an inactive caption (the font color in "Inactive Title Bar").

InfoBackground

The background color in tool tips (the first color in "ToolTip").

InfoText

The text color in tool tips (the font color in "ToolTip").

Menu

The color of a menu's background (the first color in "Menu").

MenuText

The color of text found in menus (the font color in "Menu").

Scrollbar

The "gray area" of a scrollbar.

## ThreeDDarkShadow

The same color as a dark shadow found on three-dimensional display elements.

## ThreeDFace

The same color as the face of three-dimensional display elements.

ThreeDHighlight

The color of highlights found on three-dimensional display elements. ThreeDLightShadow

The light color found on three-dimensional display elements (for edges facing the light source).

ThreeDShadow

The dark shadow found on three-dimensional display elements.

Window

The color in the background of a window (the first color in "Window").

WindowFrame

The color applied to the frame of a window.

WindowText

The color of text in windows (the font color in "Window").

CSS2 defines the system color keywords to be case-insensitive but recommends using the mixed capitalization shown in the previous list, which makes the color names more readable. As you can see, ThreeDLightShadow is easier to understand at a glance than threedlightshadow.

An obvious drawback of the vague nature of the system color keywords is that different user agents may interpret the keywords in different ways, even if the user agents are running in the same operating system. Therefore, don't rely absolutely on consistent results when using these keywords. For example, avoid text that reads, "Look for the text whose color matches your desktop", since the user may have placed a desktop graphic (or "wallpaper") over the default desktop color.

## Cursors

Another important part of the user interface is the cursor (referred to in the CSS specification as the "pointing device"), which is controlled by a device such as a mouse, trackpad, graphic tablet, or even an optical-reading system. The cursor is useful for providing interaction feedback in most web browsers; an obvious example is that the cursor changes to a small hand with an extended index finger whenever it crosses over a hyperlink.

## Changing the Cursor

CSS2 lets you change the cursor icon, which means that it's much easier to create web-based applications that function in a manner similar to desktop applications in the operating system. For example, a link to help files might cause the cursor to turn into a "help" icon such as a question mark, as shown in Figure 13-2.

In many ways, the Cascading Style, Sheets (CSS) specification

development in the history of the World Wide Web. In its inher

structural dncumente $\mathrm{CSS}$ is hoth a sten formard and a sten $h$ :

Figure 13-2. Changing the cursor's icon

This is accomplished with the property cursor.

# cursor 

Values: $\quad\left[[\text { <uri>, }]^{*}\right.$ [auto $\mid$ default $\mid$ pointer $\mid$ crosshair $\mid$ move $\mid$ e-resize $\mid$ ne-resize | nw-resize $\mid$ n-resize $\mid$ se-resize $\mid$ sw-resize $\mid$ s-resize | w-resize| text | wait | help | progress ]] | inherit

Initial value: auto

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: For < uri> values, an absolute value; otherwise, as specified

The default value, auto, simply means that the user agent should determine the cursor icon that is most appropriate for the current context. This is not the same as default, which forces the icon to be the operating system's default cursor. The default cursor is usually an arrow, but it does not have to be; it depends on the current computing environment.

## Pointing and selection cursors

The value pointer changes the cursor icon to be the same as when the user moves the cursor over a hyperlink. You can even describe this behavior for HTML documents:

a[href] \{cursor: pointer; \}

With cursor, any element can be defined to change the icon as though it were a link. This can be very confusing to the user, so I don't recommend doing it often. On the other hand (so to speak), cursor makes it much easier to create interactive, scriptdriven screen widgets out of non-link elements and then change the icon appropriately, as illustrated by Figure 13-3.

By Eric A. Meyer<br>Published by O'Reilly \& Associates<br>ISBN 1-56592-622-6

Figure 13-3. Indicating an element's interactivity

Internet Explorer for Windows before IE6 did not recognize pointer, but instead used the value hand to invoke the "pointing hand" icon. IE6 recognizes both values. A common recommendation is to use both values in succession, like this:

\#example \{cursor: pointer; cursor: hand;\}

This will not validate, but it will get a consistent result in newer browsers and older versions of Explorer. Note that the order is critical: you cannot reverse the values and expect this to work. See http:// developer.mozilla.org/en/docs/Giving_'cursor'_a_Hand for more details.

The other cursor icon very common to web browsing is the text icon, which appears in situations where the user is able to select text. This is typically an "I-bar" icon, and serves as a visual cue that the user can drag-select the content under the cursor. Figure 13-4 shows a text icon at the end of some already selected text.



Figure 13-4. Selectable text and the text cursor

Another way to indicate interactivity is to use the value crosshair, which changes the cursor icon into, well, a crosshair symbol. This is typically a pair of short lines at a 90-degree angle to each other, one vertical and the other horizontal, looking rather like a plus (+) sign. However, a crosshair could also resemble a multiplication sign (or a lowercase " $\mathrm{x}$ ") or even an icon similar to the display inside a rifle scope. Crosshairs are usually used with screen-capture programs, and they can be useful in situations where the user is expected to know exactly which pixel is being clicked.

## Movement cursors

In many circumstances, the value move will yield a result similar to crosshair. move is used in situations where the author needs to indicate that a screen element can be moved, and it is often rendered like a thick crosshair with arrowheads on the ends of the lines. It may also be rendered as a "gripping hand" whose fingers curl when the user clicks and holds the mouse button. Two possible move renderings are shown in Figure 13-5. $\qquad$
Figure 13-5. Differing icons for move

Then there are the various cursor values related to move: e-resize, ne-resize, and so on. Windows and most graphical Unix-shell users will recognize these as the icons that appear when the mouse cursor is placed over the side or corner edges of a window. For example, placing the cursor over the right side of the window will bring up an e-resize cursor, indicating that the user can drag the right side of the window back and forth to change the window size. Putting the cursor over the lower-left corner invokes the sw-resize cursor icon. There are many different ways to render these icons; Figure 13-6 shows a few of the possibilities.



Figure 13-6. A selection of "resize" cursors

## Waiting and progressing

Both wait and progress indicate that the program is busy. However, they're not identical: wait means the user should wait until the program isn't as busy, while progress indicates that the user should feel free to continue interacting with the program, even though it's busy. On most operating systems, wait is either a watch (possibly with spinning hands) or an hourglass (possibly turning itself over every so often). progress is typically represented as a spinning "beach ball" or an arrow with a small hourglass off to one side. Figure 13-7 shows some of these icons.



Figure 13-7. Waiting versus progressing



The value progress was introduced in CSS2.1.

## Providing help

In situations where the author wants to indicate that the user can get some form of help, the value help is the answer. Two very common renderings of help are a question mark and an arrow with a small question mark next to it. help can be very useful if you have classed certain links that point to more information or to information that will help the user understand the web page better. For example:

$$
\text { a.help \{cursor: help;\} }
$$

You can also use help to indicate that an element has "extra" information, such as acronym elements with title attributes. In many user agents, leaving the cursor over a titled acronym will cause the user agent to show the contents of the title attribute in a "tool tip." However, users who move the cursor around quickly, or who have slow computers, may not realize the extra information is there if the cursor didn't change. For such users, the following rule could be useful, and will lead to a result like that shown in Figure 13-8:

acronym[title] \{cursor: help; border-bottom: 1px dotted gray;\}



Figure 13-8. Showing that help (in the form of more information) is available

## Graphic cursors

Last, but most intriguing, is the ability to call for a customized cursor. This is done using a URL value:

a.external \{cursor: url(globe.cur), pointer; \}

With this rule, the user agent is asked to load the file globe.cur and use it as the cursor icon, as illustrated in Figure 13-9.

If you're interested in finding out more, visit the Earth Day Tite for
more details and schedules.

Figure 13-9. Using a custom graphic cursor

Of course, the user agent has to support the file format used to store globe.cur. If it does not, then it will fall back to the value pointer. Note that in the cursor syntax definition, any URL must be followed by a comma and one of the generic keywords. This is different from the property font-family, where you can call for a specific family and not provide any fallbacks. In effect, cursor requires fallbacks for any graphical cursors you might try to employ.

You can even specify multiple cursor files before the fallback keyword. For example, you might create the same basic cursor in several formats and include them all in a rule, hoping a user agent will support at least one of them:

a.external \{cursor: url(globe.svg\#globe), url(globe.cur), url(globe.png), url(globe.gif), url(globe.xbm), pointer; \}

The user agent will go through the different URLs until it finds a file it can use for the cursor icon. If the user agent can't find anything it supports, it will fall back to the keyword.



You can actually implement animated cursors if a user agent supports animated graphic files for cursor replacements. IE6, for example, supports this ability with .ani files.

## Outlines

CSS2 introduces one last major piece of user-interface styling: outlines. An outline is sort of like a border, but there are two very important differences. First, outlines do not participate in the flow of the document like borders do, and thus don't trigger document reflow as they appear and disappear. If you give an element a 50-pixel outline,
the outline will very likely overlap other elements. Second, outlines can be nonrectangular-but don't start leaping for joy just yet. This does not mean that you can create circular outlines. Instead, it means that an outline on an inline element may not act like a border would on that same element. With an outline, a user agent is allowed to "merge" the pieces of the outline to create a single continuous, but nonrectangular, shape. Figure 13-10 shows an example.



Figure 13-10. Outlines can have irregular shapes

User agents are not required to support nonrectangular outlines. They could instead format outlines on inline nonreplaced elements the same way they do borders. A conforming user agent must, however, make sure that outlines do not take up layout space.

There is one other basic way in which outlines and borders differ: they aren't the same thing, so they can both exist on the same element. This can lead to some interesting effects, such as that illustrated in Figure 13-11.



Figure 13-11. The coexistence of borders and outlines

The CSS2 specification states the following: "The outline may be drawn starting just outside the border edge." Note the word may in that sentence. User agents are encouraged to do as the sentence suggests, but it isn't a requirement. A user agent could decide to draw outlines inside the inner border edge or at some small distance from the border. As of this writing, all browsers that support outlines draw them just outside the outer border edge, so, thankfully, there is consistency.

Outlines are considered to be part of user-interface styling because they are most often used to indicate the current focus. If a user is using keyboard navigation to jump from link to link, then the link that is currently in focus will usually get an outline. In Internet Explorer for Windows, an outline is applied to any link that has been selected by the user ("clicked," if she's using a mouse), and tends to persist even when it isn't wanted. Other browsers apply outlines to text inputs that have the keyboard focus, thus giving a cue to where input will go if the user starts typing.

As you'll see, outlines are styled a lot like borders, but there are some key differences besides the ones previously mentioned. We'll just skip quickly over the similarities and spend time looking at the differences.

## Setting an Outline's Style

As with a border, the most basic aspect of an outline is its style, which is set using outline-style.



The list of style keywords is largely the same as the keywords for border styles, and the visual effects are the same. There is one omission: hidden is not a valid outline style, and user agents are required to effectively treat it as none. This actually makes sense, given that outlines don't affect layout even when they're visible.

The other difference between outlines and borders is that you can specify only one keyword for an outline-style value (compared with up to four keywords for borders). The practical effect is that outlines must have the same outline style all the way around an element, whether they're rectangular or not. This is probably just as well, since trying to figure out how to apply different styles to the same nonrectangular outline would be a pain.

## Outline Width

Once you've brought an outline into being by giving it a style, it's a good idea to use outline-width to define (you guessed it) the outline's width.



The list of keywords should look very familiar to anyone who's set a border width. The only real difference between outline-width and border-width is that, as with the style, you can declare only a single width for the entire outline. Thus, only one keyword is permitted in a value.

## Coloring an Outline

Since you can set style and width, it makes sense that outline-color exists to let you give the outline a color.

|  | outline-color |
| :--- | :--- |
| Values: | <color> $\mid$ invert $\mid$ inherit |
| Initial value: | invert (or user agent-specific; see text) |
| Applies to: | All elements |
| Inherited: | No |
| Computed value: | As specified |

Herein lies the most intriguing difference between borders and outlines: the keyword invert, which is the default value. An inverting outline means that a color inversion is performed for the pixels where the outline exists. See Figure 13-12.



Figure 13-12. Inverting color with an outline

The process of color-inverting pixels "behind" the outline ensures that no matter what appears behind the outline, it will be visible. If a user agent can't support color inversion for some reason, it should use instead the computed value of color for the element.

The ability to invert pixels on screen is very interesting, especially since there's no theoretical limit on the width of an outline. So you could, should you choose, use an outline to invert large portions of your document. This isn't really the purpose of outlines, but Figure 13-13 shows one such result anyway.



Figure 13-13. Massive inversion

Of course, if you'd rather define a specific color for your outline, just use any valid color value. The results of the following declarations should be obvious enough:

outline-color: red;

outline-color: \#000;

outline-color: $\operatorname{rgb}(50 \%, 50 \%, 50 \%)$;

The potential drawback here is the possibility that an outline color could closely match the colors of the pixels around it, in which case the user won't be able to see it. This is why invert was defined.

As with outline styles and widths, you can define only one color for the entire outline.

## Bringing It All Together

Like border for borders, outline is the shorthand property that allows you to set the style, width, and color of an outline all at once.

## outline

Values: $\quad[$ <outline-color> || <outline-style> || <outline-width> ] | inherit

Initial value: $\quad$ Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (outline-color, etc.)

As with other shorthands, outline brings together several properties into a compact notation. It's subject to the same behaviors as other shorthand notations, which override previously defined values. Therefore, in the following example, the outline will use the color keyword invert since it's implied by the second declaration:

a:focus \{outline-color: red; outline: thick solid; \}

Because a given outline must be of a uniform style, width, and color, outline is the only shorthand property related to outlines. There are no properties such as outlinetop or outline-right.

In cases where you want to simulate an inversion border, you can set an outline with a length value for its width, and set the element's margin to an equal or greater width. Since the outline is drawn "on top" of the margin, it will fill in some of that space, as illustrated in Figure 13-14:

div\#callbox \{outline: $5 p x$ solid invert; margin: $5 p x$; \}

input:focus \{outline: 1em double gray; \}



Figure 13-14. Different outlines

As I mentioned earlier, outlines do not participate in the document's flow. This prevents forced reflow in cases like link-focus outlines, which will move from link to link as the focus changes. If an author uses borders to indicate the focus, the document layout may shift or jump around. Outlines can yield the same effects borders allow, but without the jumpiness.

Outlines can accomplish this because they are, by definition, drawn above the rest of the element's box. Since outlines cannot overlap visible portions of their element's box in CSS2, but can overlap only the margins (which are transparent), this is not a big issue. If a future version of CSS allows outlines to move inward to overlap the borders or other visible portions of the element box, then the placement of outlines will become more important.

The one area of unfortunate vagueness in CSS2 is that it explicitly avoids defining the behaviors of two outlines overlapping each other and what happens to outlines on elements that are partially obscured by other elements. You can combine both of these in a single example:



Now suppose div\#two immediately follows div\#one in a document. It will overlap the first div, and its background will overlap portions of the first div's outline. I haven't included a figure to accompany this code block because the CSS2 specification doesn't provide any ideas about what would happen. Should the first div's outline be visible, overlapping the background and contents of the second div? There will also be places where the two inversion outlines intersect; what should happen there? Are the pixels double-inverted, and thus restored to their original state? Or should the pixels be inverted once and then left unchanged? We don't know. Any illustration here would be neither right nor wrong, but simply a possible outcome-and not necessarily the one that user agents end up implementing or that a future version of CSS defines.

## Summary

Thanks to user interface styles, it's possible for an author to make a document look more like the user's computing environment, especially with a creative use of system color and fonts. By reusing things with which the user is already familiar, a document can seem more familiar and user-friendly from the outset.

Another way to make users' lives a little easier is to create style sheets that are targeted at media other than their monitors. This would include styles intended specifically for printing, aural (spoken) access of a web page, and even for a projection-screen environment. We'll cover all of those in the next chapter.

## CHAPTER 14

## Non-Screen Media

Not everyone who accesses the Web can see the effects we've discussed in this book. Some 1.1 million people in the United States are blind, and they have a very different experience of the Web than sighted persons.

Fortunately, CSS is not silent on the matter of non-visual access. CSS2 included the ability to apply styles in non-screen media. While most of the Web's evolution has taken place on monitors - that is to say, in a visual medium-CSS2 can be used in non-visual media, assuming that the user agent has proper support.

The advantages of designing documents that are at once visually and non-visually usable should not be dismissed. If you can take one document and use different, medium-specific style sheets to restyle it for screen, print, and aural rendering, you can save yourself a whole lot of trouble. For example, you wouldn't need to link to "printer-friendly" versions of a page. Instead of creating totally different markup structures, one for screen and another for print, you can make your site more efficient by reusing the same document.

For that matter, it's possible to take a single HTML document that contains the outline of a slideshow and style it for easy reading on a screen, for clean and readable printouts, as a slideshow, and in a manner that a screen reader can translate. In the course of this chapter, we'll look at ways to do the latter three (since the rest of the book concerns itself with screen presentation).

## Designating Medium-Specific Style Sheets

You can restrict any kind of style sheet to a specific medium, thanks to the mechanisms defined in HTML and CSS. For HTML-based style sheets, you can impose medium restrictions through the media attribute. This works the same for both the link and style elements:

<link rel="stylesheet" type="text/css" media="print" href="article-print.css">
<style type="text/css" media="projection">

body $\{$ font-family: sans-serif; \}

</style>

The media attribute can accept a single medium value or a comma-separated list of values. Thus, to link in a style sheet that should be used in only the screen and projection media, you would write:

<link rel="stylesheet" type="text/css" media="screen, projection" href="visual.css">

In a style sheet itself, you can also impose medium restrictions on @import rules:

@import url(visual.css) screen, projection;

@import url(article-print.css) print;

Remember that if you don't add medium information to a style sheet, it will be applied in all media. Therefore, if you want one set of styles to apply only onscreen, and another to apply only in print, then you need to add medium information to both style sheets. For example:



If you were to remove the media attribute from the first link element in the preceding example, the rules found in the style sheet article-screen.css would be applied in all media, including print, projection, handheld, and everything else.

CSS2 also defines syntax for @media blocks, which lets you define styles for multiple media within the same style sheet. Consider this basic example:



Here you see that in all media, the body element is given a white background and a black foreground. Then a block of rules is provided for the screen medium alone, followed by another block of rules that applies only in the print medium.

@media blocks can be any size and contain any number of rules. In situations where authors may have control over a single style sheet, @media blocks may be the only way to define medium-specific styles. This is also the case in situations where CSS is used to style a document using an XML language that does not contain a media attribute or its equivalent.

## Paged Media

In CSS terms, a paged medium is any medium where a document's presentation is handled as a series of discrete "pages." This is different from the screen, which is a continuous medium: documents are presented as a single, scrollable "page." An analog example of a continuous medium is a papyrus scroll. Printed material, such as books, magazines, and laser printouts, are all paged media. So are slideshows, where a series of slides is shown one at a time. Each slide is a "page" in CSS terms.

## Print Styles

Even in the "paperless future," the most commonly encountered paged medium is a printout of some document - a web page, a word-processing document, a spreadsheet, or something else that has been committed to the thin wafers of a dead tree. Authors can do a number of things to make printouts of their documents more pleasing for the user, from affecting page breaking to creating styles meant specifically for print.

Note that print styles would also be applied to document display in a "print preview" mode. Thus, it's possible in some circumstances to see print styles on a monitor.

## Differences between screen and print

Beyond the obvious physical differences, there are a number of stylistic differences between screen and print design. The most basic involves font choices. Most designers will tell you that sans-serif fonts are best suited for screen design, but serif fonts are more readable in print. Thus, you might set up a print style sheet that uses Times instead of Verdana for the text in your document.

Another major difference involves font sizing. If you've spent any time at all doing web design, you've probably heard again and again (and again) that points are a horrible choice for font sizing on the Web. This is basically true, especially if you want your text to be consistently sized between browsers and operating systems. However, print design is not web design any more than web design is print design. Using points, or even centimeters or picas, is perfectly $\mathrm{OK}$ in print design because printing devices know the physical size of their output area. If a printer has been loaded with $8.5 \times 11$ paper, then it knows it has a printing area that will fit within the edges of that piece of paper. It also knows how many dots there are in an inch, since it knows how many dots-per-inch (dpi) it's capable of generating. This means that it can cope with physical-world length units like points.

Therefore, many a print style sheet has started with:

body \{font: 12pt "Times New Roman", "TimesNR", Times, serif;\}

It's so traditional, it just might bring a tear of joy to the eye of a graphic designer reading over your shoulder. But make sure he understands that points are acceptable only because of the nature of the print medium - they're still not good for web design.

Alternatively, the lack of backgrounds in most printouts might bring a tear of frustration to that designer's eye. To save users ink, most web browsers are preconfigured not to print background colors and images. If the user wants to see those backgrounds in the printout, she must change an option somewhere in the preferences. CSS can't do anything to force the printing of backgrounds. However, you can use a print style sheet to make backgrounds unnecessary. For example, you might include this rule in your print style sheet:

* \{color: black ! important; background: white !important; \}

This will ensure that all of your elements will print out as black text and remove any backgrounds you might have assigned in an all-medium style sheet. Since this is how most users' printers will render the page anyway, you're better off setting up your print styles along the same lines. If you have a web design that puts yellow text on a dark gray background, this rule also makes sure that a user with a color printer won't get yellow text on a white piece of paper.



CSS2.x does not include a mechanism for picking a style sheet based on the user's output device. Thus, all printers will use the print style sheets you define. The CSS3 Media Queries module defines ways to send a different style sheet to color printers than to grayscale printers, but as of this writing, support for media queries is basically nonexistent.

One other difference between paged media and continuous media is that multicolumn layouts are even harder to use in paged media. Suppose you have an article where the text has been formatted as two columns. In a printout, the left side of each page will contain the first column, and the right side the second. This would force the user to read the left side of every page, then go back to the beginning of the printout and read the right side of every page. This is annoying enough on the Web, but on paper it's much worse.

The obvious solution is to use CSS for laying out your two columns (by floating them, perhaps) and then writing a print style sheet that restores the content to a single column. Thus, you might write something like this for the screen style sheet:

div\#leftcol \{float: left; width: $45 \%$; $\}$

div\#rightcol \{float: right; width: $45 \%$; \}

Then in your print style sheet, you would write:

div\#leftcol, div\#rightcol \{float: none; width: auto; \}

If CSS had a way to do multicolumn flowed layout, none of this would be necessary. Sadly, although proposals have circulated for years, there is nothing offered as of this writing.

We could spend an entire chapter on the details of print design, but that really isn't the purpose of this book. Let's start exploring the details of paged-media CSS and leave the design discussions for another book.

## Defining the page size

In much the same way as it defines the element box, CSS2 defines a page box that describes the components of a page. A page box is composed of basically two regions:

- The page area, which is the portion of the page where the content is laid out. This is roughly analogous to the content area of a normal element box, to the extent that the edges of the page area act as the initial containing block for layout within a page. (See Chapter 7 for details on containing blocks.)
- The margin area, which surrounds the page area.

The page box model is illustrated in Figure 14-1.



Figure 14-1. The page box

In CSS2, it was possible to define the size of the page box as well as the margins. In CSS2.1, authors can set only the size of the margin area. In both cases, the @page rule is the method by which settings are made. Here's a simple example:

@page \{size: 7.5in 10in; margin: 0.5in; \}

This is a CSS2 rule, as it uses the property size, which was not included in CSS2.1 due to a lack of implementation support.

## size

Values: $\quad<$ length $>\{1,2\} \mid$ auto $\mid$ portrait $\mid$ landscape $\mid$ inherit

Initial value: auto

Applies to: $\quad$ The page area

Inherited: $\quad$ No

This property is used to define the size of the page area. The value landscape causes the layout to be rotated 90 degrees, whereas portrait is the normal orientation for Western-language printing. Thus, an author could cause a document to be printed "sideways" by declaring:

@page \{size: landscape; $\}$

size is not part of CSS2.1, which means that, as of its writing, no two interoperable implementations of size are known to exist. So, browser support is likely to be poor. CSS2. 1 does include the ability to style the margin area of the page box, which is likely to work more reliably. If you want to make sure that only a small bit at the center of every $8.5 \times 11$ page would print, you could write:

@page \{margin: $3.75 \mathrm{in} ;\}$

This would leave a printing area one inch wide by three and a half inches tall.

What's really interesting about the page box is that it doesn't have any relationship to fonts, so you can't use the length units em and ex to describe either the margin area or the page area. Only percentages and "ruler" units like inches, centimeters, or points are permitted in this context.

## Selecting page types

CSS2 offers the ability to create different page types using named @page rules. Let’s say you have a document on astronomy that is several pages long, and in the middle of it, there is a fairly wide table containing a list of the physical characteristics of all the moons of Saturn. You want to print out the text in portrait mode, but the table needs to be landscape. Here's how you'd start:

@page normal \{size: portrait; margin: 1in;\}

@page rotate \{size: landscape; margin: $0.5 \mathrm{in} ;\}$

Now you just need to apply these page types as needed. The table of Saturn's moons has an id of moon-data, so you write the following rules:

body \{page: normal; \}

table\#moon-data \{page: rotate; \}

This would cause the table to be printed in landscape mode, but the rest of the document to be printed in portrait orientation. The property page, another outcast in CSS2.1, makes this possible.

|  | page |
| :--- | :--- |
| Values: | <identifier> \| inherit |
| Initial value: | auto |
| Applies to: | Block-level elements |
| Inherited: | Yes |

As you can see from looking at the value definition, the whole reason page exists is to let you assign named page types to various elements in your document.

There are more generic page types that you can address through special pseudoclasses, and even better, this is one defined in both CSS2 and CSS2.1. : first lets you apply special styles to the first page in the document. For example, you might want to give the first page a larger top margin than other pages. Here's how:

@page \{margin: $3 \mathrm{~cm} ;\}$

@page :first \{margin-top: $6 \mathrm{~cm}$; \}

This will yield a three-centimeter margin on all pages, with the exception of a sixcentimeter top margin on the first page. The effect will be something like that shown in Figure 14-2.

## The First Page!

Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.

Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.
Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.

Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud

Figure 14-2. Specially styling the first page

In addition to styling the first page, you can also style left and right pages, emulating the pages to the left and right of a book's spine. You can style these differently using :left and :right. For example:

@page :left \{margin-left: $3 \mathrm{~cm}$; margin-right: $5 \mathrm{~cm} ;\}$

@page :right \{margin-left: $5 \mathrm{~cm}$; margin-right: $3 \mathrm{~cm} ;\}$

These rules will have the effect of putting larger margins "between" the content of the left and right pages, on the sides where the spine of a book would be. This is a common practice when pages will be bound together into a book of some type. You can see the result of the previous rules in Figure 14-3.

Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.

Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.
Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.

Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.

Figure 14-3. Styling left and right pages differently

## Page breaking

In a paged medium, it's a good idea to exert some influence over how page breaks are placed. You can affect page breaking using the properties page-break-before and page-break-after, both of which accept the same set of values.

## page-break-before, page-break-after

Values:

auto | always | avoid | left | right | inherit

Initial value:

auto

Applies to: Nonfloated block-level elements with a position value of relative or static

Inherited:

No

Computed value: As specified

The default value of auto simply means that a page break is not forced to come before or after an element. This is the same as any normal printout. always causes a page break to be placed before (or after) the styled element.

For example, assume you have a situation where the page title is an h1 element, and the section titles are all h2 elements. You might want a page break right before the beginning of each section of a document and after the document title. This would result in the following rules, illustrated in Figure 14-4:

h1 \{page-break-after: always; \}

h2 \{page-break-before: always; $\}$



Figure 14-4. Inserting page breaks

If you want the document title to be centered in its page, of course, you would add rules to that effect. Since you don't, you just get a very straightforward rendering of each page.

The values left and right operate in the same manner as always, except they further define the type of page on which printing can resume. Consider the following:

h2 \{page-break-before: left;\}

This will force every h2 element to be preceded by enough page breaks so that the h2 will be printed at the top of a left page - that is, a page surface that would appear to the left of a spine if the output were bound. In double-sided printing, this would mean printing on the "back" of a piece of paper.

So let's assume that, in printing, the element just before an h2 is printed on a right page. The previous rule would cause a single page break to be inserted before the h2, thus pushing it to the next page. If the next $\mathrm{h} 2$ is preceded by an element on a left page, however, the $h 2$ would be preceded by two page breaks, thus placing it at the top of the next left page. The right page between the two would be intentionally left blank. The value right has the same basic effect, except it forces an element to be printed at the top of a right page, preceded by either one or two page breaks.

The companion to always is avoid, which directs the user agent to do its best to avoid placing a page break either before or after an element. To extend the previous example, suppose you have subsections whose titles are h3 elements. You want to keep these titles together with the text that follows them, so you want to avoid a page break following an $\mathrm{h} 3$ whenever possible:

h3 \{page-break-after: avoid; \}

Note, though, that the value is called avoid, not never. There is no way to absolutely guarantee that a page break will never be inserted before or after a given element. Consider the following:

img \{height: 9.5in; width: 8in; page-break-before: avoid; \}

h4 \{page-break-after: avoid; \}

h4 + img \{height: 10.5in;\}

Now, suppose further that you have a situation where an h4 is placed between two images, and its height calculates to half an inch. Each image will have to be printed on a separate page, but there are only two places the h4 can go: at the bottom of the page holding the first element, or on the page after it. If it's placed after the first image, then it must be followed by a page break, since there's no room for the second image to follow it, as shown in Figure 14-5.

On the other hand, if the $h 4$ is placed on a new page following the first image, there won't be room on that same page for the second image. So, again, there will be a page break after the h4. And, in either case, at least one image, if not both, will be preceded by a page break. There's only so much the user agent can do, given a situation like this one.

Obviously, situations such as these are rare, but they can happen-for example, in a case where a document contains nothing but tables preceded by headings. There may be cases where tables print in such a way that they force a heading element to be



Figure 14-5. Necessary page breaking

followed by a page break, even though the author requested that such break placement be avoided.

The same sorts of issues can arise with the other page-break property, page-breakinside. Its possible values are more limited than those of its cousins.



With page-break-inside, you pretty much have one option other than the default: you can request that a user agent try to avoid placing page breaks within an element. If you have a series of "aside" divisions, and you don't want them broken across two pages, you could declare:

div.aside \{page-break-inside: avoid;\}

Again, this is a suggestion more than an actual rule. If an aside turns out to be longer than a page, obviously the user agent can't help but place a page break inside the element.

## Orphans and widows

In an effort to provide finer influence over page breaking, CSS2 defines two properties common to both traditional print typography and desktop publishing: widows and orphans.

|  | widows, orphans |
| :--- | :--- |
| Values: | <integer> \| inherit |
| Initial value: | 2 |
| Applies to: | Block-level elements |
| Inherited: | Yes |
| Computed value: | As specified |

These properties have similar aims but approach them from different angles. The value of widows defines the minimum number of line boxes found in an element that can be placed at the top of a page without forcing a page break to come before the element. orphans has the same effect in reverse: it gives the minimum number of line boxes that can appear at the bottom of a page without forcing a page break before the element.

Let's take widows as an example. Suppose you declare:

p \{widows: 4; $\}$

This means that any paragraph can have no fewer than four line boxes appear at the top of a page. If the layout of the document would lead to fewer line boxes, then the entire paragraph is placed at the top of the page. Consider the situation shown in Figure 14-6. Cover up the top part of the figure with your hand, so only the second page is visible. Notice that there are two line boxes there, from the end of a paragraph that started on the previous page. Given the default widows value of 2, this is an acceptable rendering. However, if the value were 3 or higher, the entire paragraph would appear at the top of the second page as a single block. This would require that a page break be inserted before the paragraph in question.

Look again at Figure 14-6, but this time cover up the second page with your hand. Notice the four line boxes at the bottom of the page, at the beginning of the last paragraph. This is fine as long as the value of orphans is 4 or less. If it were 5 or higher, the paragraph would again be preceded by a page break and be laid out as a single block at the top of the second page.

Of course, both orphans and widows must be satisfied. If an author declared the following, most paragraphs would be without an interior page break:

p \{widows: 30; orphans: 30; \}



Figure 14-6. Counting the widows

It would take a pretty lengthy paragraph to allow an interior page break given those values. Of course, if the intent is to prevent interior breaking, it would be better expressed as:

p \{page-break-inside: avoid; \}

## Page-breaking behavior

Because CSS2 allows for some odd page-breaking styles, it defines a set of behaviors regarding allowed page breaks and "best" page breaks. These behaviors guide user agents in how they should handle page breaking in various circumstances.

There are really only two generic places where page breaks are permitted. The first of these is between two block-level boxes. If a page break falls between two block boxes, then the margin-bottom value of the element before the page break is reset to 0 , as is the margin-top of the element following the page break. However, there are two rules that allow a page break to fall between two element boxes:

- If the value of page-break-after for the first element-or the value of page-breakbefore for the second element-is always, left, or right. This is true regardless of the value for theother element, even if it's avoid. (This is a forced page break.)
- If the value of the first element's page-break-after value is auto, and the same is true for the second element's page-break-before value, and if they do not share an ancestor element whose page-break-inside value is not avoid.

Figure 14-7 illustrates all of the possible page-break placements between elements in a hypothetical document. Forced page breaks are represented as a filled square, whereas potential (unforced) page breaks are shown as an open square.



Figure 14-7. Potential page-break placement between block boxes

The second generic place where page breaks are allowed is between two line boxes inside a block-level box. This, too, is governed by a pair of rules:

- A page break may appear between two line boxes only if the number of line boxes between the start of the element and the line box before the page break would be less than the value of orphans for the element. Similarly, a page break can be placed only where the number of line boxes between the line box after the page break and the end of the element is less than the value of widows.
- A page break can be placed between line boxes if the value of page-break-inside for the element is not avoid.

In both cases, the second of the two rules controlling page-break placement is ignored if no page-break placement can satisfy all the rules. Thus, given a situation where an element has been given page-break-inside: avoid but is longer than a full page, a page break is permitted inside the element, between two line boxes. In other words, the second rule regarding page-break placement between line boxes is ignored.

If ignoring the second rule in each pair of rules still does not yield good page-break placement, other rules can also be ignored. In such a situation, the user agent is likely to ignore all page-break property values and proceed as if they were all auto, although this approach is not defined (or required) by the CSS specification.

In addition to the previously explored rules, CSS2 defines a set of "best" page-breaking behaviors:

- Break as few times as possible.
- Make all pages that don't end with a forced break appear to have about the same height.
- Avoid breaking inside a block that has a border.
- Avoid breaking inside a table.
- Avoid breaking inside a floated element.

These recommendations aren't required of user agents, but they offer logical guidance that should promote ideal page-breaking behaviors.

## Repeated elements

A very common desire among authors of paged media is the ability to have a running head. This is an element that appears on every page, such as the document's title or the author's name. You can specify a running head in CSS2 by using a fixed-position element. For example:

div\#runhead \{position: fixed; top: 0 ; right: 0 ; \}

This will place any div with an id of runhead at the top-right corner of every page box when the document is output to a paged medium. The same rule would place the element in the top-right corner of the viewport in a continuous medium, such as a web browser. Any element positioned in this way will appear on every page. It is not possible to "copy" an element to become a repeated element. Thus, given the following, the h1 element will appear as a running head on every page, including the first one:

h1 \{position: fixed; top: 0; width: 100\%; text-align: center;

font-size: $80 \%$; border-bottom: 1 px solid gray; \}

The drawback is that the h1 element, being positioned on the first page, cannot be printed as anything except the running head.

## Elements outside the page

All of this talk about positioning elements in a paged medium leads to an interesting question: what happens if an element is positioned outside the page box? You don't even need positioning to create such a situation. Think about a pre element that contains a line with 411 characters. This is likely to be wider than any standard piece of paper, so the element will be wider than the page box. What happens then?

As it turns out, CSS2 doesn't say exactly what user agents should do, so it's up to them to come up with a solution. For a very wide pre element, the user agent might simply clip the element to the page box and throw away the rest of the content. It could also generate extra pages to display the "leftover" part of the element.

There are a few general recommendations for handling content outside the page box, two of which are really important. First, content should be allowed to protrude slightly from a page box to allow "bleeding." This implies that no extra page would be generated for the portions of such content that exceed the page box.

Second, user agents are cautioned not to generate large numbers of empty pages for the sole purpose of honoring positioning information. Consider:

h1 \{position: absolute; top: 1500in; \}

Assuming that the page boxes are 10 inches high, the user agent would have to precede an h1 with 150 page breaks (and thus 150 blank pages) just to honor that rule. Instead, a user agent might choose to skip the blank pages and only output the last one, which actually contains the h1 element.

The other two recommendations state that user agents should not position elements in strange places just to avoid rendering them, and that content placed outside a page box can be rendered in any number of ways. (Some elements of CSS are useful and intriguing, but some seem to cheerily state the obvious.)

## Projection Styles

Aside from printed pages, the other common paged medium is projection, which describes information that's being projected onto a large screen, suitable for viewing by a large crowd. Microsoft PowerPoint is one of the best-known projection-medium editors today.

As of this writing, only one user agent supports projection-medium CSS: Opera for Windows. This capability is called "OperaShow," and it allows authors to take any HTML document and turn it into a slideshow. We'll look at the basics of this capability, since it may appear in other user agents in the future, and it provides an interesting view of how CSS can be used in media other than screen or print.

## Setting up slides

If you're breaking up a single document into a series of slides, you need a way to define the boundaries between each slide. This is done using the page-break properties. Whether you use page-break-before or page-break-after will depend largely on how your document is constructed.

As an example, consider the HTML document shown in Figure 14-8. There is a series of h2 elements, each followed by an unordered list. This forms the "outline view" for your slideshow.

## Minimal Markup, Surprising Style <br> Eric A. Meyer

CSS:TDG

O'Reilly \& Associates

November 2003

## (Re)stating some truths

- CSS is NOT a pixel-fidelity presentation language!
- The reader can always trump the designer
- Use structural (X)HTML elements when you can
- Tables are okay, but use them sparingly
- Write CSS that's readable to you


## Where do we stand?

- Basic font and color controls are solid
- Layout and positioning is pretty firm, but gets shaky at the edges
- IE6/Win and Opera 7 join IE5/Mac and Gecko browsers in having "DOCTYPE switching"
- Improvements are coming all the time
- Old browsers can get content with minimal (or zero!) style


## Tripping the list fantastic

- Navbars, toolbars, sidebars-they all have one thing in common: they're collections of links
- We can represent such a collection as a list and style it
- With this simnle stnurture ure hasre a lint of nesentational flewihility

Figure 14-8. A slideshow outline using simple HTML

Now all you need to do is break up the document into slides. Since every slide starts with an h2 element, you can simply declare:

h2 \{page-break-before: always; \}

This will ensure that every page (that is, every slide) will start with an h2 element. Since the title of each slide is represented by an h2, this is fine: every slide will have an $\mathrm{h} 2$ as its first element. You can see the rendering of a slide in Figure 14-9.

## How Far Can We Go?

- CSS looks simple, and in a basic sense it is
- It's also highly complex and gives rise to surprising effects
- Flowing text along a curve
- Translucency effects
- Popups menus without JavaScript
- With the right document and CSS, you can create a slideshow
- We still don't know the limits of CSS-driven design

Figure 14-9. A slide

Of course, the slide looks pretty plain because you've done nothing else to make it look good; you've simply defined where page breaks are to be inserted.

Given the outline as it's currently set up, you could also have defined slide boundaries by inserting page breaks after the lists, instead of before the h2 elements:

ul \{page-break-after: always; \}

This method would work well, as long as your outline never includes nested lists. If there is a chance of having unordered lists nested within the "top-level" lists, then you'd either need to go back to putting page breaks before h2 elements, or add a second rule to prevent page-breaking:

ul \{page-break-after: always; \}

ul ul \{page-break-after: auto;\}

## Positioning elements

When you position elements, their initial containing block will be the page box in which they are placed. Thus, if you want the title of every slide to actually appear on the bottom of the slide, you would write something like:

h2 \{page-break-before: always; position: absolute; bottom: 0; right: 0;\}

This rule would place any h2 element at the bottom-right corner of the page box (slide) in which it appears. Of course, it's possible to position elements with respect to other elements instead of the page box. See Chapter 10 for details on positioning.

A fixed-position element, on the other hand, will appear in every page box in the slideshow, just as in the print medium. This means that you can take a single element, such as the document title, and put it on every slide, like this:

h1 \{position: fixed; top: 0; right: 0; font-size: $80 \%$; \}

This technique can be used to create running footers, graphical sidebars for every slide, and so on.

## Considerations for projection

It's often said that web designs should be flexible and able to adapt to any resolution-and that's certainly true in most cases. However, projection styling is not web styling, so it often makes sense for a projection style sheet to be created with a specific resolution in mind. As an example, most projectors (as of this writing) default to a resolution of $1024 \times 768$. If you know you'll be projecting at that size, it's logical to set up your CSS for that exact size. Font sizing, element placement, and so forth can all be tuned to create the best visual experience for the target resolution.

For that matter, you might create different style sheets for different resolutions: one for $800 \times 600$, another for $1024 \times 768$, and a third for $1280 \times 1024$, just to cover the most common bases. Figure $14-10$ shows a slide at $1024 \times 768$.

## How Far Can We Go?

- CSS looks simple, and in a basic sense it is
- It's also highly complex and gives rise to surprising effects

$\square$ Flowing text along a curve

$\square$ Translucency effects

$\square$ Popups menus without JavaScript

- With the right document and CSS, you can create a slideshow
- We still don't know the limits of CSS-driven design

Figure 14-10. A fully styled slide

Another thing to bear in mind is that projected documents are generally more readable for the audience if they employ high-contrast colors. This is particularly true since some projector bulbs aren't as bright as others, and dimmer bulbs call for even higher contrast. This also highlights (no pun intended) the fact that you have even less of a guarantee of color fidelity in projection situations than in normal web design (and that's not saying much).

## Aural Styles

Users who cannot see won't benefit from the visual styling that most of CSS enables. For these users, what matters is not the drop shadows or rounded corners, but the actual textual content of the page-which must be rendered audibly if they are to understand it. The blind are not the only user demographic that can benefit from aural rendering of web content. A user agent embedded in a car, for example, might use aural styles to enliven the reading of web content such as driving directions, or even the driver's email.

To meet the needs of these users, CSS2 introduced a section describing aural styles. As of this writing, there are two user agents that support, at least to some degree,
aural styles: Emacspeak and Fonix SpeakThis. In spite of this, CSS2.1 effectively deprecates the media type aural and all of the properties associated with it. The current specification includes a note to the effect that future versions of CSS are likely to use the media type speech to represent spoken renderings of documents, but it does not provide any details.

Due to this odd confluence of emerging implementation and deprecation, we will only briefly look at the properties of aural style sheets.

## Speaking

At the most basic level, you must determine whether a given element's content should be rendered aurally at all. In aural style sheets, this is handled with the property speak.



The default value, normal, is used to indicate that an element's content should be spoken. If an element's content should not be spoken for some reason, the value none is used. Even though an element's aural rendering may be suppressed using none, you may override the value on descendant elements, which would thus be rendered. In the following example, the text "Navigation:" would not be rendered aurally, but the text "Home" would be:



If an element and its descendants must be prevented from rendering aurally, use display: none instead. In this example, none of the content of the div will be rendered aurally (or in any other medium, for that matter):

<div style="display: none;">

Navigation:

<a href="home.html" style="speak: normal;">Home</a>

</div>

The third value of speak is spell-out, which will most likely be used in conjunction with acronyms or other content that should be spelled out. For example, the following fragment of markup would be rendered aurally as T-E-D-S, or "tee eee dee ess":

<acronym style="speak: spell-out;" title="Technology Evangelism and

Developer Support">TEDS</acronym>

## Punctuation and numbers

There are two other properties that affect the way in which element content is rendered aurally. The first affects the rendering of punctuation and is called (appropriately enough) speak-punctuation.



## speak-punctuation

Values: $\quad$ code $\mid$ none $\mid$ inherit

Initial value: none

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: As specified

Given the default value of none, punctuation is rendered aurally as pauses of appropriate lengths, although CSS does not define these lengths. To pick an example, the pause representing a period (and thus the end of a sentence) might be twice as long as the pause representing a comma. Pause lengths are likely to be language-dependent.

With the value code, punctuation is actually rendered aurally. Thus, the following example would be rendered as, "avast comma ye scalawags exclamation point":

<p style="speak-punctuation: code;">Avast, ye scalawags!</p>

To use another example, the following fragment might be rendered aurally as, "a left bracket href right bracket left curly brace color colon red semicolon right curly brace":

<code style="speak-punctuation: code;">a[href] \{color: red;\}</code>

Similar to affecting punctuation rendering, speak-numeral defines the method of speaking numbers.

The default value continuous means that the number is spoken as a whole number, whereas digits causes numbers to be read individually. Consider:

<p style="speak-numeral: continuous;">23</p>

<p style="speak-numeral: digits;">23</p>

## speak-numeral

Values: $\quad$ digits $\mid$ continuous $\mid$ inherit

Initial value: continuous

Applies to: All elements

Inherited: Yes

Computed value: As specified

The aural rendering of the first paragraph would be "twenty-three," whereas the second paragraph would be rendered as "two three." As with punctuation, numeric renderings are language-dependent but undefined.

## Speaking table headers

In the aural rendering of a table, it can be easy to lose track of what the cell data actually means. If you're on the 9th row of a 12-row table, and the 6th cell in that row is "21.77," what are the odds you'll remember what the 6th column represents? Will you even remember what the numbers in this row relate to? Table headers provide this information and are easy to check visually. To solve this problem in the aural medium, CSS2 introduced speak-header.



By default, a user agent will render the content of a table header only once, when the cell is encountered. The other alternative is to always render the table header information when a cell relating to that header is rendered.

Let's consider the following simple table as an example:





Without any styles applied, the aural rendering of this table would be, "Favorite Color Jim Joe Jane red green blue." You can probably figure out what all that means, but imagine a table containing the favorite colors of 10 or 20 people. Now, suppose you apply the following styles to this table:

\#colors \{speak-header: always; $\}$

\#headers \{speak: none; $\}$

The aural rendering of the table should then be, "Favorite Color Jim red Joe green Jane blue." This is much easier to understand, and it will continue to be-no matter how large the table might grow.



Note that the document language itself defines the method of determining an element's role as a table header. Markup languages may also have ways to associate header information with elements or groups of elements-for example, the attributes scope and axis in HTML4.

## Speech rate

In addition to ways to affect the style of speech, CSS also offers speech-rate, which is used to set the speed at which content is aurally rendered.



|  | speech-rate |  |
| :--- | :--- | :---: |
| Values: | <number> $\mid$ x-slow $\mid$ slow $\mid$ medium $\mid$ fast $\mid$ x-fast $\mid$ faster $\mid$ slower $\mid$ |  |
|  | inherit |  |
| Initial value: | medium |  |
| Applies to: | All elements |  |
| Inherited: | Yes |  |
| Computed value: | An absolute number |  |

The values are defined as follows:

<number>

Specifies the speaking rate in words per minute. This is likely to vary by language, since some languages are spoken more quickly than others.

$x$-slow

Equivalent to 80 words per minute.

Equivalent to 120 words per minute.

medium

Equivalent to 180-200 words per minute.

fast

Equivalent to 300 words per minute.

$x$-fast

Equivalent to 500 words per minute.

faster

Increases the current speech rate by 40 words per minute.

slower

Decreases the current speech rate by 40 words per minute.

Here are two examples of extreme changes in speech rate:

*.duh \{speech-rate: $x$-slow; $\}$

div\#disclaimer \{speech-rate: $x$-fast; $\}$

CSS does not define how the speech rate is altered. A user agent could draw out each word, stretch out the pauses between words, or both.

## Volume

In an aural medium, one of the most important aspects of presentation is the volume of the sound produced by the user agent. Enter the aptly named property, volume.



The values are defined as follows:

<number>

Provides a numeric representation of the volume. 0 corresponds to the minimum audible volume, which is not the same as being silent; 100 corresponds to the maximum comfortable volume.

<percentage>

Calculated as a percentage of the inherited value.
silent

No sound is produced, which is different from the numeric value 0 . This is the aural equivalent of visibility: hidden.

$x$-soft

Equivalent to the numeric value 0.

soft

Equivalent to the numeric value 25 .

medium

Equivalent to the numeric value 50 .

loud

Equivalent to the numeric value 75 .

$x$-loud

Equivalent to the numeric value 100.

It's important to note that the volume value (say that five times fast!) defines the median volume, not the precise volume of every sound produced. Thus, the content of an element with volume: 50; may well be rendered with sounds that go above and below that level, especially if the voice is highly inflected or has a dynamic range of sounds.

The numeric range is likely to be user-configured, since only an individual user can determine his minimum audible volume level ( 0 ) and maximum comfortable volume level (100). As an example, a user might decide that the minimum audible volume is a $34 \mathrm{~dB}$ tone, and the maximum comfortable volume is an $84 \mathrm{~dB}$ tone. This means there is a $50 \mathrm{~dB}$ range between 0 and 100 , and each increase of one in the value will mean a half-dB increase in the median volume. In other words, volume: soft; would translate to a median volume of $46.5 \mathrm{~dB}$.

Percentage values have an effect analogous to their effect in font-size: they increase or decrease the value based on the parent element's value. For example:



Given the audio range described before, the content of the div element here would be spoken with a median volume of $64 \mathrm{~dB}$. The exception is the big element, which is $125 \%$ of the parent's value of 60 . This calculates to 75 , which is equivalent to $71.5 \mathrm{~dB}$.

If a percentage value would place an element's computed numeric value outside the range of 0 through 100 , the value is clipped to the nearest value. Suppose you were to change the previous styles to read:

div.marine $\{$ volume: $60 ;\}$

big \{volume: $200 \%$;

This would cause the big element's volume value to be computed as 120; that value would then be clipped to 100 , which corresponds here to a median volume of $84 \mathrm{~dB}$.

The advantage of defining volume in this way is that it permits the same style sheet to serve in different environments. For example, the settings for 0 and 100 will be different in a library than they will be in a car, but the values will effectively correspond to the same intended auditory effects in each setting.

## Giving Voice

To this point, we've talked about ways to affect the aural presentation, but what we haven't discussed is a way to choose the voice used to aurally render content. Like font-family, CSS defines a property called voice-family.



As with font-family, voice-family allows the author to supply a comma-separated list of voices that can be used to render an element's content. The user agent looks for the first voice in the list and uses it if it's available. If not, the user agent looks for the next voice in the list, and so on, until it either finds a specific voice or runs out of specified voices.

Because of the way the value syntax is defined, you can provide a number of specific or generic families in any order. Therefore, you can end your value with a specific family instead of a generic one. For example:

h1 \{voice-family: Mark, male, Joe; \}

CSS2.x does not define generic family values, but mentions that male, female, and child are all possible. Therefore, you might style the elements of an XML document as follows:



The actual voice chosen to render a given element will affect the way the user perceives that element, since some voices will be pitched higher or lower than others, or may be more or less monotone. CSS provides ways to affect these aspects of a voice as well.

## Altering the Voice

Once you've directed the user agent to use a particular voice in the aural rendering of the content, you might want to alter some of its aspects. For example, a voice might sound right, except it's pitched too high for your liking. Another voice might be a little too "dynamic," but otherwise meets your needs. CSS defines properties to affect all of the vocal aspects.

## Changing the pitch

Obviously, different voices have different pitches. To pick the most basic of examples, male voices average around $120 \mathrm{~Hz}$, whereas female voices average in the vicinity of $210 \mathrm{~Hz}$. Thus, every voice family will have its own default pitch, which CSS allows authors to alter using the property pitch.



| pitch |  |
| :--- | :--- |
| Values: | <frequency $>\mid$ x-low $\mid$ low $\mid$ medium $\mid$ high $\mid$ x-high $\mid$ inherit |
| Initial value: | medium |
| Applies to: | All elements |
| Inherited: | Yes |
| Computed value: | The absolute frequency value |

There is no explicit definition of the keywords $x$-low through $x$-high, so all that can be said about them is that each one will be a higher pitch than the one before it. This is similar to the way the font-size keywords $\mathrm{xx}$-small through $\mathrm{xx}$-large are not precisely defined, but each must be larger than the one preceding it.

Frequency values are a different matter. If you define an explicit pitch frequency, the voice will be altered so that its average pitch matches the value you supply. For example:

h1 \{pitch: $150 \mathrm{~Hz}$;

The effects can be dramatic if an unexpected voice is used. Let's consider an example where an element is given two voice-family possibilities and a pitch frequency:

h1 \{voice-family: Jethro, Susie; pitch: $100 \mathrm{~Hz}$;

For the purposes of this example, assume that the default pitch of "Jethro" is $110 \mathrm{~Hz}$, and the default pitch for "Susie" is $200 \mathrm{~Hz}$. If "Jethro" gets picked, then h1 elements will be read with the voice pitched slightly lower than normal. If "Jethro" isn't available and "Susie" is used instead, there will be an enormous, and potentially bizarre, change from the voice's default.

Regardless of what pitch is used in an element's rendering, you can influence the dynamic range of the pitch by using the property pitch-range.



The purpose of pitch-range is to raise or lower the inflection in a given voice. The lower the pitch range, the closer all pitches will be to the average, resulting in a monotone voice. The default value, 50, yields "normal" inflections. Values higher than that will increase the degree of "animation" in the voice.

## Stress and richness

A companion property to pitch-range is stress, which is intended to help authors minimize or exaggerate the stress patterns in a language.



Every human language has, to some degree, stress patterns. In English, for example, sentences have different parts that call for different stress. The previous sentence might look something like this:



A style sheet defining stress levels for each portion of the sentence might say:

primary \{stress: 65; \}

secondary \{stress: $50 ;\}$

tertiary $\{$ stress: $33 ;\}$

This leads to a decrease in stress for the less important parts of a sentence, and a greater stress on the parts that are considered more important. stress values are language-dependent, so the same value may lead to different stress levels and patterns. CSS does not define such differences (which probably doesn't surprise you by now).

Similar in many ways to stress is richness.

|  | richness |
| :--- | :--- |
| Values: | <number> $\mid$ inherit |
| Initial value: | 50 |
| Applies to: | All elements |
| Inherited: | Yes |
| Computed value: | As specified |

The higher a voice's richness value, the greater its "brightness" and the more it will "carry" in a room. Lower values will lead to a softer, more "mellifluous" voice (to quote the CSS2 specification). Thus, an actor's soliloquy might be given richness: 80 ; and a sotto voce aside might get richness: 25 ; .

## Pauses and Cues

In visual design, you can draw extra attention to an element by giving it extra margins to separate it from everything else, or by adding borders. This draws the eye toward these elements. In aural presentation, the closest equivalent is the ability to insert pauses and audible cues around an element.

## Pauses

All spoken language relies on pauses of some form. The short gaps between words, phrases, and sentences are as critical to understanding the meaning as the words themselves. In a sense, pauses are like the auditory equivalent of margins, in that
both serve to separate the element from its surrounding content. In CSS, three properties can be used to insert pauses into a document: pause-before, pause-after, and pause.



With the <time> value format, you can express the length of a pause in either seconds or milliseconds. For example, let's say you want a full two-second pause after an h1 element. Either of the following rules have that effect:

h1 \{pause-after: $2 \mathrm{~s} ;$ \}

h1 \{pause-after: 2000ms; \} /* the same length of time as '2s' */

Percentages are a little trickier, as they are calculated in relation to a measure-implied value of speech-rate. No, really! Let's see how this works. First, consider the following:

h1 \{speech-rate: 180; \}

This means any h1 element will be aurally rendered at about three words per second. Now consider:

h1 \{speech-rate: 180; pause-before: 200\%; \}

The percentage is calculated based on the average word length. In this case, a word will take 333.33 milliseconds to speak, so $200 \%$ of that is 666.66 milliseconds. Put another way, there will be a pause before each $\mathrm{h} 1$ of about two-thirds of a second. If you alter the rule so the speech-rate value is 120 , the pause will be a full second long. The shorthand pause brings together pause-before and pause-after.

## pause

Values: $\quad[[<$ time $>\mid<$ percentage $>]\{1,2\}] \mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Computed value: See individual properties (pause-before, etc.)

If you supply only one value, it's taken as the pause value both before and after an element. If you supply two values, the first one is the pause before the element, and the second one is the pause after. Thus, the following rules are all equivalent:

pre $\{$ pause: $1 \mathrm{~s} ;\}$

pre $\{$ pause: $1 \mathrm{~s} 1 \mathrm{~s} ;\}$

pre $\{$ pause-before: 1 s; pause-after: $1 \mathrm{~s} ;\}$

## Cues

If pauses aren't enough to call attention to an element, you can insert audio cues before and after it, which are the auditory equivalent of borders. Like the pause properties, there are three cue properties: cue-before, cue-after, and cue.



By supplying the URI of an audio resource, the user agent is directed to load that resource and play it before (or after) an element. Suppose you want to precede each unvisited hyperlink in a document with a chime, and every visited link with a beep. The rules would look something like this:

a:link \{cue-before: url(chime.mp3);\}

a:visited \{cue-before: url(beep.wav); \}

The shorthand property cue acts as you'd expect.

|  | Cue |
| :--- | :--- |
| Values: | $[$ <cue-before> \|| <cue-after> $] \mid$ inherit |
| Initial value: | none |
| Applies to: | All elements |
| Inherited: | No |
| Computed value: | See individual properties (cue-before, etc.) |

As with pause, supplying a single value for cue means that value will be used for both the before and after cues. Supplying two values means the first is used for the before cue, and the second is used for the after cue. Therefore, the following rules are all equivalent:

a[href] \{cue: url(ping.mp3); \}

a[href] \{cue: url(ping.mp3) url(ping.mp3); \}

a[href] \{cue-before: url(ping.mp3); cue-after: url(ping.mp3);\}

## Pauses, cues, and generated content

Both pauses and cues are played "outside" any generated content. Consider:

h1 \{cue: url(trumpet.mp3); \}

h1:before \{content: "Behold! "; \}

h1:after \{content: ". Verily!";

<h1>The Beginning</h1>

The audio rendering of this element would be, roughly, "(trumpets) Behold! The Beginning. Verily! (trumpets)."

CSS does not specify whether pauses go "outside" cues or vice versa, so the behavior of auditory user agents in this regard cannot be predicted.

## Background Sounds

Visual elements can have backgrounds, so it's only fair that audible elements should be able to have them, too. In the aural medium, a background refers to playing a sound while the element is being spoken. The property used to accomplish this is play-during.

## play-during

Values: $\quad<$ uri> $[$ mix || repeat]? $\mid$ auto $\mid$ none $\mid$ inherit

Initial value: auto

Applies to: All elements

Inherited: No

Computed value: For < uri> values, the absolute URI; otherwise, as specified

The simplest example is playing a single sound at the beginning of an element's aural rendering:

h1 \{play-during: url(trumpets.mp3); \}

Given this rule, any h1 element would be spoken while the sound file trumpets.mp3 plays. The sound file is played once. If it is shorter than the time it takes to speak the
element's contents, it stops before the element is finished. If it's longer than the necessary time, the sound stops once all of the element's content has been spoken.

If you want a sound to repeat throughout the entire speaking of an element, add the keyword repeat. This is the auditory equivalent of background-repeat: repeat:

div.ocean \{play-during: url(wave.wav) repeat;\}

Like visible backgrounds, background sounds do not composite by default. Consider the following situation:



Here, chains.mp3 will play repetitively behind the text of the link, except for the text of the em element. For that text, the chains will not be audible; instead, bass.mp3 will be heard. The parent's background sound is not heard, just as its background would not be seen behind the em element if both elements had visible backgrounds.

If you want to combine the two, use the keyword mix:

a:link \{play-during: url(chains.mp3) repeat;\}

em \{play-during: url(bass.mp3) repeat mix; \}

Now, chains.mp3 will be audible behind all of the link text, including the text in the em element. For that element, both chains.mp3 and bass.mp3 will be heard mixed together.

The analogy to visible backgrounds breaks down with the value none. This keyword cuts off all background sounds, including any that may belong to ancestor elements. Thus, given the following rules, the em text will have no background sounds at allneither bass.mp3 nor chains.mp 3 will be heard:

a:link \{play-during: url(chains.mp3) repeat; \}

em \{play-during: none; $\}$

<a href="http://www.example.com/">This is a <em>really great</em> site!</a>

## Positioning Sounds

When only one person is speaking, the sound emanates from one point in space, unless of course that person is moving around. In a conversation involving multiple people, the sound of each voice will come from a different point in space.

With the availability of high-end audio systems and 3D sound, it should be possible to position sounds within that space. CSS2.x defines two properties to accomplish this, one of which defines the angle of a sound's source on a horizontal plane, and the second of which defines the source's angle on a vertical plane. The placement of sounds along the horizontal plane is handled using azimuth.

## azimuth

Values: $\quad$ <angle> $\mid[[$ left-side $\mid$ far-left $\mid$ left $\mid$ center-left $\mid$ center $\mid$ center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards | inherit

Initial value: center

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: Normalized angle

Angle values can come in three units: deg (degrees), grad (grads), and rad (radians). The possible ranges for these unit types are 0-360deg, 0-400grad, and 0-6.2831853rad. Negative values are permitted, but they are recalculated as positive values. For example, $-45 \mathrm{deg}$ is equivalent to $315 \mathrm{deg}(360-45)$, and -50grad would be the same as 350grad.

Most of the keywords are simply equivalents of angle values. These are shown in Table 14-1, using degrees as the angle value of choice, and illustrated visually in Figure 14-11. The last column of Table 14-1 shows the equivalents of the keywords in the first column being used in conjunction with behind.

Table 14-1. azimuth keyword and angle equivalents

| Keyword | Angle | Behind |
| :--- | :--- | :--- |
| center | 0 | 180deg -180deg |
| center-right | $20 \mathrm{deg}-340 \mathrm{deg}$ | 160deg -200deg |
| right | $40 \mathrm{deg}-320 \mathrm{deg}$ | 140deg -220deg |
| far-right | $60 \mathrm{deg}-300 \mathrm{deg}$ | 120deg -240deg |
| right-side | $90 \mathrm{deg}-270 \mathrm{deg}$ | 90deg -270deg |
| center-left | $340 \mathrm{deg}-20 \mathrm{deg}$ | $200 \mathrm{deg}-160 \mathrm{deg}$ |
| left | $320 \mathrm{deg}-40 \mathrm{deg}$ | $220 \mathrm{deg}-140 \mathrm{deg}$ |
| far-left | $300 \mathrm{deg}-60 \mathrm{deg}$ | 240deg -120deg |
| left-side | $270 \mathrm{deg}-90 \mathrm{deg}$ | 270deg -90deg |



Note that the keyword behind cannot be combined with an angle value. It can be used only in conjunction with one of the keywords listed in Table 14-1.

There are two keywords in addition to those listed in Table 14-1: leftwards and rightwards. The effect of the former is to subtract 20deg from the current angle value of azimuth, and the latter adds 20deg to the value. For example:

body \{azimuth: right-side; \} /* equivalent to 90deg */

h1 \{azimuth: leftwards; \}



Figure 14-11. The horizontal plane, seen from above

The computed angle value of azimuth for the h1 element is 70deg. Now consider the following situation:

body \{azimuth: behind;\} /* equivalent to 180deg */

h1 \{azimuth: leftwards;\} /* computes to 160deg */

The effect of leftwards, given these rules, is to make the sound move to the right, not the left. It's odd, but that's how CSS2 is written. Similarly, using rightwards in the previous example would cause the h1 element's sound source to move 20 degrees to the left. Much like azimuth, only simpler, is elevation, which places sounds in the vertical plane.

|  | elevation |
| :--- | :--- |
| Values: | <angle> $\mid$ below $\mid$ level $\mid$ above $\mid$ higher $\mid$ lower $\mid$ inherit |
| Initial value: | level |
| Applies to: | All elements |
| Inherited: | Yes |
| Computed value: | Normalized angle |

Like azimuth, elevation accepts degree, grad, and radian angles. The three angleequivalent keywords are above (90 degrees), level (0), and below ( -90 degrees). These are illustrated in Figure 14-12.



Figure 14-12. The vertical plane, seen from the right side

The relative-placement keywords, higher and lower, either add or subtract 10 degrees from the current elevation angle. Therefore, in the following example, h1 elements that are children of the body will be placed 10 degrees above the horizontal plane:

body \{elevation: level;\} /* equivalent to 0 */

body > h1 \{elevation: higher;\}

## Combining azimuth with elevation

When values for azimuth and elevation are taken together, they define a point in an imaginary sphere whose center is the user. Figure 14-13 illustrates this sphere, along with some cardinal points and the values that would place sounds in those positions.

Imagine a point halfway between straight ahead of you and your immediate right as you sit in a chair, and halfway between the horizon and the zenith. This point could be described as azimuth: 45deg; elevation: 45deg; Now imagine a sound source at



Figure 14-13. Three-dimensional aural space

the same elevation but located halfway between your immediate left and a point directly behind you. This source could be described in any of the following ways:

azimuth: -135deg; elevation: 45deg;

azimuth: 215deg; elevation: 45deg;

azimuth: left behind; elevation: 45deg;

It is entirely possible that positioned sounds would assist a user in separating cues from other audio sources, or could help to create positionally separate special material:

a[href] \{cue: url(ping.wav); azimuth: behind; elevation: 30deg;\}

voices.onhigh \{play-during: url(choir.mp3); elevation: above; \}

## Summary

Although the first stage of the Web's development was primarily visual in nature, the need to provide web content in other media led to the introduction of medium-specific styling in CSS. The ability to take the same document and customize its presentation in a manner best suited to different output media is deeply powerful. Although its most common application is to create "printer-friendly" styles for documents, we've also seen how projection styles can be used to create slideshows with Opera.

While aural styles would be very useful for blind users, there are only two programs as of this writing that support even a fragment of this portion of CSS, and the media type aural defined in CSS2.x will not be carried forward to future versions of CSS. Instead, the media type speech has been set aside for future work in auditory rendering of documents.

## APPENDIX A

## Property Reference

## Visual Media

## background

This is a shorthand method to express all of the individual background properties within a single declaration. Use of this property is generally encouraged over the individual properties, as it has a slightly better support profile in older browsers and doesn't take as long to type.

Values: [ <background-color> || <background-image> || <background-repeat> || <background-attachment> || <background-position> ] | inherit

Initial value: Refer to individual properties

Applies to: $\quad$ All elements

Inherited: No

Percentages: Values are allowed for <background-position>

Computed value: See individual properties

## background-attachment

This property defines whether the background image scrolls along with the element when the document is scrolled. This can be used to create "aligned" backgrounds; see Chapter 9 for more details.

Values:

scroll | fixed | inherit

Initial value: scroll

Applies to: $\quad$ All elements

Inherited: No

Computed value: As specified

## background-color

This sets a solid color for the background of the element. This color fills the content, padding, and border areas of the element, extending to the outer edge of the element's border. Borders that have transparent sections, such as dashed borders, will show the background color through the transparent sections.

Values: $\quad<$ color> $\mid$ transparent $\mid$ inherit

Initial value: transparent

Applies to: $\quad$ All elements

Inherited: No

Computed value: As specified

## background-image

This places an image in the background of the element. Depending on the value of background-repeat, the image may tile infinitely, along one axis, or not at all. The initial background image (the origin image) is placed according to the value of backgroundposition.

Values:

<uri> | none | inherit

Initial value: none

Applies to: All elements

Inherited: No

Computed value: Absolute URI

## background-position

This property sets the position of the background's origin image (as defined by backgroundimage); this is the point from which any background repetition will occur.

| Values: | [<epercentage $>]$ <br> $<$ length> $\mid$ top $\mid$ center $\mid$ bottom]?] $\mid[[$ left $\mid$ center $\mid$ right] \|| [top <br> center $\mid$ bottom]] \| inherit |
| :---: | :---: |
| Initial value: | $0 \% 0 \%$ |
| Applies to: | Block-level and replaced elements |
| Inherited: | No |
| Percentages: | Refer to the corresponding point on both the element and the origin <br> image |

Computed value: The absolute length offsets, if <length> is specified; otherwise, percentage values

## background-repeat

This defines the tiling pattern for the background image. Note that the axis-related repeat values actually cause repetition in both directions along the relevant axis. The repetition begins from the origin image, which is defined as the value of background-image and is placed according to the value of background-position.

Values:

repeat | repeat-x | repeat-y | no-repeat | inherit

Initial value: repeat

Applies to: All elements

Inherited: No

Computed value: As specified

## border

This is a shorthand property that defines the width, color, and style of an element's border. Note that while none of the values are actually required, omitting a border style will result in no border being applied because the default border style is none.

Values: $\quad[$ <border-width> || <border-style> || <border-color> $] \mid$ inherit

Initial value: Refer to individual properties

Applies to: All elements

Inherited: No

Computed value: As specified

## border-bottom

This shorthand property defines the width, color, and style of the bottom border of an element. As with border, omission of a border style will result in no border appearing.

Values: $\quad[$ <border-width> || <border-style> || <border-color> ] $\mid$ inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (border-width, etc.)

## border-bottom-color

This property sets the color for the visible portions of the bottom border of an element. Only a solid color can be defined, and the border's style must be a value other than none or hidden for any border to appear.

Values: $\quad<$ color> $\mid$ transparent $\mid$ inherit

Initial value: The value of color for the element

Applies to: All elements

Inherited: No

Computed value: If no value is specified, use the computed value of the property color for the same element; otherwise, as specified

## border-bottom-style

This defines the style for the bottom border of an element. The value must be something other than none for any border to appear. In CSS1, HTML user agents were only required to support solid and none.

Values: $\quad$ none $\mid$ hidden $\mid$ dotted $\mid$ dashed $\mid$ solid $\mid$ double $\mid$ groove $\mid$ ridge $\mid$ inset $\mid$ outset | inherit

Initial value: none

Applies to: $\quad$ All elements

Inherited: No

Computed value: As specified

## border-bottom-width

This sets the width for the bottom border of an element, which will take effect only if the border's style is something other than none. If the border style is none, the border width is effectively reset to 0 . Negative length values are not permitted.

Values:

$$
\text { thin } \mid \text { medium } \mid \text { thick } \mid<\text { length> }>\text { inherit }
$$

Initial value:

medium

Applies to: All elements

Inherited: No

Computed value: Absolute length; 0 if the style of the border is none or hidden

## border-color

This shorthand property sets the color for the visible portions of the overall border of an element or sets a different color for each of the four sides. Remember that a border's style must be something other than none or hidden for any border to appear.

Values: $\quad[<$ color $>\mid$ transparent $]\{1,4\} \mid$ inherit

Initial value: Not defined for shorthand properties

Applies to: $\quad$ All elements

Inherited: No

Computed value: See individual properties (border-top-color, etc.)

## border-left

This shorthand property defines the width, color, and style of the left border of an element. As with border, omission of a border style will result in no border appearing.

Values: $\quad[$ <border-width> || <border-style> || <border-color> $]$ | inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (border-width, etc.)

## border-left-color

This property sets the color for the visible portions of the left border of an element. Only a solid color can be defined, and the border's style must be something other than none or hidden for any border to appear.

Values: <color> | transparent | inherit

Initial value: The value of color for the element

Applies to: All elements

Inherited: No

Computed value: If no value is specified, use the computed value of the property color for the same element; otherwise, as specified

## border-left-style

This defines the style for the left border of an element. The value must be something other than none for any border to appear. In CSS1, HTML user agents were only required to support solid and none.
Values:
none | hidden | dotted $\mid$ dashed $\mid$ solid $\mid$ double $\mid$ groove $\mid$ ridge | inset | outset | inherit
Initial value: none
Applies to: All elements
Inherited: No
Computed value: As specified

## border-left-width

This sets the width for the left border of an element, which will take effect only if the border's style is something other than none. If the border style is none, the border width is effectively reset to 0 . Negative length values are not permitted.

Values: $\quad$ thin $\mid$ medium $\mid$ thick $\mid<$ length $>\mid$ inherit

Initial value: medium

Applies to: All elements

Inherited: No

Computed value: Absolute length; 0 if the style of the border is none or hidden

## border-right

This shorthand property defines the width, color, and style of the right border of an element. As with border, omission of a border style will result in no border appearing.

Values: $\quad[$ <border-width> || <border-style $>||$ <border-color> $] \mid$ inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (border-width, etc.)

## border-right-color

This property sets the color for the visible portions of the right border of an element. Only a solid color can be defined, and the border's style must be something other than none or hidden for any border to appear.

Values:

$$
\text { <color> | transparent | inherit }
$$

Initial value: The value of color for the element

Applies to: All elements

Inherited: No

Computed value: If no value is specified, use the computed value of the property color for the same element; otherwise, as specified

## border-right-style

This defines the style for the right border of an element. The value must be something other than none for any border to appear. In CSS1, HTML user agents were only required to support solid and none.
Values: none | hidden | dotted $\mid$ dashed $\mid$ solid $\mid$ double $\mid$ groove $\mid$ ridge | inset $\mid$ outset | inherit
Initial value: none
Applies to: All elements
Inherited: No
Computed value: As specified

## border-right-width

This sets the width for the right border of an element, which will only take effect if the border's style is something other than none. If the border style is none, the border width is effectively reset to 0 . Negative length values are not permitted.

## Values:

 thin | medium | thick | <length> | inheritInitial value: medium

Applies to: $\quad$ All elements

Inherited: No

Computed value: Absolute length; 0 if the style of the border is none or hidden

## border-style

This shorthand property can be used to set the styles for the overall border of an element, or for each side individually. The value of any border must be something other than none for the border to appear.

Values: $\quad \quad[$ none $\mid$ hidden $\mid$ dotted $\mid$ dashed $\mid$ solid $\mid$ double $\mid$ groove $\mid$ ridge $\mid$ inset $\mid$ outset $]\{1,4\} \mid$ inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (border-top-style, etc.)

Note: $\quad$ In CSS1, HTML user agents were only required to support solid and none; the rest of the values (except for hidden) may be interpreted as solid

## border-top

This shorthand property defines the width, color, and style of the top border of an element. As with border, omission of a border style will result in no border appearing.

Values: $\quad[$ < border-width> $\mid$ < <border-style> $\mid$ < <border-color> ] | inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (border-width, etc.)

## border-top-color

This property sets the color for the visible portions of the top border of an element. Only a solid color can be defined, and the border's style must be something other than none or hidden for any border to appear.

Values: $\quad<$ color> $\mid$ transparent $\mid$ inherit

Initial value: The value of color for the element

Applies to: All elements

Inherited: No

Computed value: If no value is specified, use the computed value of the property color for the same element; otherwise, as specified

## border-top-style

This defines the style for the top border of an element. The value must be something other than none for any border to appear. In CSS1, HTML user agents were only required to support solid and none.

Values:

none | hidden | dotted $\mid$ dashed $\mid$ solid $\mid$ double $\mid$ groove $\mid$ ridge | inset | outset | inherit

Initial value: none

Applies to: All elements

Inherited: No

Computed value: As specified

## border-top-width

This sets the width for the top border of an element, which will only take effect if the border's style is something other than none. If the style is none, the width is effectively reset to 0 . Negative length values are not permitted.
Values: thin | medium | thick | <length> | inherit
Initial value: medium
Applies to: All elements
Inherited: No
Computed value: Absolute length; 0 if the style of the border is none or hidden

## border-width

This shorthand property can be used to set the width for the overall border of an element or for each side individually. The width will take effect for a given border only if the border's style is something other than none. If the border style is none, the border width is effectively reset to 0 . Negative length values are not permitted.

## Values: [ thin | medium | thick $\mid<$ length> ] \{1,4\} | inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (border-top-style, etc.)

## bottom

This property defines the offset between the bottom outer margin edge of a positioned element and the bottom edge of its containing block.

Values: $\quad<$ length> $\mid$ <percentage> $\mid$ auto $\mid$ inherit

Initial value: auto

Applies to: Positioned elements (that is, elements for which the value of position is something other than static)

Inherited: No

Percentages: Refer to the height of the containing block

Computed value: For relatively positioned elements, see Note; for static elements, auto; for length values, the corresponding absolute length; for percentage values, the specified value; otherwise, auto

Note: $\quad$ For relatively positioned elements, if both bottom and top are auto, their computed values are both 0 ; if one of them is auto, it becomes the negative of the other; if neither is auto, bottom will become the negative of the value of top

## clear

This defines the sides of an element on which no floating elements may appear. In CSS1 and CSS2, this is accomplished by automatically increasing the top margin of the cleared element. In CSS2.1, clearance space is added above the element's top margin, but the margin itself is not altered. In either case, the end result is that the element's top outer border edge is just below the bottom outer margin edge of a floated element on the declared side.

Values: $\quad$ left $\mid$ right $\mid$ both $\mid$ none $\mid$ inherit

Initial value: none

Applies to: Block-level elements

Inherited: No

Computed value: As specified

## clip

This is used to define a clipping rectangle inside of which the content of an absolutely positioned element is visible. Content outside this clipping area is treated according to the value of overflow. The clipping area can be smaller or larger than the content area of the element.

Values: $\quad \operatorname{rect}($ top, right, bottom, left) $\mid$ auto $\mid$ inherit

Initial value: auto

Applies to: Absolutely positioned elements (in CSS2, clip applied to block-level and replaced elements)

Inherited: No

Computed value: For a rectangle, a set of four computed lengths representing the edges of the clipping rectangle; otherwise, as specified

## color

This property sets the foreground color of an element, which in HTML rendering means the text of an element; raster images are not affected by color. This is also the color applied to any borders of the element, unless overridden by border-color or one of the other border color properties (border-top-color, etc.).

Values: $\quad<$ color> $\mid$ inherit

Initial value: User agent-specific

Applies to: All elements

Inherited: Yes

Computed value: As specified

## content

This is the property used to define the generated content placed before or after an element. By default, this is likely to be inline content, but the type of box the content creates can be controlled using the property display.

Values:

normal | [ <string> | <uri> | <counter> | attr(<identifier>) | open-quote | close-quote | no-open-quote | no-close-quote ]+| inherit

Initial value: normal

Applies to: $\quad$ :before and : after pseudo-elements

Inherited: No

Computed value: For <uri> values, an absolute URI; for attribute references, the resulting string; otherwise, as specified

## counter-increment

With this property, counters can be incremented (or decremented) by any value, positive or negative. If no <integer> is supplied, it defaults to 1.

Values: $\quad[<$ identifier><integer>? ] $+\mid$ none $\mid$ inherit

Initial value: User agent-dependent

Applies to: All elements

Inherited: No

Computed value: As specified

## counter-reset

With this property, counters can be set or reset to any value, positive or negative. If no <integer> is supplied, it defaults to 0 .

Values: $\quad[<$ identifier><integer>? ] $+\mid$ none $\mid$ inherit

Initial value: User agent-dependent

Applies to: All elements

Inherited: No

Computed value: As specified

## cursor

This defines the cursor shape to be used when a mouse pointer is placed within the boundary of an element (although CSS2.1 does not define which edge creates this boundary).

Values: $\quad\left[[<\text { uri }>,]^{*}[\right.$ auto $\mid$ default $\mid$ pointer $\mid$ crosshair $\mid$ move $\mid$ e-resize $\mid$ ne-resize $\mid$ nw-resize $\mid$ n-resize $\mid$ se-resize $\mid$ sw-resize $\mid$ s-resize | w-resize| text | wait | help | progress ]] | inherit

Initial value: auto

Applies to: All elements

Inherited: Yes

Computed value: For <uri> values, an absolute URI; otherwise, as specified

## direction

This property specifies the base writing direction of blocks and the direction of embeddings and overrides for the Unicode bidirectional algorithm. User agents that do not support bidirectional text are permitted to ignore this property.

Values: $\quad \operatorname{ltr}|\mathrm{rtl}|$ inherit

Initial value: $\quad$ ltr

Applies to: All elements

Inherited: Yes

Computed value: As specified

## display

This is used to define the kind of display box an element generates during layout. Gratuitous use of display with a document type such as HTML can be dangerous, as it upsets
the display hierarchy already defined in HTML. In the case of XML, which has no such built-in hierarchy, display is indispensable.

Values:



Initial value: inline

Applies to: All elements

Inherited: No

Computed value: Varies for floated, positioned, and root elements (see CSS2.1, section 9.7); otherwise, as specified

Note: $\quad$ The values compact and marker appeared in CSS2 but were dropped from CSS2.1 due to a lack of widespread support

## float

This defines the direction in which an element is floated. It has traditionally been applied to images to let text flow around them, but in CSS, any element may be floated. A floated element will generate a block-level box no matter what kind of element it may be. Floated nonreplaced elements should be given an explicit width; otherwise, they may tend to become as narrow as possible.
Values: left | right | none | inherit
Initial value: none
Applies to: All elements
Inherited: No
Computed value: As specified

## font

This is a shorthand property used to set two or more aspects of an element's font all at once. It can also be used to set the element's font to match an aspect of the user's computing environment using keywords such as icon. Note that if these keywords are not used, the minimum font value must include the font size and family.

Values:

[[ <font-style> || <font-variant> || <font-weight> ]? <font-size>

[ / <line-height> ]? <font-family>] | caption | icon | menu | message-box | small-caption | status-bar | inherit

Initial value: Refer to individual properties

Applies to: All elements

Inherited: Yes

Percentages: Calculated with respect to the parent element for <font-size> and with respect to the element's < font-size $>$ for <line-height>

Computed value: See individual properties (font-style, etc.)

## font-family

This defines a font family to be used in the display of an element's text. Note that use of a specific font family (e.g., Geneva) is wholly dependent on that family being available on a user's machine; no font downloading is implied by this property. Therefore, the use of generic family names as a fallback is strongly encouraged.

Values:

[[<family-name> | < generic-family>],]* [<family-name> |

$<$ generic-family $>] \mid$ inherit

Initial value: User agent-specific

Applies to: All elements

Inherited: Yes

Computed value: As specified

## font-size

This sets the size of the font for an element. Note that it actually sets the height of the character boxes in the font; the actual character glyphs may be taller or shorter than these boxes (usually shorter). Each keyword must be larger than the next smallest keyword and smaller than the next biggest keyword. Negative length and percentage values are not permitted.

Values: $\quad x x$-small $\mid x$-small $\mid$ small $\mid$ medium $\mid$ large $\mid x$-large $\mid x x$-large $\mid$ smaller $\mid$ larger $\mid$ <length> $\mid$ <percentage> $\mid$ inherit

Initial value: medium

Applies to: All elements

Inherited: Yes

Percentages: Calculated with respect to the parent element's font size

Computed value: An absolute length

## font-style

This sets the font to use an italic, oblique, or normal font face. Italic text is generally defined as a separate face within the font family. It is theoretically possible for a user agent to compute a slanted font face from the normal face.

Values: italic | oblique | normal | inherit

Initial value:

normal

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: As specified

## font-variant

This property is basically used to define small-caps text. It is theoretically possible for a user agent to compute a small-caps font face from the normal face.

Values:

Initial value:

Applies to:

Inherited:

Computed value: As specified

## font-weight

This property sets the font weight used in rendering an element's text. The numeric value 400 is equivalent to the keyword normal, and 700 is equivalent to bold. Each numeric value must be at least as light as the next lowest number and at least as heavy as the next highest number.

Values: $\quad$ normal $\mid$ bold $\mid$ bolder $\mid$ lighter $|100| 200|300|$ | 400 | 500 | 600 | $700 \mid$ 800 | 900 | inherit

Initial value: normal

Applies to: All elements

Inherited: Yes

Computed value: One of the numeric values (100, etc.), or one of the numeric values plus one of the relative values (bolder or lighter)

## height

This defines the height of an element's content area, outside of which padding, borders, and margins are added. This property is ignored for inline nonreplaced elements. Negative length and percentage values are not permitted.

Values: <length> $\mid$ <percentage $>$ auto | inherit

Initial value: auto

Applies to: $\quad$ Block-level and replaced elements

Inherited: No

Percentages: Calculated with respect to the height of the containing block

Computed value: For auto and percentage values, as specified; otherwise, an absolute length, unless the property does not apply to the element (then auto)

## left

This property defines the offset between the left outer margin edge of a positioned element and the left edge of its containing block.

Values: $\quad<$ length $>\mid$ < percentage $>\mid$ auto $\mid$ inherit

Initial value: auto

Applies to: Positioned elements (that is, elements for which the value of position is something other than static)

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For relatively positioned elements, see Note; for static elements, auto; for length values, the corresponding absolute length; for percentage values, the specified value; otherwise, auto

Note: $\quad$ For relatively positioned elements, the computed value of left always equals right

## letter-spacing

This defines the amount of whitespace to be inserted between the character boxes of text. Since character glyphs are typically narrower than their character boxes, length values create a modifier to the usual spacing between letters. Thus, normal is synonymous with 0 . Negative length values are permitted and will cause letters to bunch closer together.

Values:

<length> | normal | inherit

Initial value:

normal

Applies to: All elements

Inherited: Yes

Computed value: For length values, the absolute length; otherwise, normal

## line-height

This property influences the layout of line boxes. When applied to a block-level element, it defines the minimum distance between baselines within that element, but not the maximum. The difference between the computed values of line-height and font-size (called "leading" in CSS) is split in half and added to the top and bottom of each piece of content in a line of text. The shortest box that can enclose all of those pieces of content is the line box. A raw number value assigns a scaling factor, which is inherited instead of a computed value. Negative values are not permitted.

Values: $\quad<$ length $>\mid$ <percentage> $\mid<$ number $>\mid$ normal $\mid$ inherit

Initial value: normal

Applies to: All elements (but see text regarding replaced and block-level elements)

Inherited: Yes

Percentages: Relative to the font size of the element

Computed value: For length and percentage values, the absolute value; otherwise, as specified

## list-style

This is a shorthand property that condenses all the other list-style properties. Because it applies to any element that has a display of list-item, it will apply only to li elements in ordinary HTML and XHTML, although it can be applied to any element and inherited by list-item elements.

Values: $\quad[<$ list-style-type $>||$ list-style-image $>||$ <ist-style-position $>]$ | inherit

Initial value: Refer to individual properties

Applies to: Elements whose display value is list-item

Inherited: Yes

Computed value: See individual properties

## list-style-image

This specifies an image to be used as the marker on an ordered or unordered list item. The placement of the image with respect to the content of the list item can be broadly controlled using list-style-position.

Values: $\quad<$ uri> $\mid$ none $\mid$ inherit

Initial value: none

Applies to: Elements whose display value is list-item

Inherited: Yes

Computed value: For <uri> values, the absolute URI; otherwise, none

## list-style-position

This property is used to declare the position of the list marker with respect to the content of the list item. Outside markers are placed some distance from the border edge of the list item, but the distance is not defined in CSS. Inside markers are treated as though they were an inline element inserted at the beginning of the list item's content.

Values: $\quad$ inside $\mid$ outside $\mid$ inherit

Initial value: outside

Applies to: Elements whose display value is list-item

Inherited: Yes

Computed value: As specified

## list-style-type

This is used to declare the type of marker system to be used in the presentation of a list.

| CSS2.1 values: | disc \| circle | square | decimal | decimal-leading-zero | lower-roman <br> upper-roman \| lower-greek | lower-latin | upper-latin | armenian <br> georgian \| none | inherit |
| :---: | :---: |
| CSS2 values: | disc \| circle | square | decimal | decimal-leading-zero | upper-alpha <br> lower-alpha \| upper-roman | lower-roman | lower-greek | hebrew | <br> armenian \| georgian | cjk-ideographic | hiragana | katakana | <br> hiragana-iroha \| none | inherit |
| Initial value: | disc |
| Applies to: | Elements whose display value is list-item |
| Inherited: | Yes |

## margin

This shorthand property sets the width of the overall margin for an element or sets the widths of each individual side margin. Vertically adjacent margins of block-level elements are collapsed, whereas inline elements effectively do not take top and bottom margins. The left and right margins of inline elements do not collapse, nor do margins on floated elements. Negative margin values are permitted, but use them with caution.

Values: $\quad[<$ length $>\mid<$ percentage $>\mid$ auto $]\{1,4\} \mid$ inherit

Initial value: Not defined

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: See individual properties

## margin-bottom

This sets the width of the bottom margin for an element. Negative values are permitted, but use them with caution.

Values: $\quad<$ length> $\mid<$ percentage $>\mid$ auto $\mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentages, as specified; for length values, the absolute length

## margin-left

This sets the width of the left margin for an element. Negative values are permitted, but use them with caution.

Values: $\quad<$ length $>\mid$ <percentage> $\mid$ auto $\mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentages, as specified; for length values, the absolute length

## margin-right

This sets the width of the right margin for an element. Negative values are permitted, but use them with caution.

Values:

$$
\text { <length> } \mid<\text { percentage }>\mid \text { auto } \mid \text { inherit }
$$

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentages, as specified; for length values, the absolute length

## margin-top

This sets the width of the top margin for an element. Negative values are permitted, but use them with caution.

Values: $\quad<$ length $>\mid$ <percentage> $\mid$ auto $\mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentages, as specified; for length values, the absolute length

## max-height

The value of this property sets a maximum constraint on the height of the element. Thus, the element can be shorter than the specified value, but not taller. Negative values are not permitted.

Values: $\quad \quad<$ length $>\mid$ <percentage $>\mid$ none $\mid$ inherit

Initial value: none

Applies to: All elements except inline nonreplaced elements and table elements

Inherited: No

Percentages: Refer to the height of the containing block

Computed value: For percentages, as specified; for length values, the absolute length; otherwise, none

## max-width

The value of this property sets a maximum constraint on the width of the element. Thus, the element can be narrower than the specified value, but not wider. Negative values are not permitted.

Values: $\quad<$ length $>\mid$ < percentage $>\mid$ none $\mid$ inherit

Initial value: none

Applies to: All elements except inline nonreplaced elements and table elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentages, as specified; for length values, the absolute length; otherwise, none

## min-height

The value of this property sets a minimum constraint on the height of the element. Thus, the element can be taller than the specified value, but not shorter. Negative values are not permitted.

Values: $\quad<$ length $>\mid$ < percentage $>\mid$ inherit

Initial value: 0

Applies to: All elements except inline nonreplaced elements and table elements

Inherited: No

Percentages: Refer to the height of the containing block

Computed value: For percentages, as specified; for length values, the absolute length

## min-width

The value of this property sets a minimum constraint on the width of the element. Thus, the element can be wider than the specified value, but not narrower. Negative values are not permitted.

Values: $\quad<$ length $>\mid<$ percentage $>\mid$ inherit

Initial value: 0

Applies to: All elements except inline nonreplaced elements and table elements

Inherited: No

Percentages: refer to the width of the containing block

Computed value: For percentages, as specified; for length values, the absolute length; otherwise, none

## outline

This shorthand property is used to set the overall outline for an element. Outlines can be of irregular shape, and they do not change or otherwise affect the placement of elements.

Values: $\quad[$ <outline-color> || <outline-style> || <outline-width> ] | inherit

Initial value: Not defined for shorthand properties

Applies to: All elements

Inherited: No

Computed value: See individual properties (outline-color, etc.)

## outline-color

This property sets the color for the visible portions of the overall outline of an element. Remember that an outline's style must be something other than none for any border to appear.

Values: $\quad<$ color $>\mid$ invert $\mid$ inherit

Initial value: invert (or user agent-specific; see text)

Applies to: All elements

Inherited: No

Computed value: As specified

## outline-style

This property is used to set the style for the overall border of an element. The style must be something other than none for any outline to appear.

Values: $\quad$ none $\mid$ dotted $\mid$ dashed $\mid$ solid $\mid$ double $\mid$ groove $\mid$ ridge $\mid$ inset $\mid$ outset $\mid$ inherit

Initial value: none

Applies to: All elements

Inherited: No

Computed value: As specified

## outline-width

This property sets the width for the overall outline of an element. The width will take effect only for a given outline if the outline's style is something other than none. If the style is none, the width is effectively reset to 0 . Negative length values are not permitted.

Values: thin $\mid$ medium $\mid$ thick $\mid<$ length $>\mid$ inherit

Initial value: medium

Applies to: All elements

Inherited: No

Computed value: Absolute length; 0 if the style of the border is none or hidden

## overflow

This defines what happens to content that overflows the content area of an element. For the value scroll, user agents are supposed to provide a scrolling mechanism whether or not it is actually needed; thus, for example, scrollbars would appear even if all content can fit within the element box.

Values: visible | hidden | scroll | auto | inherit

Initial value: visible

Applies to: $\quad$ Block-level and replaced elements

## Inherited: No

Computed value: As specified

## padding

This shorthand property sets the width of the overall padding for an element or sets the widths of each individual side padding. Padding set on inline nonreplaced elements does not affect line-height calculations; therefore, such an element with both padding and a background may visibly extend into other lines and potentially overlap other content. The background of the element will extend throughout the padding. Negative padding values are not permitted.

Values:

$[<$ length> $\mid<$ percentage $>]\{1,4\} \mid$ inherit

Initial value: Not defined for shorthand elements

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: See individual properties (padding-top, etc.)

Note: $\quad$ Padding can never be negative

## padding-bottom

This property sets the width of the bottom padding for an element. Bottom padding set on inline nonreplaced elements does not affect line-height calculations; therefore, such an element with both bottom padding and a background may visibly extend into other lines and potentially overlap other content. Negative padding values are not permitted.

Values:

$$
\text { <length }>\mid \text { <percentage> } \mid \text { inherit }
$$

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentage values, as specified; for length values, the absolute length

Note: $\quad$ Padding can never be negative

## padding-left

This property sets the width of the left padding for an element. Left padding set for an inline nonreplaced element will appear only on the left edge of the first inline box generated by the element. Negative padding values are not permitted.

Values: $\quad<$ length $>\mid<$ percentage $>\mid$ inherit

Initial value: 0

Applies to: $\quad$ All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentage values, as specified; for length values, the absolute length

Note: $\quad$ Padding can never be negative

## padding-right

This property sets the width of the right padding for an element. Right padding set for an inline nonreplaced element will appear only on the right edge of the last inline box generated by the element. Negative padding values are not permitted.

Values: $\quad<$ length> $\mid<$ percentage $>\mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentage values, as specified; for length values, the absolute length

Note: $\quad$ Padding can never be negative

## padding-top

This property sets the width of the top padding for an element. Top padding set on inline nonreplaced elements does not affect line-height calculations; therefore, such an element with both top padding and a background may visibly extend into other lines and potentially overlap other content. Negative padding values are not permitted.

Values: $\quad<$ length> $\mid$ <percentage> $\mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For percentage values, as specified; for length values, the absolute length

Note: $\quad$ Padding can never be negative

## position

This defines the positioning scheme used to lay out an element. Any element may be positioned, although elements positioned with absolute or fixed will generate a block-level box no matter what kind of element they are. An element that is relatively positioned is offset from its default placement in the normal flow.

Values:

static | relative | absolute | fixed | inherit

Initial value: static

Applies to: All elements

Inherited: No

Computed value: As specified

## quotes

This property is used to determine the quotation pattern used with quotes and nested quotes. The actual quote marks are inserted via the property content.

Values: $\quad[<$ string>< <string>]+ $\mid$ none $\mid$ inherit

Initial value: User agent-dependent

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: As specified

## right

This property defines the offset between the right outer margin edge of a positioned element and the right edge of its containing block.

Values: $\quad<$ length> $\mid$ <percentage $>\mid$ auto $\mid$ inherit

Initial value: auto

Applies to: Positioned elements (that is, elements for which the value of position is something other than static)

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For relatively positioned elements, see Note; for static elements, auto; for length values, the corresponding absolute length; for percentage values, the specified value; otherwise, auto

Note: $\quad$ For relatively positioned elements, the computed value of left always equals right

## text-align

This property sets the horizontal alignment of text within a block-level element by defining the point with which line boxes are aligned. The value justify is supported by allowing user agents to programmatically adjust the letter and word spacing of the line's content; results may vary by user agent.

CSS2.1 values: left $\mid$ center $\mid$ right $\mid$ justify $\mid$ inherit

CSS2 values: $\quad$ left $\mid$ center $\mid$ right $\mid$ justify $\mid$ <string> |inherit

Initial value: User agent-specific; may also depend on writing direction

Applies to: Block-level elements

Inherited: Yes

Computed value: As specified

Note: $\quad$ CSS2 included a <string> value that was dropped from CSS2.1 due to a lack of widespread support

## text-decoration

This property allows certain text effects such as underlining. These decorations will "span" descendant elements that do not have decorations of their own. User agents are not required to support blink.

Values: none | [ underline || overline || line-through || blink ] | inherit

Initial value: none

Applies to: All elements

Inherited: No

Computed value: As specified

## text-indent

Used to define the indentation of the first line of content in a block-level element. This is most often used to create a "tab" effect. Negative values are permitted and cause "outdent" (or "hanging indent") effects.

Values: $\quad<$ length $>\mid<$ percentage $>\mid$ inherit

Initial value: 0

Applies to: Block-level elements

Inherited: Yes

Percentages: Refer to the width of the containg block

Computed value: For percentage values, as specified; for length values, the absolute length

## text-transform

This property changes the case of letters in an element, regardless of the case of the text in the document source. The determination of which letters are to be capitalized by the value capitalize is not precisely defined, as it depends on user agents knowing how to recognize a "word."

Values: $\quad$ uppercase $\mid$ lowercase $\mid$ capitalize $\mid$ none $\mid$ inherit

Initial value: none

Applies to: All elements

Inherited: Yes

Computed value: As specified

## top

This property defines the offset between the top outer margin edge of a positioned element and the top edge of its containing block.

Values:

$$
\text { <length> } \mid<\text { percentage }>\mid \text { auto } \mid \text { inherit }
$$

Initial value: auto

Applies to: Positioned elements (that is, elements for which the value of position is something other than static)

Inherited: No

Percentages: Refer to the height of the containing block

Computed value: For relatively positioned elements, see Note; for static elements, auto; for length values, the corresponding absolute length; for percentage values, the specified value; otherwise, auto

Note: $\quad$ For relatively positioned elements, if both top and bottom are auto, their computed values are both 0 ; if one of them is auto, it becomes the negative of the other; if neither is auto, bottom will become the negative of the value of top

## unicode-bidi

This allows the author to generate levels of embedding within the Unicode embedding algorithm. User agents that do not support bidirectional text are permitted to ignore this property.

Values: $\quad$ normal $\mid$ embed $\mid$ bidi-override | inherit

Initial value: normal

Applies to: All elements

Inherited: No

Computed value: As specified

## vertical-align

This defines the vertical alignment of an inline element's baseline with respect to the baseline of the line in which it resides. Negative length and percentage values are permitted, and they lower the element instead of raising it. In table cells, this property sets the alignment of the content of the cell within the cell box.



Applies to: Inline elements and table cells

Inherited: No

Percentages: Refer to the value of line-height for the element

Computed value: For percentage and length values, the absolute length; otherwise, as specified

Note: $\quad$ When applied to table cells, only the values baseline, top, middle, and bottom are recognized

## visibility

This specifies whether the element box generated by an element is rendered. This means the element could occupy the space it would ordinarily, but be completely invisible. The value collapse is used in tables to remove columns or rows from the table's layout.

Values: $\quad$ visible $\mid$ hidden $\mid$ collapse $\mid$ inherit

Initial value: visible

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: As specified

## white-space

This declares how whitespace within an element is handled during layout. The values pre-wrap and pre-line were added in CSS2.1.
Values: normal | nowrap | pre | pre-wrap | pre-line | inherit
Initial value: normal
Applies to: $\quad$ All elements (CSS2.1); block-level elements (CSS1 and CSS2)
Inherited: No
Computed value: As specified

## width

This defines the width of an element's content area, outside of which padding, borders, and margins are added. This property is ignored for inline nonreplaced elements. Negative length and percentage values are not permitted.

Values: $\quad<$ length $>\mid$ < percentage $>\mid$ auto $\mid$ inherit

Initial value: auto

Applies to: $\quad$ Block-level and replaced elements

Inherited: No

Percentages: Refer to the width of the containing block

Computed value: For auto and percentage values, as specified; otherwise, an absolute length, unless the property does not apply to the element (then auto)

## word-spacing

This defines the amount of whitespace to be inserted between words in an element. For the purposes of this property, a "word" is defined as a string of characters surrounded by whitespace. Length values create a modifier to the usual spacing between words; thus, normal is synonymous with 0 . Negative length values are permitted and will cause words to bunch closer together.

Values: $\quad<$ length $>\mid$ normal $\mid$ inherit

Initial value: normal

Applies to: All elements

## Inherited: $\quad$ Yes

Computed value: For normal, the absolute length 0 ; otherwise, the absolute length

## z-index

This property sets the placement of a positioned element along the $z$-axis, which is defined as the axis that extends perpendicular to the display area. Positive numbers are closer to the user, and negative numbers are further away.

Values:

<integer> | auto $\mid$ inherit

Initial value: auto

Applies to: Positioned elements

Inherited: No

Computed value: As specified

## Tables

## border-collapse

This property defines the layout model used in laying out the borders in a table-i.e., those applied to cells, rows, and so forth. Although the property applies only to tables, it is inherited by all the elements within the table.

Values: $\quad$ collapse $\mid$ separate $\mid$ inherit

Initial value: separate

Applies to: Elements with the display value table or inline-table

Inherited: Yes

Computed value: As specified

Note: $\quad$ In CSS2, the default value was collapse

## border-spacing

This specifies the distance between cell borders in the separated borders model. The first of the two length values is the horizontal separation, and the second is the vertical. This property is ignored unless border-collapse is set to separate. Although the property only applies to tables, it is inherited by all of the elements within the table.

Values: $<$ length> < <ength>? | inherit

Initial value: 0

Applies to: Elements with the display value table or inline-table

Inherited: Yes

Computed value: Two absolute lengths

Note: $\quad$ This property is ignored unless border-collapse value is separate

## caption-side

This specifies the placement of a table caption with respect to the table box. The caption is rendered as though it were a block-level element placed just before (or after) the table.

Values: top | bottom

Initial value: top

Applies to: Elements with the display value table-caption

Inherited: Yes

Computed value: As specified

Note: $\quad$ The values left and right appeared in CSS2 but were dropped from CSS2.1 due to a lack of widespread support

## empty-cells

This defines the presentation of table cells that contain no content. If shown, the cell's borders and background are drawn. This property is ignored unless border-collapse is set to separate.

Values: $\quad$ show $\mid$ hide $\mid$ inherit

Initial value: show

Applies to: Elements with the display value table-cell

Inherited: Yes

Computed value: As specified

Note: $\quad$ This property is ignored unless border-collapse value is separate

## table-layout

This property specifies which layout algorithm is used to lay out a table. The fixed layout algorithm is faster but less flexible, while the automatic algorithm is slower but more reflective of traditional HTML tables.

Values: $\quad$ auto $\mid$ fixed $\mid$ inherit

Initial value: auto

Applies to: Elements with the display value table or inline-table

Inherited: Yes

Computed value: As specified

## Paged Media

## orphans

This specifies the minimum number of text lines within the element that can be left at the bottom of a page. This can affect the placement of page breaks within the element.

Values: $\quad<$ integer> $\mid$ inherit

Initial value: 2

Applies to: Block-level elements

Inherited: Yes

Computed value: As specified

## page-break-after

This declares whether page breaks should be placed after an element. While it is possible to force breaks with always, it is not possible to guarantee prevention; the best an author can do is ask the user agent to avoid inserting a page break if possible.

Values: auto | always | avoid | left | right | inherit

Initial value: auto

Applies to: Nonfloated block-level elements with a position value of relative or static

Inherited: No

Computed value: As specified

## page-break-before

Declares whether page breaks should be placed before an element. While it is possible to force breaks with always, it is not possible to guarantee prevention; the best an author can do is ask the user agent to avoid inserting a page break if possible.

Values: $\quad$ auto $\mid$ always $\mid$ avoid $\mid$ left $\mid$ right $\mid$ inherit

Initial value: auto

Applies to: Nonfloated block-level elements with a position value of relative or static

Inherited: No

Computed value: As specified

## page-break-inside

This declares whether page breaks should be placed inside an element. Because an element might be taller than a page box, it is not possible to guarantee prevention; the best an author can do is ask the user agent to avoid inserting a page break if possible.

Values:

auto | avoid | inherit

Initial value:

auto

Applies to: Nonfloated block-level elements with a position value of relative or static

Inherited: $\quad$ Yes

Computed value: As specified

## widows

This specifies the minimum number of text lines within the element that can be left at the top of a page. This can affect the placement of page breaks within the element.

Values: <integer> | inherit

Initial value: 2

Applies to: Block-level elements

Inherited: Yes

Computed value: As specified

## Dropped from CSS2.1

The following properties appeared in CSS2 but were dropped from CSS2.1 due to a lack of widespread support. They do not have computed value information since computed values were first explicitly defined in CSS2.1.

## Visual Styles

## font-size-adjust

The aim of this property is to allow authors to trigger font scaling such that substitute fonts will not look too different from the font the author intended, even if the substitute font has a different $\mathrm{x}$-height. Note that this property does not appear in CSS2.1.

Values: $\quad<$ number> $\mid$ none $\mid$ inherit

Initial value: none

Applies to: All elements

Inherited: Yes

## font-stretch

With this property, the character glyphs in a given font can be made wider or narrower, ideally by selected condensed or expanded faces from the font's family. Note that this property does not appear in CSS2.1.
Values:
normal | wider | narrower | ultra-condensed | extra-condensed | condensed $\mid$ semi-condensed $\mid$ semi-expanded $\mid$ expanded $\mid$ extra-expanded $\mid$ ultra-expanded $\mid$ inherit
Initial value: normal
Applies to: All elements
Inherited: Yes

## marker-offset

This property specifies the distance between the nearest border edge of a marker box and its associated element box.

Values:

$$
\text { <length> } \mid \text { auto | inherit }
$$

Initial value: auto

Applies to: $\quad$ Elements with a display value of marker

Inherited: No

Note: $\quad$ This property is obsolete as of CSS2.1 and will likely not reappear in CSS3, and the same is true for the display value of marker; as of this writing, it appears that other mechanisms will be used to achieve these effects

## text-shadow

This permits the assignment of one or more "shadows" to the text in an element. The first two length values in a shadow definition set horizontal and vertical offsets, respectively, from the element's text. The third length defines a blurring radius. Note that this property does not appear in CSS2.1.

Values: $\quad$ none $\mid[<\text { color }>|| \text { <ength> < length> < length>? , }]^{*}[<$ color $>||$ <ength> $<$ length> < length $>$ ?] | inherit

Initial value: none

Applies to: All elements

Inherited: No

## Paged Media

## marks

This property defines whether "cross marks" (otherwise known as register marks or registration marks) should be placed outside the content area but within the printable area of the canvas. The exact placement and rendering of the marks is not defined. Note that this value does not appear in CSS2.1.

Values:

[ crop || cross ] | none | inherit

Initial value: none

Applies to: Page context

Inherited: N/A

## page

This property, in conjunction with size, specifies a particular page type to be used in the printing of an element. Note that this property does not appear in CSS2.1.

Values: $\quad<$ identifier> $\mid$ inherit

Initial value: auto

Applies to: Block-level elements

Inherited: Yes

## size

With this property, authors can declare the size and orientation of the page box used in the printing of an element. It can be used in conjunction with page, although this is not always necessary. Note that this property does not appear in CSS2.1.

Values: $\quad<$ length $>\{1,2\} \mid$ auto $\mid$ portrait $\mid$ landscape $\mid$ inherit

Initial value: auto

Applies to: The page area

Inherited: No

## Aural Styles

## azimuth

This property sets the angle along the horizontal plane (otherwise known as the horizon) from which a sound should seem to emanate. This is used in conjunction with elevation to place the sound at a point on a hypothetical sphere with the user at its center.

Values: <angle> | [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards | inherit

Initial value: center

Applies to: All elements

Inherited: Yes

Computed value: Normalized angle

## cue

This is a shorthand property that allows an author to define cues that precede and follow the audio rendering of an element's content. A "cue" is something like an auditory icon.

Values: $\quad[$ <cue-before $>||$ <cue-after> $] \mid$ inherit

Initial value: none

Applies to: $\quad$ All elements

Inherited: No

Computed value: See individual properties (cue-before, etc.)

## cue-after

This property allows an author to define a cue that follows the audio rendering of an element's content.

Values: $\quad<u r i>\mid$ none $\mid$ inherit

Initial value: none

Applies to: $\quad$ All elements

Inherited: No

Computed value: For <uri> values, the absolute URI; otherwise, none

## cue-before

This property allows an author to define a cue that precedes the audio rendering of an element's content.

Values: $\quad<$ uri> $\mid$ none $\mid$ inherit

Initial value: none

Applies to: $\quad$ All elements

Inherited: No

Computed value: For <uri> values, the absolute URI; otherwise, none

## elevation

This property sets the angle above or below the horizontal plane (otherwise known as the horizon) from which a sound should seem to emanate. This is used in conjunction with azimuth to place the sound at a point on a hypothetical sphere with the user at its center.

Values: $\quad$ <angle> | below $\mid$ level $\mid$ above $\mid$ higher $\mid$ lower $\mid$ inherit

Initial value: level

Applies to: All elements

Inherited: Yes

Computed value: Normalized angle

## pause

This is a shorthand property that allows an author to define pauses that precede and follow the audio rendering of an element's content. A "pause" is an interval in which no content is audibly rendered, although background sounds may still be audible.

Values: $[[<$ time $>\mid<$ percentage $>]\{1,2\}] \mid$ inherit

Initial value: 0

Applies to: All elements

Inherited: No

Computed value: See individual properties (pause-before, etc.)

## pause-after

This property allows an author to define the length of a pause that follows the audio rendering of an element's content.

Values: $\quad<$ time $>\mid$ <percentage> $\mid$ inherit

Initial value:s: 0

Applies to: All elements

Inherited: No

Computed value: The absolute time value

## pause-before

This property allows an author to define the length of a pause that precedes the audio rendering of an element's content.

Values: $\quad<$ time $>\mid$ <percentage $>\mid$ inherit

Initial values: 0

Applies to: All elements

Inherited: No

Computed value: The absolute time value

## pitch

Specifies the average pitch (frequency) of the speaking voice used to audibly render the element's content. The average pitch of a voice will depend greatly on the voice family.

Values: $\quad$ <frequency> $\mid$ x-low $\mid$ low $\mid$ medium $\mid$ high $\mid x$-high $\mid$ inherit

Initial value: medium

Applies to: All elements

Inherited: Yes

Computed value: The absolute frequency value

## pitch-range

This property specifies the variation in average pitch used by the speaking voice, while audibly rendering the element's content. The higher the variation, the more "animated" the voice will sound.

Values: $\quad<$ number> $\mid$ inherit

Initial value: 50

Applies to: All elements

Inherited: Yes

Computed value: As specified

## play-during

This provides a sound to be played "in the background" while the element's contents are audibly rendered. The sound can be mixed with other background sounds (set using play-during on an ancestor element), or it can replace other sounds for the duration of the element's audio rendering.

Values: <uri> | [mix || repeat]? | auto | none | inherit

Initial value: auto

Applies to: All elements

Inherited: No

Computed value: For <uri> values, the absolute URI; otherwise, as specified

## richness

This property sets the "brightness" of the speaking voice used when audibly rendering the element's content. The brighter the voice, the more it will "carry."

Values: $\quad<$ number> $\mid$ inherit

Initial value: 50

Applies to: All elements

Inherited: yes

Computed value: As specified

## speak

This determines how an element's contents will be audibly rendered, or indeed if they will be rendered at all. The value spell-out is typically used for acronyms and abbreviations, such as W3C or CSS. If the value is none, the element is skipped (it takes no time to be audibly rendered).

Values: normal | none | spell-out | inherit

Initial value: normal

Applies to: All elements

Inherited: Yes

Computed value: As specified

## speak-header

This specifies whether the content of table headers is spoken before every cell associated with those headers, or only when the header associated with a cell is different from the header associated with the previously rendered cell.

Values: $\quad$ once $\mid$ always $\mid$ inherit

Initial value: once

Applies to: Elements containing table header information

Inherited: Yes

Computed value: As specified

## speak-numeral

This property determines how numbers are spoken during audible rendering.

Values: $\quad$ digits $\mid$ continuous | inherit

Initial value: continuous

Applies to: All elements

Inherited: Yes

Computed value: As specified

## speak-punctuation

This property determines how punctuation is spoken during audible rendering. The value code causes punctuation symbols to be rendered literally.

Values: code | none | inherit

Initial value: none

Applies to: All elements

Inherited: Yes

Computed value: As specified

## speech-rate

This sets the average rate at which words are spoken when an element's content is audibly rendered.

Values: $\quad \quad$ <number> $\mid x$-slow $\mid$ slow $\mid$ medium $\mid$ fast $\mid x$-fast $\mid$ faster $\mid$ slower $\mid$ inherit

Initial value: medium

Applies to: $\quad$ All elements

Inherited: Yes

Computed value: An absolute number

## stress

This property affects the height of peaks in the intonation of a speaking voice. These peaks are in turn generated by stress marks within a language.

Values:

<number> | inherit

Initial value: 50

Applies to: All elements

Inherited: Yes

Computed value: As specified

## voice-family

This property is used to define a list of voice families that can be used in the audio rendering of an element's content, and is comparable to font-family. The permitted generic voices are male, female, and child.

Values:

[[<specific-voice> | <generic-voice> ],]* [<specific-voice> | <generic-voice> ] | inherit

Initial value: User agent-dependent

Applies to: All elements

Inherited: Yes

Computed value: As specified

## volume

This sets the median volume level for the waveform of the audibly rendered content. Thus, a waveform with large peaks and valleys may go well above or below the volume level set with this property. Note that 0 is not the same as silent.

Values:

<number> $\mid$ <percentage $>$ silent $\mid x$-soft $\mid$ soft $\mid$ medium $\mid$ loud $\mid$ $x$-loud | inherit

Initial value: medium

Applies to: All elements

Inherited: Yes

Computed value: An absolute number

## Selector, Pseudo-Class, and Pseudo-Element Reference

## Selectors

## Universal Selector

This selector matches any element name in the document's language. If a rule does not have an explicit selector, then the universal selector is inferred.

Pattern: *

Examples:

$*$ \{color: red; $\}$

div * p \{color: blue; $\}$

## Type Selector

This selector matches the name of an element in the document's language. Every instance of the element name is matched. (CSS1 referred to these as element selectors.)

Pattern: element1

Examples:

body \{background: \#FFF; \}

p \{font-size: $1 \mathrm{em} ;\}$

## Descendant Selector

This allows the author to select an element based on its status as a descendant of another element. The matched element can be a child, grandchild, great-grandchild, etc., of the ancestor element. (CSS1 referred to these as contextual selectors.)

Pattern: element1 element2

Examples:

body h1 \{font-size: $200 \%$; $\}$

table tr td div ul li \{color: purple; \}

## Child Selector

This type of selector is used to match an element based on its status as a child of another element. This is more restrictive than a descendant element, since only a child will be matched.

Pattern: element1 > element2

Examples:

div > p \{color: cyan; $\}$

ul > li \{font-weight: bold; \}

## Adjacent Sibling Selector

This allows the author to select an element that is the following adjacent sibling of another element. Any text between the two elements is ignored; only elements and their positions in the document tree are considered.

Pattern: element1 + element2

Examples:

table $+p\{$ margin-top: $2.5 \mathrm{em} ;\}$

$\mathrm{h} 1+*\{$ margin-top: $0 ;\}$

## Class Selector

In languages that permit it, such as HTML, SVG, and MathML, a class selector using "dot notation" can be used to select elements that have a class containing a specific value or values. The name of the class value must immediately follow the dot. Multiple class values can be "chained" together. If no element name precedes the dot, the selector matches all elements containing that class value.

Patterns: element1.classname element1.classname1.classname2

Examples:

p.urgent \{color: red; \}

a.external \{font-style: italic; \}

.example \{background: olive; \}

## ID Selector

In languages that permit it, such as HTML, an ID selector using "hash notation" can be used to select elements that have an ID containing a specific value or values. The name of the ID value must immediately follow the octothorpe (\#). If no element name precedes the octothorpe, the selector matches all elements containing that ID value.

Pattern: element1\#idname

Examples:

h1\#page-title \{font-size: $250 \%$; $\}$

body\#home \{background: silver;\}

\#example \{background: lime; \}

## Simple Attribute Selector

This allows authors to select any element based on the presence of an attribute, regardless of the attribute's value.

Pattern: element1[attr]

Examples:

$a[$ rel] \{border-bottom: $3 p x$ double gray; \}

p[class] \{border: $1 \mathrm{px}$ dotted silver; $\}$

## Exact Attribute Value Selector

This allows authors to select any element based on the precise complete value of an attribute.

Pattern: element1[attr="value"]

Examples:

a[rel="Home"] \{font-weight: bold; \}

p[class="urgent"] \{color: red;;\}

## Partial Attribute Value Selector

This allows authors to select any element based on a portion of the space-separated value of an attribute. Note that [class ="value"] is equivalent to .value (see above).

Pattern: element1[attr ="value"]

Examples:

$a\left[\right.$ rel $^{\sim}=$ "friend"] \{text-transform: uppercase; \}

p[class ="warning"] \{background: yellow; \}

## Beginning Substring Attribute Value Selector

This allows authors to select any element based on a substring at the very beginning of an attribute's value.

Pattern: element1[attr^="substring"]

Examples:

$a\left[\right.$ href $\left.^{\wedge}=" / b l o g "\right]$ \{text-transform: uppercase; \}

p[class^="test-"] \{background: yellow; \}

## Ending Substring Attribute Value Selector

This allows authors to select any element based on a substring at the very end of an attribute's value.

Pattern: element1[attr $\$="$ substring"]

Example:

$a[$ href $\$=" . p d f "]$ \{font-style: italic; \}

## Arbitrary Substring Attribute Value Selector

This allows authors to select any element based on a substring found anywhere within an attribute's value.

Pattern: element1[attr*="substring"]

Examples:

a[href*="oreilly.com"] \{font-weight: bold;\}

div [class*="port"] \{border: 1px solid red;\}

## Language Attribute Selector

This allows authors to select any element with a lang attribute whose value is a hyphen-separated list of values, starting with the value provided in the selector.

Pattern: element1[lang|="lc"]

Examples:

html[lang|="en"] \{color: gray;\}

## Pseudo-Classes and Pseudo-Elements

## :active

This applies to an element during the period in which it is activated. The most common example of this is clicking on a hyperlink in an HTML document: during the
time that the mouse button is held down, the link is active. There are other ways to activate elements, and other elements can in theory be activated, although CSS doesn't define this.

Type: Pseudo-class

Applies to: An element that is being activated

Examples:

a:active $\{$ color: red; $\}$

*:active $\{$ background: blue; $\}$

## :after

This allows the author to insert generated content at the end of an element's content. By default, the pseudo-element is inline, but this can be changed using the property display.

Type: Pseudo-element

Generates: A pseudo-element containing generated content placed after the content in the element

Examples:

a.external:after \{content: " " url(/icons/globe.gif);\}

p:after \{content: " | ";

## :before

This allows the author to insert generated content at the beginning of an element's content. By default, the pseudo-element is inline, but this can be changed using the property display.

Type: Pseudo-element

Generates: A pseudo-element containing generated content placed before the content in the element

Examples:

a[href]:before \{content: "[LINK] "; \}

p:before \{content: $\operatorname{attr(class);\} }$

## :first-child

With this pseudo-class, an element is matched only when it is the first child of another element. For example, $p$ : first-child will select any $p$ element that is the first child of some other element. It does not, as is commonly assumed, select whatever element is the first child of a paragraph; for that, an author would write $p>*$ : firstchild.

Type: Pseudo-class

Applies to: Any element that is the first child of another element

Examples:

body *:first-child \{font-weight: bold;\}

p:first-child \{font-size: $125 \%$;

## :first-letter

This is used to style the first letter of an element. Any leading punctuation should be styled along with the first letter. Some languages have letter combinations that should be treated as a single character, and a user agent may apply the first-letter style to both. Prior to CSS2.1, : first-letter could be attached only to block-level elements. CSS2.1 expands its scope to include all elements. There is a limited set of properties that can apply to a first letter.

Type: Pseudo-element

Generates: A pseudo-element that contains the first letter of an element

Examples:

h1:first-letter \{font-size: $166 \%$; \}

a:first-letter \{text-decoration: underline; \}

## :first-line

This is used to style the first line of text in an element, no matter how many or how few words may appear in that line. :first-line can be attached only to block-level elements. There is a limited set of properties that can apply to a first line.

Type: Pseudo-element

Generates: A pseudo-element that contains the first formatted line of an element

Examples:

p.lead:first-line \{font-weight: bold; \}

## :focus

This applies to an element during the period in which it has focus. One example from HTML is an input box that has the text-input cursor within it; that is, when the user starts typing, text will be entered into that box. Other elements, such as hyperlinks, can also have focus, although CSS does not define which ones.

Type: Pseudo-class

Applies to: An element that has focus

Examples:

a:focus \{outline: 1 px dotted red; \}

input:focus $\{$ background: yellow; $\}$

## :hover

This applies to an element during the period in which it is "hovered." Hovering is defined as the user designating an element without activating it. The most common example of this is moving the mouse pointer inside the boundaries of a hyperlink in an HTML document. Other elements can in theory be hovered, although CSS doesn't define which ones.

Type: Pseudo-class

Applies to: An element in a hovered state

Examples:

a[href]:hover \{text-decoration: underline; \}

$\mathrm{p}$ :hover $\{$ background: yellow; \}

## :lang

This matches elements based on their human language encoding. Such language information must be contained within or otherwise associated with the document; it cannot be assigned from CSS. The handling of :lang is the same as for $\mid=$ attribute selectors.

Type: Pseudo-class

Applies to: Any element with associated language-encoding information

Examples:

html:lang(en) \{background: silver; \}

*:lang(fr) \{quotes: '" ' ' »'; \}

## :link

This applies to a link to a URI that has not been visited; that is, the URI to which the link points does not appear in the user agent's history. This state is mutually exclusive with the :visited state.

Type: Pseudo-class

Applies to: A link to another resource that has not been visited

Examples:

a:link \{color: blue; \}

$*:$ link $\{$ text-decoration: underline; $\}$

## :visited

This applies to a link to a URI that has been visited; that is, the URI to which the link points appears in the user agent's history. This state is mutually exclusive with the :link state.

Type: Pseudo-class

Applies to: A link to another resource that has already been visited

Examples:

a:visited \{color: purple;\}

*:visited \{color: gray; \}

## APPENDIX C

## Sample HTML 4 Style Sheet

The following style sheet is adapted from Appendix D of the CSS2.1 specification. There are two important things to note. The first is that while CSS2.1 says that "developers are encouraged to use [this] as a default style sheet in their implementations," this isn't always possible. For example, there is a rule that states:

ol, ul, dir, menu, dd

\{margin-left: 40px; \}

This describes the legacy indenting of lists to a distance of 40 pixels, and it uses a left margin to do it. However, some browsers have used a 40-pixel left padding instead of a margin, believing this to be a better solution. (See Chapter 12 for details.) Therefore, you cannot rely on this as the exact default style sheet for any given user agent. It is provided more for illustrative purposes and as a learning tool.

The second thing to note is that not all HTML elements are fully described in this style sheet because CSS is not yet detailed enough to completely and accurately describe them. The classic examples are form elements, such as submit buttons, which are replaced elements but have their own special formatting needs. Submit buttons are replaced elements, and thus the bottom edge of their box should align with the baseline. Authors, however, are likely to expect the text inside the button to align with the baseline of other text in the same line. This is a reasonable expectation, but CSS does not (as of this writing) have the ability to describe such behavior; therefore, all that is said about such elements is the following rule:



The rest of the formatting of such elements is left to the user agent.

With these caveats in mind, here is the style sheet (with some slight reformatting) found in the CSS2 specification. Any changes other than reformatting are noted in comments.
address, blockquote, body, dd, div, dl, dt, fieldset, form, frame, frameset, h1, h2, h3, h4, h5, h6, noframes, ol, p, ul, center, dir, hr, menu, pre \{ display: block; $\}$

li $\quad$ \{display: list-item; $\}$

head \{display: none; $\}$

table \{display: table; $\}$

$\operatorname{tr} \quad$ \{display: table-row;

thead \{display: table-header-group; \}

tbody \{display: table-row-group; \}

tfoot \{display: table-footer-group; \}

col \{display: table-column; \}

colgroup \{display: table-column-group; \}

td, th \{display: table-cell; \}

caption \{display: table-caption;\}

th $\{$ font-weight: bolder; text-align: center; $\}$

caption \{text-align: center; $\}$

body $\quad$ ppadding: 8px; line-height: 1.12em;\}

h1 $\quad$ ffont-size: 2em; margin: .67em 0; \}

h2 $\quad$ font-size: $1.5 \mathrm{em}$; margin: .75em 0; $\}$

h3 $\quad$ font-size: 1.17em; margin: .83em 0; $\}$

h4, p, blockquote, ul, fieldset, form, ol, dl, dir, menu \{ margin: $1.12 \mathrm{em} 0 ;\}$

h5 $\quad$ font-size: .83em; margin: $1.5 \mathrm{em} \mathrm{0;}\}$

h6 $\quad$ \{font-size: .75em; margin: $1.67 \mathrm{em} 0 ;\}$

h1, h2, h3, h4, h5, h6, b, strong \{

font-weight: bolder; $\}$

blockquote \{margin-left: 40px; margin-right: 40px; \}

i, cite, em, var, address \{

font-style: italic;

pre, $t t$, code, kbd, samp \{ font-family: monospace; \}

pre $\quad$ \{white-space: pre;\}

button, textarea, input, object, select, img \{ display:inline-block; \}



sub \{vertical-align: sub;\}

sup \{vertical-align: super; \}

s, strike, del \{text-decoration: line-through;\}

hr $\quad$ bborder: $1 \mathrm{px}$ inset; \}

ol, ul, dir, menu, dd \{ margin-left: 40px; \}

ol $\quad$ \{list-style-type: decimal;\}

ol ul, ul ol, ul ul, ol ol \{ margin-top: 0; margin-bottom: 0;\}

$u$, ins $\quad$ text-decoration: underline; $\}$

br:before \{content: "\A"; \}

center \{text-align: center; $\}$

abbr, acronym \{font-variant: small-caps; letter-spacing: $0.1 \mathrm{em}$; \}

:link, :visited \{text-decoration: underline;\}

:focus $\quad$ \{outline: thin dotted invert; $\}$



## Index

## Symbols

+ (plus sign)

in adjacent-sibling selectors, 49

in property syntax, xii

<> (angle brackets) in property syntax, xii

$>$ (greater-than symbol) in child selectors, 48

@import directive, 18

| (vertical bar)

in attribute selector, 43

in property syntax, xii

II (vertical double bar) in property syntax, xii

$\sim$ (tilde) in attribute selectors, 41

## A

a element, 51

absolute length units, 84

absolute positioning, 303, 317

containing blocks and, 303, 317

height and width affecting, 320

nonreplaced elements, 323

on z-axis, 329

replaced elements, 327

scrolling and, 319

stacking context and order for, 331

absolute URL, 90

ActiveBorder system color, 398

ActiveCaption system color, 398

adjacent-sibling combinator, 49

adjacent-sibling selectors, 49, 492

align attribute, img element, 283 alignment

justified, 133, 145

of baseline, 141

of cell content, 366

of middle of element, 141

spacing and, 145

superscripting and subscripting, 139

to baseline, 138

to bottom of line box, 140

to bottom of text, 140

vertical, 134

alink attribute, body element

active pseudo-class and, 54

alt attribute, attribute selectors used with, 39

alternate style sheets, 16

alternate stylesheet attribute, 16

ancestors of elements, 45

angle brackets (<>) in property syntax, xii

angle values, 92

animated cursors, 404

AppWorkspace system color, 398

aspect value of font, 119

asterisk $\left(^{*}\right)$

as universal selector, 28,32

in property syntax, xii

attribute selectors, 38-43, 493, 494

applying to multiple attributes, 39,40

exact-value attribute selectors, 39

partial-value attribute selectors, 41

particular attribute selectors, 43

simple attribute selectors, 38,493

specificity of, 63

attribute values, as generated content, 383

We'd like to hear your suggestions for improving our indexes. Send email to index@oreilly.com.
audio rendering of content, 442

aural media type, 14, 430

aural styles, 429

background sounds for, 442

cues in speech, 441,485

pauses in speech, 439, 486

positioning sounds for, 443, 484, 485

specifying content to be spoken, 488

speech rate for, 433, 489

units used with, 92

voice used for, 436, 487, 490

volume for, 434

author as origin, 71

azimuth property, 443, 446, 484

## B

background, 253

colors for, 249, 254, 450

design issues regarding, 260

extending into padding, 210, 239, 253

extending to borders, 223, 224

floated elements and, 294

for columns and column groups, 345

for empty table cells, 354

of content area, 158

print styles not including, 414

background attribute, body element, 256

background images, 256, 280, 450

attaching to viewing area, 275-279, 449

inheritance and, 259

origin image, 264

positioning, 264-273, 450

scrolling, 276

special effects with, 277

tiling, 256, 257, 261, 273

background property, 280, 449

background sounds, 487

Background system color, 398

background-attachment property, 449

background-color property, 254, 256, 450

combining with background-image property, 260

background-image property, 257, 450

combining with background-color property, 260

background-position property, 264, 450

default values for, 270

keyword values for, 266

length values for, 270 negative values for, 271

percentage values for, 267

background-repeat property, 261, 451

backslash ( () escaping linefeeds, 383

backward accessibility with older browsers, 19

ball spinning, cursor, 403

baselines

aligning elements using, 138, 141

replaced elements and, 196

bidirectional text, 476

bleeding outside page box, 426

block boxes

for floated elements, 286

for list items, 370, 377

for positioned elements, 303

for table captions, 350

for tables, 341

forcing with display property, 9, 203

overlapping floated elements, 297

page breaks between, 423

run-in elements and, 203

block, containing, 159

block-level elements, 8, 9, 160, 201

boundaries of, 161

horizontal formatting of, 161

blur radius for text shadow, 152

body element

alink attribute, 54

as containing block for positioned elements, 319

background attribute, 256

color attributes replaced with color property, 249

inheritance of background styles, 69

link and vlink attributes, 52

bold text used in this book, xi

border property, 69, 236, 451

border-bottom property, 170, 451

border-bottom-color property, 451

border-bottom-style property, 452

border-bottom-width property, 452

border-collapse property, 352, 478

border-color property, 159, 231, 251, 452

border-left property, 163, 453

border-left-color property, 232, 453

border-left-style property, 227, 453

border-left-width property, 454

border-right property, 163, 454
border-right-color property, 454

border-right-style property, 455

border-right-width property, 455

borders, 158, 159, 223-238, 404

as foreground of element, 247

background extending to, 223, 224

color of, 159, 224, 226, 231, 251, 451-456

enabling existence of, 224, 230

for columns and column groups, 344

for inline replaced elements, 195

for inline-level elements, 192, 237

for table cells, 352, 353, 355, 478

hiding, 224

padding and, 239

sides of, 236, 451, 453, 454, 456

style of, 224, 226, 452, 453, 455, 456

transparent, 233

width of, 224, 228, 234, 452, 454, 455, 457

border-spacing property, 353, 479

border-style property, 171, 224, 455

border-top property, 170, 234, 456

border-top-color property, 232, 456

border-top-style property, 227, 456

border-top-width property, 228, 457

border-width property, 228, 457

bottom alignment, 140

bottom property, 457

boxes, 9

cell boxes, 341

column boxes, 340

dialog boxes, 396

em boxes (em squares), 107

line boxes, 135, 182, 183, 184, 186, 190, 194,424

page boxes, 415,425

row boxes, 340

braces $(\{\})$ in property syntax, xiii

brackets ([])

in attribute selectors, 38

in property syntax, xii

Braille media type, 14

breaks

generated by block-level elements, 9

page breaks, 418, 480, 481

browsers, 8

as screen-medium user agents, 15

attribute selectors, 38,252

clipping, 316

color names, 79 escaped content, 383

floated element placement, 292

font face rules not implemented by, 126

form element colors, 253

generated content, 379

indentation of list items, 377

inheritance support, 70

list-style-type defaults, 375

nonrectangular outlines, 405

older versions of, 19, 37

outline placement, 405

padding for images, 244

pixel preference settings in, 86

printing fixed-attachment backgrounds, 279

projection media support, 426

run-in elements, 205

stretching and adjusting fonts not implemented, 117

text decorations, 151

transparent borders, 233

bugs

z-axis positioning, 334

borders drawn away from padding in Navigator 4, 238

default font size in Internet Explorer, 109

fixed-attachment backgrounds on non-body elements handled incorrectly, 279

height and width applied incorrectly in Internet Explorer, 210

multiple class selector handling in Internet Explorer, 35

styles not inherited into tables, 70

ButtonFace system color, 398

ButtonHighlight system color, 398

buttons

system colors for, 398

system font for, 396

ButtonShadow system color, 398

ButtonText system color, 398

## C

caption system font, 123, 396

captioned controls, system font for, 396

captions for tables, 350

placement of, 350, 479

specifying, 343

caption-side property, 350, 479

CaptionText system color, 399
carriage returns

white-space property and, 154

cascade rules, 6, 71-75

cascades, 6

Cascading Style Sheets (CSS), 6

features of, 3

future of, 7

history of, 3

unique features of CSS2 and CSS2.1, xi

versions covered in this book, xi

case of text, 475

case-sensitivity, of class and ID selectors, 37

cell boxes, 341

cell phones, web-enabled, media type for, 15

cells

alignment of content in, 366

borders for, 352, 355, 479

empty, 354, 479

images in, with gaps, 139

layer for, 349

positioning, 341

spanning, 340

specifying, 343

vertically aligning elements in, 138

cellspacing attribute, 353

center element, 132

centering text, 132, 165

centimeters $(\mathrm{cm})$ length units, 84

child combinator, 48

child elements, 45, 495

child selectors, 48, 492

class attribute, 32

class selectors, 32-35, 492

attribute selectors substituting for, 38, 41

case-sensitivity of, 37

combining with pseudo-classes, 53

languages supporting, 37, 38

multiple, 34

specificity value of, 63

when to use, 36

clear property, 298, 458

clearing, 298-302

clip property, 458

$\mathrm{cm}$ (centimeters) length units, 84

code, examples, xiii

col element, 343

colgroup element, 343 colon (:)

between property and value, 26

in pseudo-class or pseudo-element selectors, 52

color inversion for outlines, 407, 409

color property, 248, 459

affecting borders, 251

affecting form elements, 252

combining with background-color property, 256

inheritance and, 253

color values, 78

equivalents, table of, 82

named colors, 78, 82

RGB colors, 79

web-safe colors, 83

colors

background, 254

border, 159

design issues regarding, 246

inheritance and, 253

outline, 408,470

projection styles, 429

replacing body attributes for, 249

text decorations, 149, 151

column boxes, 340

column groups

layer for, 349

specifying, 343

visibility of, 345

columns, table

background for, 345

borders for, 344

layer for, 349

specifying, 342

visibility of, 345

width of, 345

columns, text, print styles for, 414

combinator

in adjacent-sibling selectors, 49

in child selectors, 48

in descendant selectors, 46

specificity value of, 63

comma (,)

in property syntax, xii

in selectors, 27

comments, 20

compact file size, 7
complexspiral distorted demonstration, 278

contact information for this book, xiv

containing block

height of, affecting positioning, 306

of floated elements, 286

positioning and, 303

content area, 134, 158, 378

background of, 158

clipping, 312, 458

for inline nonreplaced elements, 184

glyphs and, 194

height of, 170, 306, 464

overflowing, 311, 471

width of, 161,477

content edge, 159

content property, 382, 459

counters used with, 389

quotation-related values of, 385

contextual selectors, 46

continuous medium, 413

controls, small captioned, system font for, 396

conventions used in this book, xi

counter-increment property, 388, 459

counter-reset property, 387, 460

counters for ordered lists

defining for multiple levels, 392

incrementing, 388, 390, 459

negative values for, 388,389

resetting, 387, 390, 460

scope of, 392

styles for, 391

crop marks (cross marks), 483

crosshair cursor, 402

CSS, xi

cascading, 6

comments, 20

documents and, 1-22

ease of use, 4

link tag, 12

rich styling, 3

rules, 23-27

styles on multiple pages, 5

stylistic language, 7

XHTML and, 11-21

CSS comments, 20

CSS2

@font-face rule, 126

@) page rules, 416 attribute selectors, 38, 252

clip property, elements applied to, 458

collapse value for visibility, 317

downloadable fonts, 94

drop shadows for text, 152

font-size-adjust property, 482

font-stretch property, 482

list item numbering, 370

list styles, 371

marker-offset property, 178, 379

marks property, 483

min-max properties, 308

offsetting margin edges, 305

page box size, 415

page property, 416, 484

reference pixel recommendation, 89

run-in elements, 202

scaling factor, 108

size property, 415,484

speak-header property, 432

specificity of inline style declarations, 74

specificity of pseudo-elements, 63

stretching and adjusting fonts, 117

text-shadow property, 483

transparent border color, 233

universal selector, 28

CSS2.1

background, area covered by, 224

block and inline elements, 8

cascade rules, 71

color names, 78

combining pseudo-classes, 57

containing block, rules for determining, 159, 303

content area definition, 182

dynamic pseudo-classes, 53

first-letter pseudo-element, scope of, 496

floated elements, 294, 297

generated content, 60

height of content area in relation to font, 194

important rules, 67

inherit keyword, 92

inline-block elements, 201

list styles, 371

list-style-position property, 375

margin placement, 193

offsetting margin edges, 305

overconstrained relative positioning, 338

CSS2. 1 (continued)

pre-wrap and pre-line for white-space property, 154

primacy of inline style declarations, 66

progress value for cursor property, 403

pseudo-elements, 58

real numbers, definition of, 77

reference pixel recommendation, 89

specificity of inline style declarations, 74

specificity of pseudo-elements, 63

static position, 321

cue property, 442, 484

cue-after property, 485

cue-before property, 485

cues in speech, 441, 484, 485

curly braces $(\{\})$ in property syntax, xiii

cursive fonts, 96

cursor property, 400, 460

cursors, 400-404, 460

ball spinning cursor, 403

changing, 400

crosshair cursor, 402

customized, 404

hourglass cursor, 403

over side or corner edges of window, 402

pointing cursor, 401

progress cursor, 403

text selection cursor, 402

## D

declaration block, 24, 26

declarations, 24, 26, 29

descendant selectors, 46, 49, 491

descendants of elements, 45, 68

devices, style sheets specific to, 14

dialog boxes, system font for, 396

direction of flow, 460

direction property, 460

display property, 9, 198, 460

value for lists, 372

values for element display roles, 199

values for generated content, 380

values for tables, 341

document structure, using, 44-50

document style sheets, 18

documents, 1

aural rendering of, 1

file size reduced by CSS, 7

height of, 161

hierarchy of elements in, 44

linking multiple style sheets to, 15 linking style sheets to, 18

multiple, linking style sheets to, 5

presentation of, 2, 3, 4, 75

printing, 413

slideshow presentation of, 1

structured, benefits of, 2

URLs not relative to, 91

width of, 161

dot-class notation, 37

double quotes (") in font-family declaration, 99

drop-down controls, system font for, 396

dynamic pseudo-classes, 53

dynamic styling, real-world issues, 55

## E

element boxes, 158, 207-210

breaks before and after, 9

for inline nonreplaced elements, 184

height of, 170, 468

margins of, 163, 170, 467, 468

outlines of, 470

overlapping, 208

padding of, 471

specifying type of, 199, 460

width of, 161, 469

within a line of text, 9

element selectors, 24, 63, 491

elements, 8

activated, pseudo-class for, 494

ancestors of, 45

background of, 247

block-level elements, 9

child elements, 45

containing block of, 159

converting between inline- and block-level elements, 199

first letter of, pseudo-element for, 58, 59, 496

first line of, pseudo-element for, 59, 496

floating, 283

flow direction of, 160, 476

foreground of, 247

height of, 161, 469

hierarchy of, 44

hovered, pseudo-class for, 497

in focus, pseudo-class for, 496

inserting content before and after, pseudo-elements for, 60

mouse hovering over, pseudo-class for, 54

nonreplaced elements, 8
overlapping, 219

parent elements, 45

persistent, fixed positioning for, 336

siblings of, 49

static position of, 321

visibility of, 316

width of, 161, 208

elements, block-level, 8

elements, inline-level, 8

elevation property, 445, 485

em (em-height) length units, 89

em box, 107

em square, 107

Emacspeak, 93, 430

embedded style sheets, 17, 18

embossed media type, 14

empty-cells property, 354,479

ex (x-height) length units, 86

exact-value attribute selectors, 39, 493

Extensible Markup Language, 7

external style sheets, 13,18

## F

fantasy fonts, 96

file size, compact, 7

filename extension

for animated graphics, 404

for graphic cursors, 404

for style sheets, 14

first-letter, 59

first-line, 59

fixed positioning, 303, 334

fixed-width fonts, 95

float property, 283, 461

floated elements, 283

background and, 294

block boxes generated for, 286

containing blocks and, 286

direction of float, 283, 461

disabling, 285

expanding to contain floated descendants, 294

height for, 310

margins of, 284

negative margins and, 295

nonreplaced elements, 285

overlapped by block boxes, 297

overlapped by inline boxes, 297

overlapping one another, 288

overwriting one another, 287

overwriting previous content, 296, 297 placement rules for, 287

preventing placement next to specific elements, 298, 458

taller than parent element, 292

wider than parent element, 297

width for, 310

floating, 283-298

flow

bidirectional, 476

outlines not included in, 409

font download method, @font-face rule, 127

font face, 95

font families, 95

cursive fonts, 96

fantasy fonts, 96

generic, 95

sans-serif fonts, 95

specifying, 462

font name matching method, @font-face rule, 126

font property, 120, 461

omitted values, behavior of, 122

slash (/) separating keywords of, 27

system fonts, specifying, 123, 396

font size

adjusting based on aspect value, 118, 482

determination of, using em square, 107

font matching and, 125

for inline nonreplaced elements, 184

for print design, 413

inheritance and, 111

specifying, 462

font synthesis method,@font-face rule, 126

font tag, 2

font-family property, 96, 462

quotation marks in, 98

specifying alternate font families with, 98

specifying generic font families with, 96

specifying multiple font families with, 98

specifying specific font family with, 97

fonts, 128

aspect value of, 119

availability of, 94, 124

downloading, 127

em (em-height) value of, 86

ex (x-height) value of, 87

for print design, 413

for screen design, 413

leading and, 134

matching available fonts to specified fonts, 124

proportional, 95
fonts (continued)

setting all values of, 120

setting style of, 114, 463

setting weight of, 463

stretching, 117, 482

used in this book, xi

font-size property, 106, 462

absolute-size keywords for, 107

font matching and, 125

for inline nonreplaced elements, 184

length units for, 112

percentage values for, 110

relative-size keywords for, 109

scaling factor used with, 108

font-size-adjust property, 118, 482

font-stretch property, 117, 482

font-style property, 114, 125, 463

font-variant property, 116, 125, 463

font-weight property, 100, 463

bold keyword, mapping of, 102

bolder keyword, mapping of, 103

font matching and, 125

lighter keyword, mapping of, 105

normal keyword, mapping of, 102

numeric values, mapping of, 101

footers, table, 342

foreground colors, 248, 459

form elements, 160

attribute selectors for, 252

color of, 252

padding for, 244

form inputs, aligning vertically, 137

forward slash (/)

between font size and line height, 122

in property syntax, xii

frames, fixed positioning as substitute for, 334

frequency values, 93

functional RGB notation, 79

## G

generated content, 378-393

attribute values as, 383

audio pauses and cues used with, 442

borders and, 380

counters for ordered lists, 387

floating prohibited for, 380

inheritance and, 381

pseudo-elements for, 60

quotation marks as, 385 specifying content for, 382, 459

specifying location of, 379

string values as, 382

URI values as, 383

generic font families, 95, 98

generic page types, 417

glyphs, content area and, 194

GrayText system color, 399

greater-than symbol ( $>$ ) in child selectors, 48

grid cells, 340,341

grouping, $27-31$

declarations, 29

everything, 30

selectors, 27

universal selector, 28

## $\mathrm{H}$

handheld media type, 15

hanging indents, 129

hash mark, 36

hash-ID notation, 37

headers, table, 342,432

height property, 170, 308, 464

percentage values for, 172

positioned elements and, 307

setting to auto, 171,172

tables and, 365

help cursor, 403

hexadecimal color notation, 81

hexadecimal notation, 82

Highlight system color, 399

Highlight Text system color, 399

horizontal alignment

of table cell content, 366

of text, 131

horizontal formatting, of block-level elements, 161

href attribute, link tag, 14

HTML, 1

element selectors for, 24

file size reduced by CSS, 7

future of, 7

history of, 1

presentational elements in, 2

structural elements of, 2

XML replacing, 7

HTML 4 style sheet sample, 499-501

html element, 160

as root element, 45

inheritance of background styles, 69

hyperlinks, 52

Hypertext Markup Language, 7

hyphenation

capitalization and, 147

justified text using, 133

## I

icon system font, 123, 396

icons

system font for, 396

used in this book, xii

id attribute, 36

ID selectors, 36, 36-37, 493

attribute selectors substituting for, 38, 41

combining with pseudo-classes, 53

languages supporting, 37,38

specificity of, 63,66

uniqueness of, 36

images

as background, 256

as generated content, 380,383

floating using HTML, 283

in links, border style for, 226

in table cell, gaps around, 139

indents affecting, 129

padding for, 244

img element, align attribute, 283

in (inches) length units, 84

InactiveBorder system color, 399

InactiveCaption system color, 399

InactiveCaptionText system color, 399

inches (in) length units, 84

InfoBackground system color, 399

InfoText system color, 399

inherit keyword, 92

inheritance, 62, 68-71

exceptions to, 69

inherit keyword, 92

line height and, 136

text decoration and, 149

initial containing block, 303

inline boxes, 134, 182

forcing with display property, 9, 203

overlapping floated element, 297

inline styles, 21, 66, 73

inline-block elements, 201

inline-level elements, 8, 9, 160

aligning vertically, 476

borders for, 192, 237

generated content as, 380

history of formatting of, 198

line height of, 183

margins for, 192, 221 nonreplaced, 184, 208

padding for, 192, 243

replaced, formatting of, 194

spreading lines of text apart, 198

tables as, 341

intelligent font matching method, @font-face rule, 126

Internet Explorer

adjacent-sibling selectors not supported, 50

assigning table-related display values to HTML elements not supported, 344

attribute selector not supported, 38

child selectors not supported, 50

combined pseudo-classes not supported, 58

default font size, 109

dynamic pseudo-class support, 55

empty-cells property, 355

first-child pseudo-class not supported, 57

fixed positioning not supported, 336

fixed-attachment backgrounds on non-body elements, 279

generated content not supported, 379

height and width implementation, 210

min-max properties not supported, 309

multiple class selectors and, 35

placement of @import directive and, 19

italic text

as font style, 114

used in this book, xi

## J

JavaScript for fixed positioning, 336

justified alignment, 133

spacing and, 145

## K

keyword values, 26, 91

## L

landscape orientation, 416

language

attribute selectors, 494

pseudo-class for, 57, 497

leading, 134

left property, 321, 464

length units, 83

absolute length units, 84

relative length units, 86
letters, spacing between, 144, 464

letter-spacing property, 144, 464

line boxes, 135, 182, 186

aligning elements with, 140

construction of, 183

height of, 184

inline replaced elements and, 194

page breaks and, 424

linefeeds

in generated content, 383

white-space property and, 153

line-height property, 134, 465

baselines and, 190

for block-level elements, 190

for inline replaced elements, 194, 195

for inline-level elements, 183, 184, 186, 189

scaling factor for, 191

setting with font property, 122

lines of text

construction of, 134

height of, 122, 134, 237, 465

spread apart by inline-level elements, 198

line-through text, 148, 150

link attribute, body element, 52

link tag, 12

links

borders visible only when hovered, 233

displaying as block elements, 199

displaying horizontally with equal widths, 202

height and width of, 208

images in, border style for, 226

inserting icons at end of, 380

not visited, pseudo-class for, 51, 497

preceding with generated content, 379

pseudo-classes for, 52

suppressing underlining of, 148

visited, pseudo-class for, 51, 498

lists, $370-378$

counters for ordered lists, 387

formatting of list items, 178

indentation of list items, 377

layout of, 376

markers for list items, 370, 371, 372, 374, 378

list-style property, 375,465

list-style-image property, 373,465

list-style-position property, 178, 466

list-style-type property, 466

lowercase text, 146

## M

margin area for page boxes, 415

margin property, 211, 467

length values for, 213

negative values for, 218

percentage values for, 214

replicating values in, 216

margin-bottom property, 170, 467

collapsing margins with, 174

negative values for, 176

setting to auto, 171

margin-left property, 163, 217, 467

negative values for, 166,218

percentage values for, 168

margin-right property, 163,468

setting to auto, 163

margins, 158

background of, 158

collapsing, 174, 220

for inline-level elements, 192, 196, 221

for page boxes, 415

increased by clear property, 301

internal table elements not including, 339

negative values for, 196

of element boxes, 163,170

of floated elements, 284, 295

positioning and, 305

setting all margins, 211-223

setting separately for each side, 217

margin-top property, 170, 468

negative values for, 176

marker-offset property, 178, 379

markers for list items, 370

as generated content, 378

formatting of, 178

images as, 373,465

inheritance and, 372, 374

position of, $375,377,379,465$

types of, 375, 466

marks property, 483

markup, structured, 3

max-height property, 308, 468

max-width property, 308, 469

media attribute

all, 14

aural, 14

braille, 14

embossed, 14

handheld, 15

print, 15
projection, 15

screen, 15

tty, 15

tv, 15

media attribute, link tag, 14, 411

medium-specific style sheets, 411

@import restrictions for, 412

@media blocks in, 412

based on specific device, not supported, 414

specifying, 411

megahertz (MHz), 93

Menu system color, 399

menu system font, 123, 396

MenuText system color, 399

message-box system font, 123, 396

Microsoft Internet Explorer, 91

middle alignment, 141

millimeters $(\mathrm{mm})$ length units, 84

min-height property, 308, 469

min-width property, 308, 469

$\mathrm{mm}$ (millimeters) length units, 84

Mondrian effect, 219

monitor

media type for, 15

pixel dimensions of, 85

monospace fonts, 95

Mosaic browser, 1

movement cursors, 402

multicolumn layouts, in paged media, 414

multiple class selectors, 34

## $\mathrm{N}$

named color values, 78, 82

Navigator 4

borders drawn away from padding, 238

color replacements, 249

form element colors, 253

URLs relative to document, not style sheet, 91

newlines, white-space property and, 153

none keyword, 91

nonreplaced elements, 8

absolute positioning of, 323

floated, 285

inline, 184, 208, 221, 244

non-screen media, 411-447

normal flow, 160

numbers

as property values, 77

speaking, 431, 488

## 0

O'Reilly Media, contact information for, xiv oblique text, as font style, 114

offset properties, 304, 321

operating system icons, system font for, 396

order of style rules, 71,73

origin image, 264, 273

origin of style rules, 71

orphans property, 424,480

outline property, 408, 470

outline-color property, 407, 470

outlines, 404-408, 470

color of, 407

obscured by other elements, 410

overlapping, 410

style of, 406

width of, 406

outline-style property, 406, 470

outline-width property, 406, 470

overflow property, 471

overlined text, 148

overriding rules, 6

## P

padding, 158, 207, 238-244

background extending to, 210, 239

for inline replaced elements, 195

for inline-level elements, 192, 243

for replaced elements, 244

indenting inline-level elements with, 129

negative indentation and, 129

positioning and, 305

setting for a single side, 243

setting separately for each side, 472, 473

transparent borders acting as, 233

padding property, 238, 471

padding-bottom property, 170, 472

padding-left property, 163, 472

padding-right property, 163, 168, 472

padding-top property, 170, 243, 473

page area, 415

page boxes, 415

page property, 416, 484

page-break-after property, 418, 423, 426, 480

page-break-before property, 418, 423, 481

page-break-inside property, 421, 423, 424, 481

paged media, 413, 480

paperless future, 413

parent elements, 45
parent-child relationship, 44-45

partial-value attribute selectors, 41, 493

particular attribute selectors, 43

pause property, 440, 486

pause-after property, 486

pause-before property, 486

pauses in speech, 439, 486

pc (picas) length units, 84

percentage values, 77

period (.) in class selectors, 32

persistent elements, fixed positioning for, 336

persistent style sheets, 17

picas (pc) length units, 84

pitch property, 437,486

pitch-range property, 438,487

pixel theory, 89

pixels, 79

absolute lengths and, 85

length of, 88

pixels per inch (ppi), 85

play-during property, 442,487

plus sign (+), 402

in adjacent-sibling selectors, 49

in property syntax, xii

pointing cursor, 401

pointing device, 400

points (pt) length units, 84

portrait orientation, 416

position property, 302, 473

positioning, 283, 302-338, 473

absolute, 303, 317

clipping content with, 312

containing blocks in relation to, 303,317

fixed, 303, 334

generated content prohibited from, 380

of internal table elements, 341

of list item markers, 375, 377, 379, 465, 466

offset properties for, $304,457,464,474$, 476

outside containing block, 304, 306

overflowing content with, 311

relative, 303,336

static, 302

visibility of elements and, 316

width of positioned element, 306

z-axis placement for, 329

pound sign (\#) in hexadecimal color notation, 81

preferred style sheets, 17 presentational elements, 5

centralization of, 4

CSS features for, 3

deprecated in XHTML, 7

in HTML, 2

presentational information and markup in web sites, 2

presentational markup, 3

print media type, 15

print preview, 413

print styles, 413

designing, 413

elements outside the page, handling, 425

multiple page types for, 484

orphans, handling, 422

page breaks in, 418

page orientation for, 416

page size for, 415,484

repeated elements in, 425

specifying media type for, 15

printers, teletype, media type for, 15

projection media type, 15

projection styles, 426

colors for, 429

design considerations, 428

positioning elements in, 428

resolution and, 428

slide breaks for, 426

specifying media type for, 15

properties, 9, 24, 26

syntax conventions used in this book, xii

value of, 26

pseudo-class

first-child, 56

lang ( ), 57

pseudo-class selectors, 51-58

pseudo-classes

combining in one selector, 57

dynamic, resulting from user behavior, 53

for element being activated, 54, 249

for element being hovered, 54

for element in focus, 54

for first child element, 56

for first page in document, 417

for language, 57

for links, 249

order of, in selector, 54

requiring document to be redrawn, 55

specificity value of, 63

pseudo-classes, linking, 52

pseudo-element selectors, 58-60
pseudo-elements

for inserting content before and after elements, 379,495

placement of, 60

pt (points) length units, 84

punctuation, speaking, 431, 489

px (pixels) length units, 86, 88, 89

## 0

question mark (?) in property syntax, xiii quotation marks in font-family declaration, 98

quotes property, 385,473

## R

rad (radians) units, 92

reader as origin, 71

reader style sheets, 6

reals, 77

rel attribute, link tag, 14, 16

relative length units, 86

relative positioning, 303, 336

relative URL, 90

replaced elements, 8,160

absolute positioning of, 327

baselines and, 196

horizontal formatting of, 169

inline, 194, 223

padding for, 244

resolution, 84

absolute units of measurement and, 84

projection styles and, 428

relative units of measurement and, 86

RGB colors, 79

rich styling, 3

richness property, 439, 487

right property, 474

root element, 45, 160, 303

row boxes, 340

row groups

layer for, 349

specifying, 342

row primacy model, 344

rows

layer for, 349

specifying, 342

rule structure, 24

declaration block, 24

selector, 24

run-in elements, 202

running head, 425

## S

sample style sheet, 499

sans-serif fonts, 95

scaling factor

for font sizes, 108

for line height, 136

screen, 15

screen media type, 15

screen readers, media type for, 14

Scrollbar system color, 399

scrolling

absolute positioning and, 319

of background, 275

seconds (s) units, 92

selecting elements with exact attribute values, 39

selecting elements with partial attribute values, 41

selectors, 23-61

adjacent-sibling selectors, 49, 492

attribute selectors, 38, 252, 493

child selectors, 48, 492

class selectors, 32, 36, 492

descendant selectors, 46, 491

element selectors, 24

grouping, 27, 30

ID selectors, 36, 493

pseudo-class selectors, 51

pseudo-element selectors, 58

universal selector, 491

semicolon (;) following declarations, 26, 29

serif fonts, 95

serifs, 95

siblings of elements, 49

sidebar backgrounds, 261

simple attribute selectors, 38,493

single quotes (') in generated

content, 385,473

size property, 415,484

slash (/) in property syntax, xii

slideshows, style sheets for, 426

small caps text, as font variant, 117, 463

small-caption system font, 396

sorting, 72-75

sounds, 443

spacing, 153

speak property, 430, 488

speak-header property, 488

speaking content, 430

speak-numeral property, 431, 488

speak-punctuation property, 431, 489
specificity, 62-67

calculating, 63

cascade rule for, 71,73

of attribute selectors, 63,66

of class selectors, 63

of grouped selectors, 64

of ID selectors, 63

of inherited values, 69

of inline styles, 66

of multiple rules, 64

of non-CSS presentational hints, 75

of pseudo-classes, 63

of pseudo-elements, 63

of universal selector, 63,70

resolving ties between, 71

speech media type, 430

speech-rate property, 433, 489

square brackets ([])

in attribute selectors, 38

in property syntax, xii

stacking context, for absolute positioning, 331

static position of element, 321

static positioning, 302, 303

status-bar system font, 396

stress property, 438, 489

strikethru text, 148

structural HTML markup, 2

structured documents, 2

style attribute, 21,73

style element, 17, 20

style rules, 19, 23

important declarations, 67

inline, 73

multiple, specificity of, 64

order of, in cascade rules, 71,73

origin of, 71,72

parts of, 24

weight of, 71,72

style sheets, 4

alternate, 16

alternate style sheets, 16

embedded, 18

example of, 499

external style sheets, 13

filename extension for, 14

linking to documents, 18

linking to multiple documents, 5

multiple, linking to document, 15

persistent style sheets, 17

preferred style sheets, 17

reader style sheets, 6 styles, 19

styling features of CSS, 3

styling, rich, 3

superscripting, 139

syntax conventions used in this book, xii

system colors, 398

system fonts, 123, 395

## T

table captions, 343

table columns, 340

table element, 341

internal table elements, 339

layer for, 349

table footers, 342

table headers, 342

table-layout property, 359, 480

tables, 339-369, 478-480

anonymous table objects, 345

arrangement rules for, 339

automatic layout for, 362, 480

block-level, 341

captions for, 350

fixed-layout model for, 360

headers for, spoken, 432, 488

height of, 365

hidden borders and, 224

inline-level, 341

layers of, 349

missing components of, 345

row primacy model for, 344

specifying elements for, 341

width of, 359

tags, 12

tbody element, 342

td element, 343

teletype printers, media type for, 15

television, media type for, 15

text, 128

aligning horizontally, 474

aligning vertically, 134

blinking, 148, 475

carriage returns in, 154

centering, 132

color of, 149, 151

drop shadows for, 152

hyphenation of, 133

indenting, 128, 475

leading, 134

letter spacing of, 145

overlining, 148
shadows for, 483

strikethru, 148

underlining, 148, 150

whitespace between words and lines, 153

wrapping, 154

text attribute, body element, replacing using color property, 249

text-align property, 131, 474

compared to margin-left and margin-right, 165

for cell content, 366

for table captions, 351

text-bottom alignment, 140

text-decoration property, 148, 475

text-indent property, 128, 475

text-shadow property, 483

text-transform property, 146, 475

tfoot element, 342

th element, 343

thead element, 342

ThreeDDarkShadow system color, 399

ThreeDFace system color, 399

ThreeDHighlight system color, 399

ThreeDLightShadow system color, 399

ThreeDShadow system color, 399

tilde ( ) in attribute selectors, 41

tiling of background images, 256, 257, 451

time values, 92

title attribute

attribute selectors used with, 39

link tag, 16

toolbars, displaying links across horizontally, 202

tooltips, attribute selectors used with, 39

top alignment, 140

top property, 476

tr element, 342

transparent borders, 233

tty media type, 15

tv media type, 15

type attribute, link tag, 14

type selectors, 491

typographical conventions used in this book, xi

## U

underline keyword, 91

underlined text, 148

unicode-bidi property, 476

Uniform Resource Identifier, 93 units and values, 77-93

units for aural styles, 92

universal selector, 28, 491

in class selectors, 32,34

in ID selectors, 36

specificity of, 70

URI (Uniform Resource Identifier), specifying, 93

URL (Uniform Resource Locator)

relative to style sheet, 91

specifying, 90

user agents, 8

as origin of declarations, 71,72

default styles of, 72

Emacspeak, 93

Fonix SpeakThis, 430

weight of declarations and, 72

user interface

colors for, 398

cursors, 400

fonts for, 395

user interface styles, 395-410

## V

value of property, 24, 26

colors as, 78

keywords as, 91

URLs as, 90

values and units, 77-93

vertical alignment of inline nonreplaced elements, 186

of table cell content, 366

of text, 137

vertical bar ( $\mid$ )

in attribute selector, 43

in property syntax, xii

vertical double bar $(\mid)$ in property syntax, xii

vertical formatting, of block-level elements, 170

vertical-align property, 186,476

for table cell content, 366

text-decoration and, 150

visibility of elements, 316,477

visibility property, 316,477

visual styles, 482

vlink attribute, body element, 52, 249

voice used for speaking, 436, 486, 487, 489

voice-family property, 436, 490

volume of speech, 490

volume property, 434, 490

## W

W3C, 3

waiting cursor, 403

watch cursor, 403

web sites

for this book, xiv

O'Reilly Media, Inc., xiv

Web, history of, 1

web-safe colors, 83

white-space property, 153, 477

whitespace, handling, 477

widows property, 422, 424, 481

width property, 161, 208, 308, 477

affect of negative margins on, 166

columns and column groups, 345

positioned elements and, 307

replaced elements and, 169

setting to auto, 163

wildcard, 28

Window system color, 400

WindowFrame system color, 400
WindowText system color, 400

words, spacing between, 143, 144, 478

word-spacing property, 143, 478

World Wide Web, 1

World Wide Web Consortium (W3C), HTML elements deprecated by, 3

wrapping text, 154

## $\mathrm{X}$

XHTML

CSS and, $11-21$

deprecated elements in, 7, 21

specification, 7

XML

element selectors for, 24

replacing HTML, 7

## Z

z-axis, absolute positioning on, 478

z-index property, 478

## About the Author

Eric A. Meyer has been working with the Web since late 1993 and is an internationally recognized expert on the subjects of HTML, CSS, and web standards. A widely read author, he is also the founder of Complex Spiral Consulting (www.complexspiral.com), which counts among its clients America Online; Apple Computer, Inc.; Wells Fargo Bank; and Macromedia, which described Eric as "a critical partner in our efforts to transform Macromedia Dreamweaver MX 2004 into a revolutionary tool for CSS-based design."

Beginning in early 1994, Eric was the visual designer and campus web coordinator for the Case Western Reserve University web site, where he also authored a widely acclaimed series of three HTML tutorials and was project coordinator for the online version of the Encyclopedia of Cleveland History and the Dictionary of Cleveland Biography, the first encyclopedia of urban history published fully and freely on the Web.

Author of Eric Meyer on CSS and More Eric Meyer on CSS (New Riders), Cascading Style Sheets: The Definitive Guide (O'Reilly), and CSS2.0 Programmer's Reference (Osborne/McGraw-Hill), as well as numerous articles for the O'Reilly Network, Web Techniques, and Web Review, Eric also created the CSS Browser Compatibility Charts and coordinated the authoring and creation of the W3C's official CSS Test Suite. He has lectured to a wide variety of organizations, including Los Alamos National Laboratory, the New York Public Library, Cornell University, and the University of Northern Iowa. Eric has also delivered addresses and technical presentations at numerous conferences, among them An Event Apart (which he cofounded), the IW3C2 WWW series, Web Design World, CMP, SXSW, the User Interface conference series, and The Other Dreamweaver Conference.

In his personal time, Eric acts as List Chaperone of the highly active css-discuss mailing list (www.css-discuss.org), which he cofounded with John Allsopp of Western Civilisation, and which is now supported by evolt.org. Eric lives in Cleveland, Ohio, which is a much nicer city than you've been led to believe. For nine years he was the host of "Your Father's Oldsmobile," a Big Band-era radio show heard weekly on WRUW 91.1 FM in Cleveland.

You can find more detailed information on Eric's personal web page at http:// www.meyerweb.com/eric.

## Colophon

Our look is the result of reader comments, our own experimentation, and feedback from distribution channels. Distinctive covers complement our distinctive approach to technical topics, breathing personality and life into potentially dry subjects.

The animals on the cover of CSS: The Definitive Guide, Third Edition, are salmon (salmonidae), which is a family of fish consisting of many different species. Two of the most common salmon are the Pacific salmon and the Atlantic salmon.

Pacific salmon live in the northern Pacific Ocean off the coasts of North America and Asia. There are five subspecies of Pacific salmon, with an average weight of 10 to 30 pounds. Pacific salmon are born in the fall in freshwater stream gravel beds, where they incubate through the winter and emerge as inch-long fish. They live for a year or two in streams or lakes and then head downstream to the ocean. There they live for a few years, before heading back upstream to their exact place of birth to spawn and then die.

Atlantic salmon live in the northern Atlantic Ocean off the coasts of North America and Europe. There are many subspecies of Atlantic salmon, including the trout and the char. Their average weight is 10 to 20 pounds. The Atlantic salmon family has a life cycle similar to that of its Pacific cousins, and also travels from freshwater gravel beds to the sea. A major difference between the two, however, is that the Atlantic salmon does not die after spawning; it can return to the ocean and then return to the stream to spawn again, usually two or three times.

Salmon, in general, are graceful, silver-colored fish with spots on their backs and fins. Their diet consists of plankton, insect larvae, shrimp, and smaller fish. Their unusually keen sense of smell is thought to help them navigate from the ocean back to the exact spot of their birth, upstream past many obstacles. Some species of salmon remain landlocked, living their entire lives in freshwater.

Salmon are an important part of the ecosystem, as their decaying bodies provide fertilizer for streambeds. Their numbers have been dwindling over the years, however. Factors in the declining salmon population include habitat destruction, fishing, dams that block spawning paths, acid rain, droughts, floods, and pollution.

The cover image is a 19th-century engraving from the Dover Pictorial Archive. The cover font is Adobe ITC Garamond. The text font is Linotype Birka; the heading font is Adobe Myriad Condensed; and the code font is LucasFont's TheSans Mono Condensed.


[^0]:    planet[moons] \{font-weight: bold; \}

[^1]:    * Note that there are seven absolute-size keywords, just as there are seven font sizes (e.g., <font size="5">). Since the typical default font size was historically 3 , it makes sense that the third value on the CSS absolutesize keyword list is used to indicate a default font size. Since the third keyword turns out to be small, Explorer behaves accordingly.

[^2]:    Donec ut magna. Aliquam erat volutpat. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nulla facilisi. Aenean mattis, dui et ullamcorper ornare, erat est sodales mi, non blandit sem ipsum quis justo. Nulla tincidunt.

    Quisque et orci nec lacus hendrerit fringilla. Sed quam nibh elementum et, scelerisque a, aliquam vestibulum, sapien. Etiam commodo auctor sapien. Pellentesque tincidunt lacus nec quam. Integer sit amet neque vel eros interdum omare. Sed consequat.

[^3]:    * Hyphenation is not described in CSS because different languages have different hyphenation rules. Rather than try to concoct a set of rules that would most likely be incomplete, the specification simply avoids the problem.

[^4]:    this is text, some of which is emphasized, plus other text

    which is Strong and ${ }^{\text {tall }}$ and which is

    larger than the surrounding text.

[^5]:    p img \{margin-bottom: -10px; \}

[^6]:    <a href="http://www.example.net" style="display: block;">

    <p style="display: inline;">this is wrong!</p>

    </a>

[^7]:    This is a paragraph with some margins, padding, and a background color. Varying the amount of margins and padding can change the look of an element quite a bit, not to mention how it's placed in relation to other elements.

    This is a pargraph with some margins, padding, and a background color. Varying the amount of margins and padding can change the look of an element quite a bit, not to mention how it's placed in relation to other elements.

[^8]:    What they did seems bizarre, but it worked. The merchants rebuilt their businesses right away (using stone and brick this time instead of wood), as they had to do. In the meantime, the project to raise the financial district went ahead more or less as planned, but with one modification. Instead of filling in the whole area, the streets were raised to the desired level. As the filling happened, egach block of businesses would be surrounded by a retaining wall, and the streets between the walls would be filled with dirt. This meant that the sidewalks were actually below street level, once the street was filled in, so pedestrians got to walk along a block, scale a ladder or staircase, cross the street, descend back to sidewalk level, and continue onward.

[^9]:    Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

    Lorem ipsum, dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in

    0 hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

[^10]:    * Yes, the spelling of "positioning" is incorrect, but that's the way the language crumbles. The page is still a good source of information.

[^11]:    table \{border-collapse: separate; \}

    td \{border: 3px double black; padding: $3 p x ;\}$

    <table cellspacing="0">

