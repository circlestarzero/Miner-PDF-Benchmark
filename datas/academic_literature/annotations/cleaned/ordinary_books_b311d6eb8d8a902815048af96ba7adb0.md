# 羔高职高专网络专业系列规划教村 

䣄出媇

## 计算机网络宾全技木



JISUANJI WANGLUO ANQUAN JISHU

大连理工大学出版社

DALIAN UNIVERSITY OF TECHNOLOGY PRESS

## 图书在版编目 $($ CIP $)$ 数据

计算机网络安全技术 / 薛庆水, 朱元忠主编. 一大连:大连理工大学出版社, 2008.2

高职高专网络专业系列规划教材

ISBN 978-7-5611-3856-4

I . 计‥ II . (1)薛‥ (2) 朱… III. 计算机网络一安全技术一高等学校: 技术学校一教材 IV. TP393.08

中国版本图书馆 CIP 数据核字 (2008)第 018527 号

大连理工大学出版社出版

地址: 大连市软件园路 80 号邮政编码: 116023

电话: 0411-84708842邮购:0411-84703636 传真:0411-84701466

E-mail:dutp@dutp.cn URL:http://www.dutp.cn

大连天正华延彩色印刷有限公司印刷 大连理工大学出版社发行

幅面尺寸: $185 \mathrm{~mm} \times 260 \mathrm{~mm}$ 印张: 17.25 字数: 397 千字印数: $1 \sim 4000$

2008 年 2 月第 1 版 2008 年 2 月第 1 次印刷

责任编辑:付 亮

责任校对:张爱华封面设计:苏儒光
我们已经进入了一个新的充满机遇与挑战的时代, 我们已经跨入了 21 世纪的门槛。

20 世纪与 21 世纪之交的中国, 高等教育体制正经历着一场缓慢而深刻的革命, 我们正在对传统的普通高等教育的培养目标与社会发展的现实需要不相适应的现状作历史性的反思与变革的尝试。

20 世纪最后的几年里, 高等职业教育的迅速崛起, 是影响高等教育体制变革的一件大事。在短短的几年时间里,普通中专教育、普通高专教育全面转轨, 以高等职业教育为主导的各种形式的培养应用型人才的教育发展到与普通高等教育等量齐观的地步,其来势之迅猛, 发人深思。

无论是正在缓慢变革着的普通高等教育, 还是迅速推进着的培养应用型人才的高职教育, 都向我们提出了一个同样的严肃问题: 中国的高等教育为谁服务, 是为教育发展自身,还是为包括教育在内的大千社会? 答案肯定而且惟一, 那就是教育也置身其中的现实社会。

由此又引发出高等教育的目的问题。既然教育必须服务于社会, 它就必须按照不同领域的社会需要来完成自己的教育过程。换言之, 教育资源必须按照社会划分的各个专业(行业) 领域(岗位群) 的需要实施配置, 这就是我们长期以来明乎其理而疏于力行的学以致用问题, 这就是我们长期以来末能给予足够关注的教育目的问题。

如所周知, 整个社会由其发展所需要的不同部门构成, 包括公共管理部门如国家机构、基础建设部门如教育研究机构和各种实业部门如工业部门、商业部门,等等。每一个部门又可作更为具体的划分, 直至同它所需要的各种专门人才相对应。教育如果不能按照实际需要完成各种专门人才培养的目标, 就不能很好地完成社会分工所赋予它的使命, 而教育作为社会分工的一种独立存在就应受到质疑( 在市场经济条件下尤其如此)。可以断言, 按照社会的各种不同需要培养各种直接有用人才, 是教育体制变革的终极目的。

随着教育体制变革的进一步深入, 高等院校的设置是否会同社会对人才类型的不同需要一一对应, 我们姑且不论。
但高等教育走应用型人才培养的道路和走研究型( 也是一种特殊应用) 人才培养的道路, 学生们根据自己的偏好各取所需, 始终是一个理性运行的社会状态下高等教育正常发展的途径。

高等职业教育的崛起,既是高等教育体制变革的结果, 也是高等教育体制变革的一个阶段性表征。它的进一步发展,必将极大地推进中国教育体制变革的进程。作为一种应用型人才培养的教育, 它从专科层次起步, 进而应用本科教育、应用硕士教育、应用博士教育……当应用型人才培养的渠道贯通之时, 也许就是我们迎接中国教育体制变革的成功之日。从这一意义上说, 高等职业教育的崛起, 正是在为必然会取得最后成功的教育体制变革奠基。

高等职业教育还刚刚开始自己发展道路的探索过程,它要全面达到应用型人才培养的正常理性发展状态, 直至可以和现存的(同时也正处在变革分化过程中的)研究型人才培养的教育并驾齐驱, 还需假以时日; 还需要政府教育主管部门的大力推进, 需要人才需求市场的进一步完善发育, 尤其需要高职高专教学单位及其直接相关部门肯于做长期的坚忍不拔的努力。新世纪高职高专教材编审委员会就是由全国 100 余所高职高专院校和出版单位组成的旨在以推动高职高专教材建设来推进高等职业教育这一变革过程的联盟共同体。

在宏观层面上, 这个联盟始终会以推动高职高专教材的特色建设为已任, 始终会从高职高专教学单位实际教学需要出发, 以其对高职教育发展的前瞻性的总体把握, 以其纵览全国高职高专教材市场需求的广阔视野, 以其创新的理念与创新的运作模式, 通过不断深化的教材建设过程, 总结高职高专教学成果, 探索高职高专教材建设规律。

在微观层面上, 我们将充分依托众多高职高专院校联盟的互补优势和丰裕的人才资源优势, 从每一个专业领域、每一种教材入手, 突破传统的片面追求理论体系严整性的意识限制, 努力凸现高职教育职业能力培养的本质特征, 在不断构建特色教材建设体系的过程中,逐步形成自己的品牌优势。

新世纪高职高专教材编审委员会在推进高职高专教材建设事业的过程中, 始终得到了各级教育主管部门以及各相关院校相关部门的热忱支持和积极参与, 对此我们谨致深深谢意; 也希望一切关注、参与高职教育发展的同道朋友, 在共同推动高职教育发展、进而推动高等教育体制变革的进程中,和我们携手并肩,共同担负起这一具有开拓性挑战意义的历史重任。
随着信息技术的迅猛发展和广泛应用,社会信息化进程不断加快, 信息网络的基础性、全局性作用日益增强。社会对信息化的依赖性也越来越强, 信息网络的安全问题愈加重要。

当前, 伴随着我国社会主义市场经济的快速发展, 中国即将或已经成为世界制造业中心, 各行各业越来越需要具有综合职业能力和全面素质的, 直接工作在生产、技术、管理和服务第一线的应用型、技能型的高级实用人才。可以预见, 高等职业技术教育即将和高等教育的本科教育相提并论, 并且在我国高等教育体系中占有相当重要的地位。

高职教育作为我国高等教育的一个重要组成部分, 其培养目标是具有必要理论知识和较强实践能力的高等技术应用型专门人才。它的人才培养以适应生产、建设、管理、服务第一线需要的高等技术应用型专门人才为根本任务; 以适应社会需要为目标; 以培养技术应用能力为主线; 以突出职业性、实践性、适应性和地方性为特点。在计算机教学中, 应以传授应用知识为主, 强调操作使用, 注重培养学生利用计算机开展专业技术分析、解决各种技术问题的意识, 培养学生的自学能力和创造性学习的能力为目标。

密切结合高职教育的特点, 在编写本教材时, 对于计算机网络安全的理论知识和工作原理介绍得简单一些, 更多的内容侧重于对计算机具体网络安全技术的应用的介绍, 体现出注重培养学生实际应用技术能力的特点。在内容的安排上,每章后面都安排了适量的练习与实验题目, 并且都配有参考答案, 方便教师的教学与学生的自学。在编写的过程中, 力求体现教材的系统性、先进性和实用性。

全书共分 14 章, 第 1 章介绍了有关计算机网络安全的各种基本概念、基本知识, 使学生对计算机网络安全有一个基本的、总体的认识和了解。第 2 章介绍了网络安全的基本概念和网络安全的体系框架等, 要求了解相关的概念, 掌握网络安
全的体系框架和网络安全系统的功能, 了解 OSI 参考模型的安全问题。第 3 章介绍了网络数据包的结构与数据包截获的原理和分析方法, 讲述了 Sniffer 软件的使用方法, 使学生对网络数据包的结构与截获和分析有一个全面的认识。第 4 章介绍了数据加密技术, 在阐述了一些基本概念之后给出了几种在 Internet 中常见的数据加密技术, 使学生掌握数据保护的有关知识。第 5 章介绍密钥管理方法, 包括密钥的管理内容、分配技术, 重点介绍与当前网络应用的发展密切相关的公开密铜管理体制, 使学生能掌握密钥的管理方法和管理体制。第 6 章介绍数据完整性保护技术, 包括信息摘要技术和数字签名技术, 使学生能掌握保护数据完整性的各种技术。第 7 章介绍数据鉴别技术的基本方法以及在 Internet 中常见的数据鉴别技术, 使学生能够理解和掌握各种数据鉴别技术。第8 章介绍单机和网络的访问控制问题, 使学生了解访问控制的基本原理和常用的防火墙技术。第 9 章介绍了计算机病毒的概念、计算机病毒的发展史与危害, 以及计算机病毒的主要特性、计算机病毒的分类、查杀与防范方法等。第 10 章以 Internet 的安全为背景, 介绍了网络攻防技术的基本原理, 使学生能够了解各种网络入侵和网络攻击技术,掌握安全防范和安全监测的基本原则和一般方法。第 11 章以 IETF 安全领域中一些工作组的工作内容为背景介绍了 Internet 基础设施安全方面的一些新进展,使学生能够追踪有关网络安全领域前沿的研究方向和研究课题。第 12 章介绍 Internet 部分网络基础设施 DNS 及 PGP。第 13 章介绍了操作系统安全的基本概念、访问控制的概念、类型与措施、Windows 系列操作系统、UNIX 和 Linux 系统的安全漏洞与安全措施。第 14 章介绍了计算机信息系统安全评价标准,要求掌握美国可信计算机系统评价标准中对计算机系统的安全划分的七个级别, 三个大类。

本书内容安排合理, 逻辑性强, 文字简明, 循序渐进, 通俗易懂, 适合高职高专信息安全专业学生的专业教学使用, 也适合计算机类本科专业学生和各种网络安全的培训班使用。

本书由薛庆水、朱元忠任主编。朱元忠编写了第 1 2、11、12、14 章, 汪进编写了第 $3 、 9$章, 梁立哲编写了第 4 章, 薛庆水编写了第 $5 \sim 7,13$ 章, 在统稿的过程中, 朱元忠对第 $8 \sim 12$章进行了审阅, 全书由薛庆水统阅定稿。在书的编写过程中, 还有其他一些作者参与。

在本书的立项、大纲的编写和内容的确定以及编写过程中得到了大连理工大学出版社各位同志的大力支持和帮助, 在此表示衰心的感谢。特别感谢北京大学计算机科学技术系的唐礼勇副教授在大纲的修改与确定中所提出的宝贵意见和建议。同时,感谢刘远生教授在教材编写过程中给予的指导和帮助。

由于时间仓促和作者水平有限, 书中难免存在错误、缺点与不足, 恳请各位学者、专家、老师和同学提出宝贵意见。

所有意见和建议请发往: gzjckfb@163.com

联系电话:0411-84707492

编 者

2008 年 1 月
第 1 章 网络安全概述 ..... 1
1.1 网络安全的定义 ..... 1
1.2 网络安全事件速览 ..... 2
1.2 .1 网络安全事件的起源 ..... 2
1.2.2 网络一一盗窃钱财的新途径 ..... 2
1.2 .3 网络一宣泄情绪的途径 ..... 4
1.3 中国网络安全形势严峻 ..... 4
1.4 网络安全概述小结 ..... 5
第 2 章 网络安全体系结构 ..... 6
2.1 网络安全基本概念 ..... 6
2.2 网络安全体系结构框架 ..... 7
2.3 网络安全系统的功能 ..... 8
2.4 OSI 参考模型的安全问题 ..... 8
第 3 章 网络数据包结构与安全 ..... 11
3.1 分组交换与数据包的结构 ..... 11
3.1 .1 什么是分组交换和数据包 ..... 11
3.1 .2 信息传输过程与数据包的结构 ..... 12
3.1.3 学习网络协议在网络安全中的意义 ..... 13
3.2 数据包的捕获与分析 ..... 14
3.2 .1 数据包截获的原理 ..... 14
3.2 .2 数据截获的方法 ..... 16
3.2.3 Sniffer Portable 软件介绍 ..... 16
3.2.4 数据的捕获与过滤 ..... 19
3.3 数据的分析 ..... 23
3.3.1 TCP/IP 协议 ..... 24
3.3.2 利用 Sniffer Portable 分析网络协议 ..... 24
3.3.3 网络层协议报头结构 ..... 26
3.3.4 传输层协议报头结构 ..... 32
3.4 数据的安全 ..... 35
3.4 .1 安全隐患 ..... 35
3.4 . 2 提高网络安全性,防止网络咊探的措施 ..... 37
第 4 章 数据加密技术 ..... 41
4.1 数据加密技术概述 ..... 42
4.1 .1 密码技术的起源和发展 ..... 42
4.1 .2 密码学的基本概念 ..... 42
4.1 .3 密码的分类 ..... 43
4.2 传统密码体制 ..... 44
4.2 .1 代替密码 ..... 44
4.2 .2 移位密码 ..... 45
4.2 .3 一次一密钥密码 ..... 46
4.3 现代密码体制 ..... 46
4.3 .1 对称密码体制 ..... 46
4.3 .2 非对称密码体制 ..... 67
4.4 混合加密方法 ..... 70
4.5 Internet 中常用的数据加密技术 ..... 71
第 5 章 密钥管理 ..... 75
5.1 密钥管理的内容 ..... 75
5.1 .1 密钥的组织结构 ..... 76
5.1 .2 密钥生成 ..... 77
5.1 .3 密钥储存和保护 ..... 77
5.1 .4 密钥更新 ..... 78
5.1 .5 密钥分发 ..... 78
5.1 .6 密钥验证 ..... 78
5.1 .7 密钥使用 ..... 79
5.1 .8 密钥备份 ..... 79
5.1 .9 密钥销毁 ..... 79
5.2 密钥分配 ..... 79
5.2 .1 密钥分配中心方式 ..... 79
5.2.2 Diffie-Hellman 方法 ..... 80
5.2 .3 加密的密钥交换 ..... 81
5.2 .4 增强的密钥协商方法 ..... 82
5.3 公钥的全局管理 ..... 82
5.3 .1 公钥的用途 ..... 82
5.3 .2 签名密钥和加密密钥 ..... 82
5.3 .3 公钥的产生 ..... 83
5.3 .4 公钥的获取 ..... 83
5.3 .5 密钥备份和恢复 ..... 83
5.3 .6 基于 X. 509 证书的 PKI ..... 84
第 6 章 数据的完整性保护 ..... 93
6.1 信息摘要技术 ..... 94
6.1 .1 基本原理 ..... 94
6.1.2 MD5 算法 ..... 94
6.1 .3 安全散列标准 ..... 97
6.1 .4 HM AC ..... 99
6.2 数字签名 ..... 102
6.2 .1 数字签名的概念 ..... 102
6.2 .2 基于公钥密码体制的数字签名 ..... 103
6.2 .3 基于私铜密码体制的数字签名 ..... 104
6.2.4 数字签名标准 DSS ..... 104
第 7 章 身份鉴别技术 ..... 110
7.1 鉴别概述 ..... 110
7.1 . 1 实体鉴别和数据源发鉴别 ..... 110
7.1 .2 单向散列函数 ..... 112
7.2 鉴别机制 ..... 113
7.2 .1 非密码的鉴别机制 ..... 113
7.2 .2 采用对称密码的鉴别机制 ..... 115
7.2 .3 采用公钥密码体制的鉴别机制 ..... 116
7.3 Kerberos 系统 ..... 117
7.3.1 Kerberos 的认证方案 ..... 117
7.3.2 Kerberos 的局限性 ..... 118
7.4 GSSAPIv2 ..... 118
7.4.1 单 TGT 的 Kerberos ..... 119
7.4 .2 双 TGT 的 Kerberos ..... 119
第 8 章 访问控制及防火墙 ..... 122
8.1 访问控制的基本原理 ..... 122
8.2 常见操作系统的访问控制 ..... 125
8.2.1 Windows 2000 中的访问控制 ..... 125
8.2.2 Linux 中的访问控制 ..... 127
8.3 防火墙技术 ..... 127
8.3 .1 防火墙的概念 ..... 127
8.3 .2 防火墙的技术分类 ..... 128
8.3.3 防火墙的主要技术参数 ..... 133
8.3 .4 防火墙基本体系结构 ..... 134
8.3 .5 防火墙的部署 ..... 135
8.3 .6 防火墙设置案例 ..... 136
8.3.7 Linux 内核防火墙 ..... 139
第 9 章计算机病毒与防御 ..... 145
9.1 计算机病毒的概念 ..... 145
9.1.1 计算机病毒的定义 ..... 145
9.1 .2 计算机病毒的发展史 ..... 146
9.1 .3 计算机病毒的危害 ..... 148
9.1 .4 计算机病毒的主要特性 ..... 149
9.2 计算机病毒的种类 ..... 151
9.2 .1 文件型病毒 ..... 151
9.2.2引导型病毒 ..... 152
9.2 .3 宏病毒 ..... 152
9.2 .4 网页脚本程序病毒 ..... 153
9.2 .5 蠕虫 ..... 154
9.2 .6 特洛伊木马 ..... 155
9.3 计算机病毒的查杀与防范方法 ..... 156
9.3 .1 杀毒软件工作原理 ..... 156
9.3 . 2 如何使用杀毒软件 ..... 157
9.3 .3 计算机病毒的预防 ..... 162
第 10 章 网络攻防技术 ..... 170
10.1 网络攻击 ..... 170
10.1.1 网络攻击概念 ..... 170
10.1 .2 网络攻击分类 ..... 170
10.1 .3 网络攻击的一般过程 ..... 171
10.2 网络入侵技术 ..... 172
10.2 .1 端口扫描 ..... 172
10.2 .2 漏洞扫描 ..... 173
10.2 .3 网络监听 ..... 177
10.2 .4 口令破译 ..... 177
10.3 网络攻击技术 ..... 181
10.3 .1 拒绝服务攻击 ..... 181
10.3 .2 后门和特洛伊木马攻击 ..... 183
10.3 .3 缓冲区溢出攻击 ..... 184
10.4 安全防范和安全监测 ..... 184
10.4 .1 安全防范 ..... 184
10.4 . 2 安全监测技术 ..... 185
第 11 章 IP 与 TCP 安全 ..... 196
11.1 IPsec 简介 ..... 196
11.1.1 IPSec 协议簇 ..... 196
11.1.2 IPSec 的工作方式 ..... 197
11.1.3 AH(认证头) ..... 198
11.1 ESP(封装安全有效载荷) ..... 199
$11.1 .5 \mathrm{IKE}$ (密钥交换) ..... 199
11.1.6 IPSec 的实施 ..... 200
11.1.7 IPSec 的应用 ..... 201
11.2 网络传输服务的安全性 ..... 201
11.2.1 SSL 的安全性 ..... 201
11.2.2 TLS 的安全性 ..... 202
第 12 章 Internet 的基础设施安全 ..... 212
12.1 DNS 安全 ..... 212
12.1.1 DNS 基本概念 ..... 212
12.1.2 DNS 安全级别 ..... 213
12.1.3 DNS 安全面临的挑战 ..... 215
12.1.4 DNS 安全攻击与防范 ..... 215
12.2 PGP 的使用 ..... 216
12.3 SHTTP 的安全性 ..... 223
12.4 SSH 的安全性 ..... 223
第 13 章 网络操作系统安全 ..... 230
13.1 网络操作系统 ..... 230
13.2 操作系统的安全与访问控制 ..... 231
13.2 .1 操作系统安全 ..... 231
13.2 .2 访问控制的涵义 ..... 232
13.2 .3 访间控制的类型 ..... 232
13.2 .4 访问控制措施 ..... 233
13.3 Windows NT 系统安全 ..... 235
13.3.1 Windows N T 的安全基础 ..... 236
13.3.2 Windows NT 的安全漏洞 ..... 238
13.3.3 Windows N T 的安全性机制和技术 ..... 239
13.3.4 Windows N T 的安全管理措施 ..... 241
13.3.5 Windows NT 的数据保护 ..... 242
13.4 Windows 2000 安全 ..... 244
13.4.1 Windows 2000 的安全漏洞 ..... 244
13.4.2 Windows 2000 的安全性措施和技术 ..... 246
13.5 其他网络操作系统的安全 ..... 250
13.5.1 UNIX 系统安全 ..... 250
13.5.2 Linux 系统安全 ..... 253
第 14 章 计算机信息系统安全评价标准 ..... 260
参考文献 ..... 263

## 第

7 章

## 网络安全概述



网络安全基本概念。

## 本章重点与难点

## 教学要求

介绍网络安全的定义,通过讲述历史上的网络安全事件, 激发学生学习网络安全的兴趣, 结合网络安全事件的介绍, 讲述网络安全的基本概念。网络安全的定义

计算机网络安全是指计算机及其网络系统资源和信息资源不受自然和人为有害因素的威胁和危害, 即指计算机、网络系统的硬件、软件及其系统中的数据受到保护, 不因偶然的或者恶意的原因而遭到破坏、更改和泄露, 确保系统能连续可靠正常地运行, 使网络服务不中断。计算机网络安全从其本质上来讲就是系统上的信息安全。计算机网络安全是一门涉及计算机科学、网络技术、密码技术、信息安全技术、应用数学、数论和信息论等多种学科的综合性科学。

从广义来说,凡是涉及到计算机网络上信息的保密性、完整性、可用性、真实性和可控性的相关技术和理论都是计算机网络安全的研究领域。所以,广义的计算机网络安全还包括信息设备的物理安全性,诸如场地环境保护、防火措施、防水措施、静电防护、电源保护、空调设备、计算机辐射和计算机病毒等。

网络安全的定义中, 涉及一些网络领域的专业术语, 我们可以从后面的学习中逐渐深人了解它们。



### 1.2.1 网络安全事件的起源

1979 年,年仅 15 岁的凯文・米特尼克仅凭一台电脑和一部调制解调器闯人了北美空中防务指挥部的计算机主机。在 “以信任对方”为前提的高校实验室中诞生的诸多网络协议,不仅让当时的恶意攻击者有机可乘, 而且时至今日也成为一些攻击的原罪, 如利用 TCP/IP 三次握手的 SYN FLOOD 、SMTP 的伪造信息头和更改源地址的重定向攻击等等,都是利用了协议的漏洞。

1983 年,美国联邦调查局首次逮捕了 6 名少年黑客,这 6 名少年黑客被控侵人 60 多台电脑, 其中包括斯洛恩 - 凯特林癌症纪念中心和洛斯阿拉莫斯国家实验室。用计算机从事破坏活动的性质被确定为“犯罪”, 就是从这时候开始的。

1987 年,美国联邦执法部门指控 16 岁的赫尔伯特 - 齐恩闯人美国电话电报公司的内部网络和中心交换系统。齐恩是美国 1986 年“计算机欺计与滥用法案”生效后被判有罪的第一人。利用计算机和网络进行犯罪的“有法可依”, 给假借黑客之名进行犯罪之实的家伙们敲响了警钟。

1988 年, 美国康奈尔大学研究生罗伯特・莫里斯向互联网传输了一个蠕虫程序, 感染了 6000 多个系统一几乎占当时互联网的十分之一。同年,在发现有黑客人侵军事网的一部联网电脑后, 美国国防部切断了非保密军事网与阿帕网 (早期互联网)之间的物理连接。有人问过, “怎样才能做到服务器绝对安全?”回答是: “拔掉网线 !”但这样就不能提供服务了。因此,所有尽责的网络管理员所能做到的,只是尽力接近安全而已。

### 1.2.2 网络一盗窃钱财的新途径

早期的网络安全事件,多因黑客为炫耀技术而起,这也是时至今日, 黑客们制造的许多网络安全事件仍能得到大多数网民原谅的主要原因。但是随着互联网应用的深人发展, 网络蕴藏着巨大的商机和通过网络产生的巨大的经济利益驱使许多技术高超的黑客走向商业犯罪。

## 1. 世界范围内的网络盗窃

1995 年, “世界头号电脑黑客”凯文・米特尼克被捕。他被指控闯人许多电脑网络,包括人侵北美空中防务体系和美国国防部,偷窃了 2 万个信用卡号和复制软件。同年,俄罗斯黑客列文在英国被捕。他被指控用笔记本电脑从纽约花旗银行非法转移至少 370 万美元到世界各地由他和他的同党控制的账户。这类事件不断上演, 是不是将你心目中的黑客拉下了神台?

## 2.“网络钓鱼”钓你钱财

2005 年 1 月,一个假冒中国工商银行的网站出现在互联网上,诱骗银行卡持有者的账户和密码, 并导致多人的银行存款被盗, 直接经济损失达 800000 元人民币。事发后, 引起各大银行的重视,中行、工行和农行等多家银行均迅速在其网站上发表“敬告客户”或“安全提
示”的信息,提示其网上银行客户登录合法网址。“网络钓鱼”作为一种网络计骗的新手段,出现在国人面前。

在中国, “网络钓鱼”暂时还没有造成过多的损失,但随着宽带网络进一步普及,用户将面临更多的线上交易安全风险。2004 年,国家计算机网络应急技术处理协调中心共接到网络仿冒报告 223 起,仿冒对象主要是金融网站和电子商务网站。而在 2002 年和 2003 年,每年只有一起, 同比增长了上百倍。2005 年, 假冒网站数量进一步增加。

“网络钓鱼”这种攻击方式利用欺骗性的电子邮件、手机短信以及伪造的 Web 站点等来进行诈骗活动,欺骗者通常会找一个看似正当的理由。例如: 提示你为了保证你的银行卡安全, 要求你在线更改你的信用卡密码, 然后将用户引诱至某个著名企业的假冒网站。这些假冒的网站域名与企业真正的域名非常相近，如假冒中国工商银行域名是 www.1cbc.com.cn, 与中国工商银行网站 www.icbc.com.cn，也只是“ 1 ” 和“i”一字之差。

在假冒网站的首页通常会有一个仿冒的密码输人框, 提示你输人账户和密码, 然后将用户输人的内容通过邮件等方式发给欺骗者。受骗者往往会泄露自己的财务数据, 如信用卡号、账户用户名和口令等内容。“网络钓鱼”这种攻击方式最大的特点是不需要主动攻击, 欺骗者只需要静静等候上当的“鱼儿”就可以了。

网上交易已经是大家相当熟悉的交易方式了,网上交易的安全性是整个网上交易的重心。可是频频发生的假冒网上银行和银行卡短信欺计事件让人们在感受到互联网带来的便捷的同时, 也感受到它极大的风险性。好在现在国家立法对网上交易进行规范, 相信随着法规的不断完善和人们安全意识的提高, “网上钧鱼”这种欺骗手段终将消失。

## 3. 网上团伙作案逐渐呈现

日前,宁波警方在安徽警方的配合下, 将正在网吧里聊天的徐某抓获。这位年仅 17 岁的少年就是年初发生的利用 “黑客”技术盗窃网上银行存款一案的主谋。而在他的 QQ 好友名单里竟有近二百名“志同道合”的少年“黑客”。

2005 年 1 月 4 日,宁波张女士的网易电子邮箱收到一封自称是网易公司员工发来的邮件, 说张女士的邮箱中奖了, 只需提供本人身份证号码和家庭住址即可得到一台价值近万元的索尼 DV 摄录机。信里还留有联系电话和电子邮箱。第二天, 张女士把身份证号码和家庭住址告诉了对方。当晚,她发现网上银行账户里的存款少了近五千元人民币。1 月 6 日，张女士赶紧把十多万余款全部取出并向宁波江北区警方报案。

经过调查, 警方发现电子邮件来自注册在成都的一个私人网站, 登记邮编是安徽省马鞍山市新市镇, 在案发后两天就关闭了。与此同时, 警方综合另外几条线索, 初步断定嫌疑人很可能是新市镇当地人。历时两个月的不解追踪, 嫌疑人徐某终于被抓获。

徐某交代, 因为现在互联网上的很多游戏都需要用钱去购买虚拟币才能玩, 所以他学了些“黑客”知识后开始盗用他人的虚拟币, 再转卖给他人, 每月收人可达数千元。因为一条偶然看到的新闻, 他就开始了通过骗取他人网上账户信息盗取存款的不法行为。如此简便的挣钱方式一度让他特有成就感。也因此, 这位来自普通家庭的少年一直混迹在安徽、湖南、湖北等地网吧,花钱如流水,身边女友不断。

然而, 相对于案件个体, 意外在徐某 QQ 上发现的近二百位“少年黑客兵团”名单更让警方震惊和担忧。这些同龄人唯徐某马首是瞻, 按各自的“攻关”级别以“总、军、师”和“首长”等头衔称呼, 俨然就是一个组织严密的 “少年黑客兵团”。徐某亦承认, 平时这些成员就是利
用“黑客”技术,盗窃他人的 Q币和虚拟装备。

有关人士指出, 互联网的兴盛引起了全球新一轮的技术更迭, 但同时对社会其他领域也形成了比较大的影响。对青少年而言, 他们对新事物新变化的接受力非常强, 适应能力也相当高,这也就使青少年的教育问题更加复杂、严峻,必须引起足够的重视。

### 1.2.3 网络一一宣泄情绪的途径

尽管黑客文化正在逐渐由大众回归小众, 但伴随着中国外交摩擦而发生的小规模黑客冲突从来没有停止过。当我们回过头来反思黑客江湖的浮躁, 我们无法忘记 1999 年那个愤怒的夏天, 当看到白宫网站上飘扬的五星红旗时, 心里忍不住浮动的快意。从根本意义上说, 网络黑客所采取的手段和大学生对美国大使馆扔石头和墨水瓶没有什么两样, 那只是一种宣泄的手段,追求的不是攻击性。

中国科学院新闻与传播研究所教授闵大洪说, 在 1998 年以前, 中国发生的历次大事件中, 国外所能听到的只有中国官方的声音, 而在印尼排华潮后, 中国网民用自己的行动, 将自己的声音直接传达到他们想传达的对象面前。

关于中美黑客大战以及中国网民对于印尼排华事件的反应大家可以通过互联网络查询, 来了解事件的详情。



由于计算机和国际互联网的飞速普及, 中国目前已经成为多手可热的黑客攻击目标。据 2005 年的统计, 全球每天有 15 万台 PC 机处于随时可能被攻击的失控状态, 而其中有 $20 \%$ 的 PC 机来自中国。

## 1. 盗版软件无法升级成软助

这些可以被黑客远程攻击的 PC 机被称为 “zombies(僵系统)”。“僵系统” 的特点是, 它为黑客开了一道“后门”, 黑客可以随时通过远程方式对该系统“指手画脚”。一般情况下, 黑客会利用这些大量的“僵系统”传播病毒或垃圾邮件。

在中国, 网民越来越多, 许多网民并不精通计算机技术, 有些甚至还是首次接触互联网,专家指出: “对于一些没有计算机安全知识的用户, 如果他们经常在线, 那将是一件很危险的事情。” 另外, 由于很多人没有及时安装补丁程序, 使得这些系统更易受到病毒的攻击。而且, 关于及时更新补丁程序问题, 这一直是中国计算机用户的一个“痛处”。因为中国的盗版软件比较普遍, 而微软已表示, 不再支持盗版 Windows 升级。此外, 语言障碍也是导致中国计算机用户容易受到攻击的原因之一。目前, 中国有 20 种方言, 如果微软发布一款补丁程序, 不可能得到所用网民的一致关注。

## 2. 网民应该采取预防措施

目前, 计算机和互联网在中国已十分普及。据统计数据显示, 每年至少有 1490 万台 PC 机出货到中国。到 2010 年, 中国还将新增 1.78 亿台 PC 机。互联网的使用率则增长了 $18 \%$ 。截止 2007 年 6 月,中国有网民 1.62 万。

用户接人互联网的方式将直接影响到病毒的传播力度。通常, 黑客主要攻击的是宽带
接人用户。而目前, 中国网民的宽带接人率极高,上网地点主要集中在企业、政府机构和网吧。

安全专家 Raffael Marty 表示, 要维护计算机系统安全, 用户必须要采取一些基本预防措施。他说: “不要从不明来源下载未知程序, 通过防火墙来阻挡未知应用, 并及时对系统和防病毒软件进行升级。”

Sonic Wall 公司安全服务副总裁 BorisYanovsky 表示, 将有大量的黑客攻击事件发生,因为他们的攻击行为已经转变为出于经济目的。

## 网络安全概迷小结

通过前面的网络安全事件, 我们可以了解到目前网络安全面临的问题是比较多的, 学习网络安全, 就要密切关注网络安全事件发生的起因和形式,进而找出相应的防范措施, 尽力使网络变得更安全。

## 习习题

1.1 通过网络检索, 结合书中的案例, 举例说明有哪几种形式的网络安全事件。

1.2 结合自己使用电脑上网的经历, 介绍自己上网遇到的网络安全事件并说明解决的过程。

## 第

## 网络安全体系结构



本章重点与难点

网络安全体系结构框架。

## 教学要求

本章介绍了网络安全的基本概念和网络安全的体系框架等,要求了解相关的概念, 掌握网络安全的体系框架和网络安全系统的功能, 了解 OSI 参考模型的安全问题。

计算机网络安全体系结构是网络安全最高层的抽象描述。在大规模的网络工程建设和管理,以及基于网络的安全系统的设计与开发过程中,需要从全局的体系结构角度考虑安全问题的整体解决方案, 才能保证网络安全功能的完备性与一致性, 降低安全的代价和管理的开销。这样一个安全体系结构对于网络安全的理解、设计、实现与管理都有重要的意义。

## 网络安全基本概念

计算机网络安全是指计算机及其网络系统资源和信息资源不受自然和人为有害因素的威胁和危害, 即是指计算机、网络系统的硬件、软件及其系统中的数据受到保护, 不因偶然的或者恶意的原因而遭到破坏和更改、泄露, 确保系统能连续可靠正常地运行, 使网络服务不中断。计算机网络安全从其本质上来讲就是系统上的信息安全。计算机网络安全是一门涉及计算机科学、网络技术、密码技术、信息安全技术、应用数学、数论和信息论等多种学科的综合性科学。

从广义来说,凡是涉及到计算机网络上信息的保密性、完整性、可用性、真实性和可控性的相关技术和理论都是计算机网络安全的研究领域。所以,广义的计算机网络安全还包括信息设备的物理安全性,诸如场地环境保护、防火措施、防水措施、静电防护、电源保护、空调设备、计算机辐射防护和计算机病毒防护等。

## 2.2

## 网络安全体系结构框架

一般把计算机网络安全看成一个由多个安全单元组成的集合。其中,每一个安全单元都是一个整体, 包含了多个特性。可以从安全特性的安全问题、系统单元的安全问题以及开放系统互连 (ISO/OSI) 参考模型结构层次的安全问题等三个主要特性去理解一个安全单元。所以安全单元集合可以用一个三维的安全空间去描述它, 如图 2-1 所示。图中描述了一个三维的计算机网络安全空间, 反映了计算机网络安全的需求和体系结构的共性。



图 2-1 计算机网络安全空间

## 1. 安全特性的安全问题

安全特性指的是该安全单元能解决什么安全威胁。一般来说,计算机网络的安全威胁主要关于人的恶意行为可能导致的资源 (包括信息资源、计算资源、通信资源)被破坏、信息泄漏、信息被篡改、信息被滥用和拒绝服务。ISO7498-2 对 OSI 规定了五个方面的安全服务: 即认证、数据保密性、数据完整性、访问控制和防抵赖。有些安全服务几乎可以在 OSI 所有层中提供。

## 2. 系统单元的安全问题

系统单元的安全问题指的是该安全单元解决什么系统环境的安全问题。对于Internet,可以从四个不同的环境来分析其安全问题。

物理环境的安全问题:物理环境指的是如硬件设备和网络设备等。包含该特性的安全单元解决物理环境的安全问题。

网络系统本身的安全问题: 一般是指数据在网络上传输的安全威胁与数据和资源在存
储时的安全威胁。

应用系统的安全问题: 应用程序是在操作系统上安装和运行的。包含该特性的安全单元解决应用程序所包含的安全问题。一般是指数据在操作和资源在使用的时候的安全威胁。

网络管理的安全问题:ISO7498-2 制定了有关安全管理的机制,包括安全域的设置和管理、安全管理信息库、安全管理信息的通信、安全管理应用程序协议及安全机制与服务管理。



一个网络安全系统应有如下的功能:

## 1.身份识别

身份识别是安全系统应具备的最基本功能。这是验证通信双方身份的有效手段。用户向其系统请求服务时, 要出示自己的身份证明, 例如输人 User ID 和 Password。系统应具备查证用户身份的能力,对于用户的输人,能够明确判别该输人是否来自合法用户。

## 2.存取权限控制

其基本任务是防止非法用户进人系统及防止合法用户对系统资源的非法使用。在开放系统中,网上资源的使用应制定一些规定:一是定义哪些用户可以访问哪些资源; 二是定义可以访问的用户各自具备的读、写等操作权限。

## 3. 数字签名

即通过一定的机制如 RSA 公开密钥加密算法等,使信息接收方能够做出“该信息是来自某一数据源且只可能来自该数据源”的判断。

## 4.保护数据完整性

通过一定的机制,如加人消息摘要等,以发现信息是否被非法修改,避免用户或主机被伪信息所欺骗。

## 5. 审计追踪

即通过记录日志和对一些有关信息进行统计等手段,使系统在出现安全问题时能够追查原因。

## 6. 密钥管理

信息加密是保障信息安全的重要途径, 以密文方式在相对安全的信道上传递信息,可以让用户比较放心地使用网络。如果密钥泄露或居心不良者通过积累大量密文而增加破译密文的机会, 都会对通信安全造成威胁。因此,对密钥的产生、存储、传递和定期更换进行有效地控制并引人密钥管理机制,对增强网络的安全性和抗攻击性也是非常重要的。

## 2.

## OSI 参考模型的安全问题

OSI 安全体系结构的研究始于 1982 年, 当时 OSI 参考模型刚刚确立。1989 年, ISO 为实现开放互连环境下的信息安全, 制定了 IS 07498-2 标准,作为 OSI 参考模型的新补充。 IS 07498-2 标准现在已经成为网络安全专业人员的重要参考, 它不是解决某一特定的安全
问题, 而是为解决网络安全共同体提出了一组公共的概念和术语, 用来描述和讨论安全问题和解决方案。OSI 安全体系结构主要包括三部分内容, 即安全服务、安全机制和安全管理,下面就 OSI 的安全服务、安全机制进行介绍。

## 1. 安全服务

ISO 对 OSI 规定了五种级别的安全服务: 对象认证、访问控制、数据保密性、数据完整性和防抵赖。下面分别介绍这些安全服务。

(1)认证安全服务

认证安全服务是防止主动攻击的重要措施, 这种安全服务提供对通信中的对等实体和数据来源的鉴别, 它对于开放系统环境中的各种信息安全有重要的作用。认证就是识别和证实。识别是辨别一个对象的身份, 证实是证明该对象的身份就是其声明的身份。OSI 环境可提供对等实体认证 (Peer-entity Authentication)的安全服务和信源认证(Data-origin Authentication)的安全服务。

(2)访问控制安全服务

访问控制安全服务是针对越权使用资源和非法访问的防御措施。访问控制大体可分为自主访问控制和强制访问控制两类。其实现机制可以是基于访问控制属性的访问控制表(或访问控制路),或基于“安全标签”、用户分类和资源分档的多级访问控制等。访问控制安全服务主要位于应用层、传输层和网络层。它可以放在通信源、通信目标或两者之间的某一部分。

(3)数据保密性安全服务

数据保密性安全服务是针对信息泄露和窃听等被动威胁的防御措施。这组安全服务又细分为:

信息保密: 保护通信系统中的信息或网络数据库数据。而对于通信系统中的信息, 又分为面向连接保密和无连接保密。连接保密服务为一次 $(N)$ 连接上的全部 $(N)$ 用户数据保证其机密性。尽管在某些层次上, 保护所有数据可能是不适宜的,例如加速数据或连接请求中的数据。无连接机密服务为单个无连接的 (N)SDU 中的全部 (N)用户数据保证其机密性。

数据字段保密:保护信息中被选择的部分数据字段;这些字段或处于 $(N)$ 连接的 $(N)$ 用户数据中,或为单个无连接的 (N)SDU 中的字段。

业务流保密: 防止攻击者通过观察业务流, 如信源、信宿、转送时间、频率和路由等来得到敏感的信息。

(4)数据完整性安全服务

数据完整性安全服务是针对非法地篡改和破坏信息、文件和业务流而设置的防范措施,以保证资源的可获得性。这组安全服务又细分为：

基于连接的数据完整性: 为 $(\mathrm{N})$ 连接上的所有 $(\mathrm{N})$ 用户数据提供完整性服务, 可以检测整个 SDU 序列中的数据遭到的任何篡改、插人、删除或重放。同时根据是否提供恢复成完整数据的功能,区分为有恢复的完整性服务和无恢复的完整性服务。

基于数据单元的数据完整性: 这种服务当由 ( $\mathrm{N}$ )层提供时,对发出请求的 $(\mathrm{N}+1)$ 实体提供数据完整性保证。它对无连接数据单元逐个进行完整性保护。另外, 在一定程度上也能提供对重放数据单元的检测。

基于字段的数据完整性:这种服务为有连接或无连接通信的数据提供被选字段的完整性服务, 通常是确定被选字段是否遭到了篡改。

(5) 防抵赖安全服务

防抵赖安全服务是针对对方进行抵赖的防范措施, 可用来证实已发生过的操作。这组安全服务可细分为:

数据源发证明的抗抵赖, 它为数据的接收者提供数据来源的证据, 这将使发送者谎称未发送过这些数据或否认它的内容的企图不能得逞;

交付证明的抗抵赖, 它为数据的发送者提供数据交付证据, 这将使得接收者事后谎称未收到过这些数据或否认它的内容的企图不能得送。

通信双方互不信任, 但对第三方(公证方)则绝对信任, 于是依靠第三方来证实已发生的操作。

## 2 . 支持安全服务的基本机制

为了实现上述 5 种安全服务, ISO 7408-2 中制定了支持安全服务的 8 种安全机制, 它们分别是:

加密机制 (Enciphermant Mechanisms)

数字签名机制(Digital Signature Mechanisms)

访问控制机制 (Access Control Mechanisms)

数据完整性机制(Data Integrity Mechanisms)

鉴别交换机制 (Authentication Mechanisms)

通信业务填充机制 (Traffic Padding Mechanisms)

路由控制机制 (Routing Control Mechanisms)

公证机制 (Notarization Mechanisms)

## 3. 支持安全服务的辅助机制

安全服务基本机制直接地保护计算机网络安全,但真正实现这些机制必须有下面一些机制的配合, 使安全服务满足用户需求。这些机制的实现与网络层次没有必然的联系, 它们侧重于安全管理方面。主要包括: 安全机制可信度评估、安全标识、安全审计、安全响应与恢复。

## 习习题

2.1 何为计算机网络安全?

2.2 网络安全系统的主要功能是什么?

## 习题参考答案

2.1 计算机网络安全是指计算机及其网络系统资源和信息资源不受自然和人为有害因素的威胁和危害, 即是指计算机、网络系统的硬件、软件及其系统中的数据受到保护, 不因偶然的或者恶意的原因而遭到破坏、更改和泄露, 确保系统能连续可靠正常地运行, 使网络服务不中断。计算机网络安全从其本质上来讲就是系统上的信息安全。

2.2 (1)身份识别

(2)存取权限控制

(3) 数字签名

(4) 保护数据完整性

(5)审计追踪

(6)密钥管理

## 第

## 网络数据包结构与安全



数据包截获的原理、Sniffer 软件的使用方法与防止网络嗅探的措施。教学要求

本章介绍了网络数据包的结构与数据包截获的原理和分析方法, 讲述了 Sniffer 软件的使用方法, 使学生对网络数据包的结构与截获和分析有一个全面的认识。通过本章的学习, 要求学生了解分组交换与数据包的结构、掌握数据包截获的原理、熟悉 Sniffer 软件的使用、了解数据的分析方法, 掌握提高网络安全性并防止网络嗅探的措施。



我们所处的网络环境是一个开放的环境,任何人都可以通过简单的手段从物理上连人一个网络, 就好像人们可以随意进人任何一个街头公园一样。

在这样一个开放的网络环境中如何才能安全地使用网络传输信息? 在目前的网络环境中存在哪些安全隐患或者漏洞? 这些隐患和漏洞是怎样造成对网络安全的威胁的? 我们如何防范……这些问题都是我们这门课要解决的问题。

在互联网这个开放的环境中,各方的信息传输都是以通信协议为基础的。只有深人了解通信协议, 才能在开放的通信环境中选择适当的协议来保证通信的效率与安全, 并且能够有针对性地避开某些协议的安全缺陷, 建立安全的网络环境。



### 3.1.1 什么是分组交换和数据包

计算机网络通信是建立在传统语音通信线路基础上的。但由于计算机网络通信与传统语音通信的性质有着很大的不同, 网络数据传输方式也与传统语音的传输方式有着很大的差异。
在计算机网络中,传输的数据被称为 “报文”,过长的报文在网络中传输是很困难的, 就如同生活中一座楼房的移动是很困难的一样。在生活中, 我们将一座大楼分解成一块块预制板, 这样运输起来就方便多了。计算机网络也是一样, 将要传输的报文分割成一个个小的数据片段,称为 “分组”,在每一个分组的数据前加上传输数据所必需的信息——“报头”, 就构成了网络数据传输的基本部件—“数据包”。

在网络传输协议中,信息是分层传递的。在不同的协议层要对数据包加上本协议层服务的报头。这就如同我们生活中的信件。信件内容是我们最终要传递的对象, 但为了能够迅速而准确地将信件传递给收信人, 我们需要在信件外面加上信封, 信封上写明收信人的地址和姓名。当此信件被送到邮局后, 邮局要对信件再次打包,但在邮局的邮包上注明的不是收件人姓名, 而是此邮件的目的城市和支局名。

从这个例子我们可以看出不同的邮件包装层所需要的服务对象是不同的,邮包上写明的内容也是不同的, 但有一点是相同的, 就是这些内容都是为本层的工作提供服务的。

网络信息传输的原理同生活中的信件邮递过程非常相似。被分割的数据片断就像信件的内容, 是传输过程的主体,而在逐层传递信息时,各层的服务程序要在原有数据包的基础上添加本层传输服务所需的数据包头, 构成最终传输的完整数据包。

由此可以看出, 在计算机网络中, 传输的信息是以数据包为基本传输单位的,数据包的内容是被分割后的信息块,在每个数据包上附加了多层包头。在一个数据包里,信息内容往往是不完整的, 而在每一个数据包头部, 却完整地包含了传送此数据包所需的全部来源及目标地址信息。

### 3.1.2 信息传输过程与数据包的结构

数据包的结构通常是按照不同的网络协议分层套接的。在 OSI 协议层次中, 高层协议面向被传输的对象,低层协议面向传输的过程。

一个数据包的最里层是被传输的数据。在数据的外面首先由处理此数据的应用程序将数据片断外包裹上应用层的协议, 然后交给网络通信系统软件, 网络通信系统软件根据此数据包的传输方式, 为数据包裹上传输层协议, 交给下一层协议。下面的网络层协议根据数据包的路由地址, 为其包裹上网络层协议,并交给下一层协议。下面的链路层协议为数据包加上来源和目标物理地址后交给下一层协议。在物理层, 由网络通信硬件系统按照通信设备的要求将数据包转换成一个个符合物理层协议的电脉冲, 通过网络接口电路发送到网络传输媒介上。

这一串串电脉冲沿着传输媒介到达下一个网络节点。在每一个网络节点上, 节点设备将收到的电脉冲还原为数字信号, 并对数字信号进行判断和分析, 了解此数据包的最终目的地, 并根据节点上的路由表为此数据包选择一个到达目的地的最佳路由并对此数据包进行必要的修改和签章后再次发送到网络传输媒介上。

数据包就这样通过一个个网络节点, 最终到达信息传输的目的地。

在目标主机上, 依据网络协议, 逐层地对数据包进行签收和校验, 如果数据包未出现差错, 则剥除此层的协议, 将数据向上层递交。通过如此逐层剥除与递交, 最终在应用层由应用软件系统将一个个还原后的数据包拼接还原为原始的状态, 完成数据的传输过程。

不同的协议层,有着不同的任务目标,应用着不同的网络协议。
应用层的主要任务是将被传输的信息转换成符合网络传输规范的二进制数据块。常用的应用层协议有: 超文本传输协议 HTTP, 文件传送协议 FTP、远程登录协议 TELNET、简单邮件传送协议 SMTP、域名解析协议 DNS、简单网络管理协议 SNMP、动态主机配置协议 DHCP 以及微软媒体服务器协议 M MS 等。

传输层的主要任务是将数据包传输到目的地, 为此, 传输层为应用层上的应用提供两类截然不同的服务:第一类服务是可靠的面向连接服务,确保正确无误地把消息从源端传送到目的地, 使用的协议是 TCP 协议。第二类服务是不可靠的无连接服务, 使用的协议是用户数据包协议 UDP。

网络层的任务是将源主机发出的信息经过适当的路径送到目的主机。在 Internet 上网络层使用的协议是 IP 协议。IP 协议允许不同种类的操作系统和计算机使用网络并选择最佳的传输途径。

数据链路层的任务是将网络层交下来的 IP 数据报组装成帧, 在两个相邻节点间的链路上传送以帧为单位的数据。主要功能有链路管理、差错控制和流量控制等。根据不同的传输媒介和传输方式, 使用不同的链路层协议, 这些协议被统称为数据链路控制 (DLC) 协议。

物理层是 OSI 参考模型的最底层, 其任务就是为它的上一层提供一个传输数据的物理连接。在这一层, 数据仅作为原始的比特流进行处理。

### 3.1.3 学习网络协议在网络安全中的意义

在网络技术发展的初期, 如何实现连通是最受关注的问题, 为了实现广泛的连通, 网络通信协议具有充分的开放透明性与灵活有效的多业务增值能力。然而, 在开放透明的同时,也往往更容易暴露, 自然也容易受到攻击。在 Internet 商用化后暴露出来的一系列问题中,最欶手、解决难度最大的问题就是安全性问题。

网络协议存在很多的安全性漏洞, 为网络应用的安全性埋下严重的安全隐患。为了能够在不安全的网络中实现安全的通信, 需要对网络通信过程与通信协议有深人的理解, 在充分利用网络通信的开放性与透明性的同时, 加强网络的安全性。

TCP/IP 协议数据流采用明文传输, 就如同传统邮件邮寄中使用明信片一样。明信片在邮寄过程中没有采用密封措施, 任何人都可以看到信件的内容, 甚至邮件内容被篡改也不易被发现。TCP/IP 协议中的数据流也是如此, 在网络中很容易截获别人通信的数据包, 由于数据包未被加密, 所以可以很容易得到通信的内容, 甚至是通过网络传递的各种账户和密码信息。

由于通信内容明文传输,也很容易被篡改或假冒。

网络人侵者掌握了网络协议后, 可以在数据包中伪造 IP 地址, 而获得合法身份潜人网络系统进行窥探或破坏。

网络人侵者还可以利用开放网络协议的特点, 使用网络扫描工具探测网络结构、发现网络漏洞和寻找网络安全薄弱环节对网络或主机进行攻击。

而我们在掌握了网络传输原理与协议结构之后, 就可以有针对性地对网络人侵或安全威胁进行有效的防范。可以对数据包上的信息进行分析和判断, 对合法的数据包放行, 而对非法的数据包进行阻拦。也可以通过拦截网络数据包的方法对网络工作状态进行有效监控, 发现网络异常行为, 及时采取应对措施, 保证网络系统安全高效地运行。

## 3.2

数据包的捕获就是通过技术手段截获网络中的数据包, 并根据需要对数据包的内容进行过滤与分析,得到有价值的信息。这一技术被广泛应用于网络监控管理与网络信息刺探。

### 3.2.1 数据包截获的原理

在计算机网络系统中,数据的收发是由网卡来完成的。

在网络信息传输过程中,各种信息依据网络协议,逐级转换成电脉冲信号发送到网络传输介质上, 在网络中的计算机接收到此脉冲信号后, 由网卡内程序将脉冲还原成数据帧, 并判读数据帧中的目的 MAC 地址, 根据计算机上的网卡驱动程序设置的接收模式判断是否应该接收, 若认为应该接收就将其接收并保存下来, 认为不该接收就丢弃不要。由此得知,网络中不该接收的数据在网卡上就被截断了, 计算机操作系统对这些信息并不知道。如果网卡判断此数据应该接收,就将接收到的数据交给操作系统处理。

网卡根据什么来判断收到的数据是交由操作系统去处理还是应丢弃呢? 这与网卡设置的工作模式有关。以太网接口卡可以被设置成如下 4 种工作模式:

广播: 数据帧可以发向网络中所有计算机。任何设置为广播模式的网卡都接收目的地址为广播地址的数据帧。通常所有的网卡被配置为接收广播帧。

多播:发往一组计算机的帧称为多播帧,使用特定的多播地址作为目的地址。这些计算机的组构成了多播组。这样,多播组里的任何一个成员计算机将会接收具有多播目的地址的帧。

直接: 发往特定计算机的帧具有特定计算机的物理地址。具有特定物理地址的计算机将接收特定的帧, 丢弃其他的帧。网卡可以设置为仅仅接收直接帧。

混杂: 设置为这个模式的网卡接收所有收到的数据包,任何到达此网卡的信息都不丢弃。这个模式是网络监测应用程序的关键模式。

网卡的缺省工作模式包含广播模式和直接模式,即它只接收广播帧和发给自己的帧。如果采用混杂模式,网卡将接受所有到达本网卡网络端口的信号。

什么样的数据包能够到达本网卡的端口呢?

现在局域网广泛使用的是以太网。在以太网中,同一个网段内的信息是以广播的方式传播的。即在同一个网段内,一台主机发出的数据包试图传向本网段中存在的每一台主机。

如图 3-1 所示, 在以太网中,主机 A、B 和 C 同处一个网段,通过集线器将所有主机连在一起。若主机 $\mathrm{A}$ 发送数据包给主机 $\mathrm{B}$, 因为以太网中同一网段内信息是广播的,所以此数据包将通过集线器同时传送到主机 B 和主机 C 的网络端口。

在默认情况下, 每台主机的网卡都设置为 “直接”工作状态, 数据包传到主机 B 的网络端口后, 主机 B 的网卡判断此数据包的目的地址就是本机, 于是将数据包接收下来并交给操作系统做进一步处理。而这个数据包传到主机 $\mathrm{C}$ 的网络端口后, 主机 $\mathrm{C}$ 的网卡判断此数据包的目的地址并非本主机,将其丢弃。于是可以看到,主机 A 发送给主机 B 的信息仅被主机 B 接收到,而其他主机不会收到。



图 3-1

如果主机 C 的工作模式设置为 “混杂”, 那么任何目的地址的数据包只要到达了主机 C 的网络端口, 就会被网卡接收并交予操作系统进行处理。这种情况下, 主机 A 与主机 B 之间的信息交流就会同时被主机 C 全部接收。

如果将图 3-1 中的集线器换成交换机,情况就要发生变化。

交换机属于网络协议中的二层设备。在交换机中可以识别每一个端口上连接网络设备的物理地址, 可以根据各个端口所连接设备的物理地址有选择的转发数据帧。即: 在以交换机为核心节点的网络连接中, 信息并不在交换机各个端口间广播发送, 而是根据设备物理地址有选择的转发。

还以图 3-1 为例,将集线器替换成交换机,如图 3-2 所示。



图 3-2

当主机 A 与主机 B 进行相互间的通信时, 主机 A 在开始通信前并不知道主机 B 在哪一个端口, 于是主机 A 向网络广播发送与主机 B 建立连接的请求, 此请求是以广播方式发布的,所以主机 B 和主机 C 都能收到此信息。主机 B 的网卡判断此连接请求是给本机的,随即向主机 A 发出应答信号, 此应答信号被交换机传送给主机 A 并记忆下来。主机 C 也会收到主机 A 的连接请求信号, 但是主机 C 的网卡判定此连接与本机无关, 立即将此数据包丢弃,不做任何处理。

通过以上的连接及学习过程, 交换机知道主机 A 与主机 B 所在的端口, 并为主机 A 和主机 B 所在的端口建立起一条逻辑通道, 当主机 A 与主机 B 正式通信开始后, 两机通过这条逻辑通道进行一对一的通信, 此通信信息不向交换机上其他端口广播, 主机 C 不会收到主机 A 与主机 B 之间的通信数据。

### 3.2.2 数据截获的方法

通过上一节的学习可知,在以太网中,计算机之间进行通信的必要条件有两个:第一,包含通信信息的电脉冲信号必须能到达接收信息主机的网络端口; 第二, 到达网络端口的数据包必须能够被网卡接受并交与操作系统。

在正常通信情况下, 上述第一点由网络中的路由器、交换机、集线器等设备及网络传输介质实现。这些设备可以保证将数据包按照数据包头部的目的地址传输到目的主机的网卡上的网络端口。第二点由网卡上的处理电路和处理程序依据系统配置而实现。

在网络监听情况下,要想监听到被监听主机之间的通信信息,也要满足以下两点基本要求:

第一,要将监听计算机与被监听主机使用集线器相连。

因为交换机、路由器等二层以上的网络设备具有了网络寻址功能, 可以按照物理或逻辑地址寻找通信目标, 而作为非通信目标的监听计算机将无法收到非发向本机的数据包, 无法捕获其他主机间的通信信息。

但如果把监听软件安装到路由器或作为路由器的主机上, 则可以监听所有通过此路由器的网络通信信息。

第二,要将监听计算机上网卡的工作模式设置为混杂模式。

通常情况下, 当使用专用嗅探软件进人监听模式时会自动将网卡设为混杂模式,所以使用专用嗅探软件进行监听时不需要专门对网卡进行模式转换操作了。

网络监听可以使用 Windows 2000 Server 自带的“网络监视器”程序,也可以使用专用的网络监视软件。通常专用的网络监视软件具有更强的数据捕获与过滤功能, 是网络管理员手中的重要工具软件。

在下一节我们将介绍 NETWORK GENERAL 公司推出的功能强大的协议分析软件 Sniffer Portable。

### 3.2.3 Sniffer Portable 软件介绍

能够实现网络监听的工具软件有很多, 各有优缺点。常用的网络监听软件有微软公司 Windows 2000 Server 中网络监视器和 NETWORK GENERAL 公司的 Sniffer Portable 等。Windows 中的网络监视器出于安全考虑, 仅允许捕获进出本机的数据包, 禁止捕获与本机无关的主机间数据包。而 Sniffer Portable 是一款专用网络监视软件, 可以捕获一切到达本机网络端口的数据报。

在我们的课程中重点介绍 NETWORK GENERAL 公司推出的协议分析软件 Sniffer Portable 。

Sniffer Portable 可以工作于 Windows 2000 及 Windows XP 系统中。它以被动的方式默默地监视和捕获每一个在网络中广播的数据包, 并可对数据包的内容进行过滤、分析、存储。

Network General 公司 Sniffer 中国产品服务中心中文网站的网址是 http://www.sniffer-cn.com, 该网站提供最新版本 Sniffer Portable 软件的免费下载服务,并提供两周的完全功能免费试用期。如图 3-3 所示。



Hetwork Gener a l 作为全球领先的网络安全与高可用性解决方家提洪商, 一直致力于提供最完善的的决决


析、故障彾断和性能管理顼领棫事实上的工业标准。


能管理需求的演变和发展, Sniffer已经发展成面向不同网络技术和不同应用环境的不同系列产品。 Sniffer的产品包括可为网络工程人员提㤨便掑式的网络分析解这方案的Sni ffer Port tble系列产品; 以及能提供网络实时 ( $7 \times 24$ ) 监控分析能力的 Sni fer 分布式系列产品, 它将实时网络流量监控分析和BMOW相结

图 3-3

如果需要购买此软件, 可与 Network General 公司 Sniffer 产品中国代理商广州元通公司联系, 公司网址 http://www.ytlink.com, 该公司网站也可提供免费试用版 Sniffer 软件的下载并提供相关技术支持。如图 3-4 所示。



图 3-4

Sniffer 软件对网络管理员来说是一种强大的监控管理工具, 可以分析网络中的协议,了解网络流量, 发现异常通信等。对网络黑客而言它是一种重要的刺探工具, 常用来窃取网络账号和密码, 窃取网络通信或电子邮件信息。它是一把双刃剑, 既为网络管理工作提供了重要的信息资源, 也为网络安全带来了巨大的威胁。我们学习它的目的是为了把它更好地应用在网络管理中,同时对 Sniffer Portable 带来的网络安全威胁进行有效的预防。

Sniffer Portable 的主要功能:

(1)捕获网络流量进行详细分析;

(2) 利用专家分析系统诊断问题;

(3) 实时监控网络活动;

(4) 收集网络利用率和错误等。

Sniffer Portable 主界面如图 3-5 所示。



图 3-5

从图 3-5 中可以看出,Sniffer Portable 软件主界面由菜单栏、工具栏、仪表板和状态栏等部分组成。仪表板上有带宽占用率、每秒封包数和出错率这 3 个表盘, 显示出当前网络工作的状况。仪表板下面是网络图表, 用曲线反映不同时刻网络工作的状况。

Sniffer Portable 共有 8 个下拉菜单, 其主要功能是:

文件菜单: 打开和保存各种记录数据文件; 软件系统工作模式的设定; 打印各种报表或报告;运行脚本程序等。

监视器菜单: 选择设定系统监视对象和监视的任务, 可以定义过滤器对监视的对象有选择的做出显示,也可以察看报警日志。

捕获菜单: 可以启动或停止捕获操作。可以按照不同的工作需求设置捕获过滤器, 也可以为捕获操作设置触发条件。这些功能可以极大地提高捕获工作效率。

显示菜单: 显示捕获数据的内容。可以对显示内容进行搜索与过滤。

工具菜单: 包含了一些系统工具。如系统配置选项、监视对象地址簿和数据包自动发送工具等。

数据库菜单: 对保存数据的数据库进行整理维护。

窗口菜单: 按不同的工作需要显示或隐藏不同的窗口。

帮助菜单: 提供系统帮助。

在 Sniffer Portable 软件中,与网络安全密切相关的是信息捕获部分。

### 3.2.4 数据的捕获与过滤

## 1.Sniffer Portable 的启动

Sniffer Portable 软件安装好后, 通过“开始” $\rightarrow$ “所有程序” $\rightarrow$ “Sniffer Pro” $\rightarrow$ “Sniffer”路径, 点击启动 Sniffer Portable 程序, 如图 3-6 所示。



图 3-6

启动 Sniffer Portable 程序后首先出现的是“当前设置”对话框，对话框中列表显示出本计算机中可以使用的各个网卡, 若计算机中装有多个网卡, 需要从中选择准备用于监听的网卡,即选中与被监听系统连接的网卡,选中后点击“确定”按钮,如图 3-7 所示。



图 3-7

Sinffer Portable 将打开如图 3-5 所示主窗口。

## 2. 数据包的捕获

捕获数据包需要将监听主机与被监听主机通过集线器连接在一起。前面已有详细介绍,这里不再赘述。

Sniffer Portable 捕获工具栏共有 6 个按钿, 如图 3-8 所示。

6 个按钮的功能分别是:

开始按钮: 启动捕获程序, 开始捕获数据包。

暂停按锄: 暂时停止捕获数据。

停止按钿: 停止捕获工作。

停止和显示按钮: 停止捕获工作, 自动转到显示捕获数据包窗口。

显示按锄:显示捕获数据包的内容。

定义过滤器按钮: 设置过滤条件, 有选择的进行捕获。

捕获方法很简单, 点击捕获工具栏上的“开始”按钮即可开始捕获。







图 3-8

一旦捕获到有效数据包, 捕获工具栏上的 “停止和显示” 按钮由灰色变为彩色。点击此按钮可以停止捕获并显示出捕获数据包的内容, 如图 3-9 所示。



图 3-9

## 3. 数据包的读取与分析

Sniffer Portable 捕获到的数据包被暂存在内存里,点击 “显示”或“停止和显示”按钮可以把捕获的数据包内容显示出来。

在数据显示窗口中, 通过窗口标签可以选择多种显示模式。

专家模式: 是一种综合显示模式, 将各种捕获数据的信息综合排列显示在窗口中,如图 3-10 所示。



图 3-10

解码显示模式: 将捕获到的数据依据不同的协议依次详细显示出来, 是数据分析的主要模式,如图 3-11 所示。

在这种模式下, 可以清晰地看到数据包中每一个字节内容及其在协议中所处的位置与含义。



图 3-11

矩阵显示模式: 可以直观的从捕获的数据包中看出哪些地址的主机间进行了何种协议的连接,如图 3-12 所示。











(专家入解玛入矩阵 〈主机列表 $\lambda$ Protocol Dist.. 亘看统计表为这当肖前对话/

图 3-12

主机列表显示模式: 详细列出每一个地址上各种协议出人数据包的数量及字节数, 如图 3-13 所示。



## 4. 捕获过滤

图 3-13

通过上面的介绍可以看出 Sniffer Portable 的信息捕获能力很强,在一瞬间可以捕获大量的数据, 其中有些数据是有价值的, 但绝大多数是无用的, 如果不对这些数据有选择的捕获,会占用大量的系统资源,而且也会给有用信息的提取带来困难。

Sniffer Portable 有着很强的数据过滤功能, 通过合理配置过滤器, 可以仅对有价值的信息进行捕获,提高系统工作效率,降低系统工作负荷。

点击 Sniffer Portable 捕获工具栏上的“定义过滤器”按钮,可以打开“定义过滤器”对话框。在对话框中可以设置按指定的地址及在指定地址上数据传输方向进行过滤, 如图3-14 所示。

## 定义过㵢器一㭪获



图 3-14
也可以设置按某种协议或数据包大小进行捕获,如图 3-15 所示。



图 3-15

可以设置捕获缓冲区的大小, 及设置自动将缓冲区内容保存到指定位置的文件中, 如图 3-16 所示。



图 3-16

通过对上面这些过滤条件的指定, 就可以有针对性的进行信息捕获,使捕获到的数据包所包含的都是我们所需要的信息。

捕获数据包的目的是为了获得网络中对我们有价值的信息。这一节的内容将介绍如何
对捕获的数据包进行分析和整理。

### 3.3.1 TCP $/$ IP 协议

网络中传输的信息都是按照一定协议格式组合的。为了读懂数据包的内容, 就要熟悉各种网络协议的格式规定。

现在使用最广泛的网络协议是 TCP/IP 族,它由 100 多个协议组成。

TCP/IP 通常被认为是一个四层协议体系,每一层负责不同的功能, 如图 3-17 所示。



图 3-17

第一层链路层, 也被称为网络接口层。定义了数据传输设备和传输媒体或网络间的接口。这一层涉及到对于传输媒介的特性、信号的特性、数据传输率和相关内容的确定。本层主要网络有 DLC 帧协议 (数据链路控制)。

第二层网络层, 也被称作互连网层, 处理分组在网络中的活动, 例如分组的路由选择。在 TCP/IP 协议组件中, 网络层协议包括 IP 协议 (网际协议), ICMP 协议 (Internet 互连网控制报文协议)以及 IGM P 协议(Internet 组管理协议)。

第三层运输层, 主要为两台主机上的应用程序提供端到端的通信。在 TCP/IP 协议中,有两个互不相同的传输协议:即面向连接的 TCP 协议和非连接的 UDP 协议。

第四层应用层,由不同的应用程序实现特定的应用目的。如：

TELNET 远程登录协议

FTP 文件传输协议

SMTP 简单邮件传输协议

SNMP 简单网络管理协议

......

### 3.3.2 利用 Sniffer Portable 分析网络协议

利用 Sniffer Portable 捕获网络通信的数据包后, Sniffer Portable 可以对捕获的数据按照不同的网络协议层次进行分析与解释, 极大地方便了我们对捕获到的数据进行分析和理解。

图 3-18 是使用 Sniffer Portable 捕获的一段网络通信内容, 在解码视图模式下看到的窗口情况。

窗口工作区被分成三个窗格。

上面的窗格显示数据包列表。每一行代表一个数据包。可以看到每一个数据包在这批数据中的编号、此数据包的来源与目标地址和数据包内容摘要等。

下面窗格显示当前选中的数据包中的具体内容。用十六进制和 ASCII 码显示。

中间窗格显示出当前选中的数据包中包含哪些网络协议, 及各协议报头在数据包中的











图 3-18

位置。用鼠标选中窗格中的一个协议后,在下面窗格中就会用灰色底纹将与此协议相关的内容突出显示出来。

下面我们以 DLC 帧为例,学习使用 Sniffer Portable 分析网络协议的方法。

在链路层, 数据是以帧为单位进行发送的。以太网帧包含 6 个域:

1.前导码: 8 个字节,用于同步和起始标志。在 Sniffer Portable 中不显示。

2.目的地址: 6 个字节,目的主机 MAC 地址。

3 .源地址: 6 个字节, 源主机 MAC 地址。

4. 类型域: 2 个字节, 标识了在以太网上运行的客户端协议。即表明上层 (网络层)的协议。如 IP 和 IPX 等网络层协议。
5. 数据: $46 \sim 1500$ 字节, 这是真正要传输的数据。如果长度不够 46 字节则由 DLC 协议自动补齐为 46 字节。
6. 帧校验序列: 4 个字节, 利用的是 CRC 循环冗余校验法, 在 Sniffer Portable 中不显示。

其中 $2 \sim 4$ 称为帧头, 6 称为帧尾。




从图 3-19 中可以看到, 此帧以 DLC Header 开头, 帧内容包含 IP 和 TCP 协议内容。

在 DLC 头部: 共显示 6 行信息, 其中第 3 5 行显示内容是 DLC 真实内容, 其他行是 Sniffer Portable 添加的状态信息。

第一行: Sniffer Portable 添加的 DLC 起始标志。

第二行: Sniffer Portable 添加的帧序号、捕获日期、时间和帧的长度等信息。以上 2 行内容在数据包中是没有的。

第三行: DLC 真实内容。目标主机的 MAC 地址。占 6 个字节, 帧内地址 $00 \sim 05 \mathrm{H}$ 。

第四行: DLC 真实内容。源主机的 MAC 地址。占 6 个字节, 帧内地址 $06 \sim 0 B \mathrm{O}$ 。

第五行: DLC 真实内容。数据包的类型 (即上层协议的类型)。占 2 个字节, 帧内地址 $O C \sim 0 D H$ 。上层协议的类型主要有 0800 为 IP 协议, 0806 为 ARP 协议等。

第六行:Sniffer Portable 添加的 DLC 结束标志。

DLC 结束标志之后是此帧的所要传输信息的真实内容。此帧内容包括 IP 和 TCP 协议 2 部分。其中 IP 协议内容长度为 20 字节, TCP 协议内容长度为 20 字节。内容总长度 40 字节。

帧的最后一行是 DLC 填充段。因为此数据帧内容长度不足 46 字节, DLC 自动添加了 6 个字节的“ 00 ”将其补足为 46 字节。

### 3.3.3 网络层协议报头结构

网络层协议主要有:

网际协议 (IP)

地址解析协议 (ARP)

网际控制报文协议(ICMP)

下面我们分别介绍以上各协议的格式。

## 1.IP 协议

IP 协议是 TCP/IP 协议族中最核心的协议, 所有的 TCP、UDP、ICMP 和 IGMP 数据都以 IP 数据报格式传输。

IP 协议定义了一种高效、不可靠和无连接的传输方式。由于传输没有得到确认, 所以是不可靠的。一个包在传输过程中可能丢失了或是传输顺序错了, 但是传输设备并不检测这些情况,也不知道通信双方有无连接。

这样做的好处是每个包的传递与其他包是相互独立的。一台主机上的包可通过不同的路径到达另一台主机。由于传输设备都试图以最快的速度传输, 所以是最高效的。

IP 协议定义了通过 TCP/IP 网络传输的数据的格式, 定义了数据进行传递的路由功能。即: 在一个数据包前面加上 IP 包头后, 这个数据包就如同放飞的信鸽一样自动寻找目的主机, 其过程不需要发送方再干预。由此可知, IP 数据包的头部必须包含使数据包自动找到目标所需的全部信息。

IP 数据包的格式如图 3-20 所示。

| 4 位版本 | 4 位首部长度 | 8 位服务类型 | 16 位总长度 (字节数) |  |
| :---: | :---: | :---: | :---: | :---: |
| 16 位标识 |  |  | 3 位标志 | 13 位片偏移 |
| 8 位 T TL |  | 8 位协议 | 16 位首部检验和 |  |
| 32 位源 IP 地址 |  |  |  |  |
| 32 位目的 IP 地址 |  |  |  |  |
| 数据 |  |  |  |  |

图 3-20

下面结合实例介绍 IP 报头的结构,如图 3-21 所示。

|  |  |
| :---: | :---: |

图 3-21

IP 报头从 Sniffer Portable 数据包中第 $0 \mathrm{EH}$ 字节开始 $(00 \mathrm{H} \sim 0 \mathrm{DH}$ 是 DLC 帧头)。

地址 $O \mathrm{E}: 1$ 字节。高 4 位是 IP 协议版本号, 低 4 位是本包 IP 首部长度。此例中 $O \mathrm{EH}$地址内容为 $45 \mathrm{H}$ 。 4 代表 IP 协议版本号为 4 , 即 IPv 4 , 此包所经过的各个路由器等网络设备均按 IPv4 格式对数据包进行解读与处理。5 为此数据包 IP 首部长度代码。实际首部长度为此代码乘以 4 , 本例中首部长度为 $5 \times 4=20$ 字节。首部最大长度为 $0 \mathrm{FH} \times 4=15 \times 4=$ 60 (字节)。

地址 OF:1 字节。服务类型: 定义 IP 协议包的处理方法,它包含如下子字段:

过程字段: 3 位, 设置了数据包的重要性, 取值越大数据越重要, 取值范围为: 0 (正常) 7 (网络控制)。

延迟字段: 1 位, 取值: 0 (正常)、1(低延迟)。

流量字段: 1 位, 取值: 0 (正常)、1(高流量)。

可靠性字段: 1 位,取值: 0 (正常) 、 1 (高可靠性)。
成本字段: 1 位,取值: 0 (正常)、1(最小成本)。

未使用: 1 位。

本例中均取正常值“ 0 ”。

地址 $10 \mathrm{H} \sim 11 \mathrm{H}: 2$ 字节。IP 包总长度。此例中 IP 包总长度为 $0052 \mathrm{H}$, 即 82 字节。从 $\mathrm{OEH}$ 到 $5 \mathrm{FH}$, 包含了 IP 包头及数据长度。

地址 $12 \mathrm{H} \sim 13 \mathrm{H}: 2$ 字节。IP 报文标识字段, 每一个 IP 数据包都有一个与分组过程相关的惟一标识, 做为到达目标后恢复数据时组合的依据。此例中标识为 $78 \mathrm{FAH}$ 。

地址 $14 \mathrm{H}$ 的高 3 位: 有关数据分段的标识。

地址 $14 \mathrm{H}$ 的低 5 位 $15 \mathrm{H}$ : 段偏移。当数据分组时, 它和更多段位进行连接, 帮助目的主机将分段的包组合。

地址 16H:1 字节。IP 包生存时间 T TL。由于 IP 包发出后就不再对它进行管理, 任其自由寻找目标主机。如果网络或目标主机出现故障造成 IP 包无法到达目的主机, 此数据包就会不断在网上游遌, 形成网络数据包孤儿。网络数据包孤儿大量存在就会占用网络资源,严重影响正常的网络通信。因此, 如果 IP 包经过一定时间还无法找到目标主机就应该让它自动消亡。这个时间就是 TTL。当某一网络设备发出 IP 包的同时要给 IP 包设定一个生存时间常数, 每经过一个路由器此时间常数自动减一, 当 T T L 值减为 0 还无法找到目标主机就自动消亡。

不同的操作系统或设备预定的时间常数不同, 但都为二进制整数。如 $32,64 、 128 、 256$等。此例中捕获到的数据包 TTL 值为 $33 \mathrm{H}(51)$, 表明它从发出到被捕获已经过 $64-51=$ 13 个路由器了。

地址 $17 \mathrm{H}: 1$ 字节。协议代码。表示此 IP 包携带的是何种协议报文。

常见的有:

$$
\begin{aligned}
& 1: \mathrm{ICMP} \\
& 6: \mathrm{TCP} \\
& 17: \mathrm{UDP}
\end{aligned}
$$

此例中协议代码值为 6 , 表示报文是 TCP 协议。

地址 $18 \mathrm{H} \sim 19 \mathrm{H}$ : 2 字节。首部校验和。用于校验和纠错。

地址 $1 \mathrm{AH} \sim 1 \mathrm{DH}: 4$ 字节。源 IP 地址。此例为 DB $、 85 \mathrm{H} 、 3 \mathrm{FH} 、 36 \mathrm{H}$ 。用点分十进制表示即为 219.133.63.54。

地址 $1 \mathrm{EH} \sim 21 \mathrm{H}: 4$ 字节。目标 IP 地址。此例为 $\mathrm{C} 0 \mathrm{H} 、 \mathrm{~A} 8 \mathrm{H} 、 01 \mathrm{H} 、 64 \mathrm{H}$ 。用点分十进制表示即为 192.168.1.100。

随后是选项, 此例中没有选项。

选项之后是此 IP 数据包的载荷。此例为 TCP 协议传输的数据。

## 2.地址解析协议 (ARP)

ARP 是一种将 IP 地址转化成与 IP 地址对应网卡的物理地址的协议,或者说 ARP 协议是一种将 IP 地址转化成 MAC 地址的一种协议, 它靠在内存中保存的一张表来使 IP 得以在网络上被目标机器应答。

源主机在发送一个 IP 包之前, 它要到该转换表中寻找与目标主机 IP 包相对应的 MAC 地址,如果没有找到,该源主机就发送一个 ARP 广播包,即目的 MAC 为 FF-FF-FF-FF-FF-FF,
目的 IP 为目标主机,再带上自己的源 IP 和源 MAC。

源主机所在网段上的所有主机都会接收到来自源主机的 ARP 请求, 由于每台计算机都有自己惟一的 M AC 和 IP, 那么它会分析目的 IP 是不是自己的 IP。如果不是, 网卡自动丢弃数据包。如果目标主机经过分析, 发现目的 IP 是自己的, 于是更新自己的 ARP 缓存,记录下源主机的 IP 和 M AC。然后回应源主机一个 ARP 应答, 把源主机的源 IP 和源 MAC 变成现在目的 IP 和目的 MAC,再带上自己的源 IP、源 MAC,发送给源主机。

当源主机机接收到 ARP 应答后, 更新自己的 ARP 缓存, 即把 ARP 应答中的目标主机的源 IP、源 M AC 的映射关系记录在缓存中。现在源主机中有目标主机 M AC 和 IP, 目标主机中也有源主机的 MAC 和 IP。ARP 请求和应答过程结束, 两台主机之间可以进行正常通信了。

ARP 数据包结构,如图 3-22 所示。

| 硬件类型 |  | 协议类型 |
| :---: | :---: | :---: |
| 硬件地址长度 | 协议地址长度 | 操作 (请求: 1 ;应答: 2 ) |
| 源主机硬件地址 |  |  |
| 源主机协议地址 |  |  |
| 目标硬件地址 |  |  |
| 目标协议地址 |  |  |

图 3-22

下面结合实例介绍 ARP 数据包结构, 如图 3-23 所示。





$00000010: 08 \quad 0006 \quad 0400 \quad 0100$ 0d 60 8a fo 3 ff c0 a8 0164




婐

图 3-23

这是一台 IP 地址为 192.168.1.100 的主机向 IP 地址为 192.168.1.101 的主机发出 ARP 请求的数据包。

数据包前 14 个字节为 DLC 包头, ARP 协议包从偏移地址 ODH 开始到 $29 \mathrm{H}$ 结束。
地址 ODH OEH : 2 字节。硬件类型, 以太网为“0001H”。

地址 $10 \mathrm{H} \sim 11 \mathrm{H}: 2$ 字节。上层协议类型, $0800 \mathrm{H}$ 为 IP 协议。

地址 $12 \mathrm{H}$ : 硬件地址长度。 $\mathrm{MAX}$ 地址长度恒为 6 字节。

地址 $13 \mathrm{H}$ : 协议地址长度。IP 地址恒为 4 字节。

地址 $14 \mathrm{H} \sim 15 \mathrm{H}$ : 操作。请求包恒为 1 ,应答包恒为 2 。此例是请求包, 值为 1 。

地址 $16 \mathrm{H} \sim 1 \mathrm{BH}$ : 源主机的 MAC 地址。此例为: 00-0D-60-8A-F0-3F。

地址 $1 \mathrm{CH} \sim 1 \mathrm{FH}$ : 源主机协议地址。此例为 192.168.1.100。(十六进制表示为 $\mathrm{C0H}$ 、 A8 $\mathrm{H}, 01 \mathrm{H}, 64 \mathrm{H})$ 。

地址 $20 \mathrm{H} \sim 25 \mathrm{H}$ : 目标主机 M AC 地址。此例为 ARP 请求包, 地址为 0 .

地址 $26 \mathrm{H} \sim 29 \mathrm{H}$ : 目标主机协议地址。此例为 192.168.1.101(十六进制表示为 $\mathrm{COH}$ 、 A8 $8 \mathrm{H}, 01 \mathrm{H}, 65 \mathrm{H})$ 。

地址 $2 \mathrm{AH} \sim 3 \mathrm{BH}: \mathrm{DLC}$ 将数据包不足长度部分补足。

目标主机收到此 ARP 请求包后, 回应一个 ARP 应答包, 内容如下, 如图 3-24 所示。



图3-24

具体内容及含义请同学们自己分析。

## 3. 网际控制报文协议 (ICMP)

ICMP 协议用于在主机、路由器之间传递控制消息以检查网络是否通畅、主机是否可达和路由是否可用等。ICMP 包并不传输用户数据, 但是对于用户数据的传递起着重要的作用。ICMP 常被黑客利用成为网络攻击的重要手段。

我们在网络维护管理中经常会使用到 ICMP 协议, 比如经常使用的用于检查网络连通性的 Ping 命令, 跟踪路由的 Tracert 命令等。

ICMP 报文包含在 IP 数据报中, 属于 IP 的载荷。一个 ICMP 报文包括 IP 头部、ICMP 头部和 ICMP 报文,如图 3-25 所示。

| IP 首部 | ICM P 报文 |
| :--- | :--- |

图 3-25

ICMP 数据包结构如图 3-26 所示。

| 8 位类型 | 8 位代码 | 16 位检验和 |
| :---: | :---: | :---: |
| 不同的类型和代码有不同的数据内容 |  |  |

图 3-26

下面结合实例介绍 ICMP 数据包结构, 如图 3-27 所示。



图 3-27

图 3-27 是一个使用 Sniffer Portable 捕获的 ICMP 数据包内容。

地址 $00 \mathrm{H} \sim 0 \mathrm{DH}: \mathrm{DLC}$ 包头

地址 $0 \mathrm{EH} \sim 21 \mathrm{H}: \mathrm{IP}$ 包头

地址 $22 \mathrm{H}: 1$ 字节。ICMP 数据包类型字段。不同的代码代表此数据包内容的类型。类型代码 类型描述

0 响应应答 (ECHO-REPLY)

3 不可到达

4 源抑制

5 重定向

8 响应请求(ECHO-REQUEST)

11 超时

12 参数失灵

13 时间截请求

14 时间翟应答

15 信息请求 (* 已作废)

16 信息应答 $(*$ 已作废)

17

18

地址掩码请求

此例中代码 08 ,响应请求。

地址 $22 \mathrm{H}$ : 1 字节。代码。根据前一字节设定的不同类型。此字节的含义不同。详细解释请查阅 ICMP 协议手册。此例中为 0 。

地址 $23 \mathrm{H} \sim 24 \mathrm{H}: 2$ 字节校验和。用于校验数据包的正确性。

后面随不同的类型和代码有不同的数据内容。此例为响应请求 ICM P 包, 其内容为:

地址 $25 \mathrm{H} \sim 26 \mathrm{H}$ : 标识。

地址 $27 \mathrm{H} \sim 28 \mathrm{H}: 2$ 字节。发送二进制位序列号。

地址 $29 \mathrm{H} \sim$ 结束: 发送探测包内容。使用 Windows 系统的 Ping 命令时内容为英文小写字母 $\mathrm{a} \sim \mathrm{w}$ 循环发送, 直到达到命令要求的字节数为止。默认字节数为 32 。

图 3-28 为上述响应请求的应答包, 内容请同学们自己分析。

|  | 序号 | 状态 | 源地址 | 目标地址 | 摘要 |  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| $\square$ | 1 | $\mathrm{M}$ | $[192.168 .1 .100]$ | $[202.108 .33 \cdot 32]$ | ICMP | Echo |
| $\square$ | 2 |  | $[202.108,33.32]$ | $[192,168 \cdot 1 \cdot 100]$ | ICMP | Echo reply |
| L | 3 |  | $[192,168,1,100]$ | $[202,108,33,32]$ | $\mathrm{ICMP}$ | Echo |
| $\not$ | 4 |  | $[202 \cdot 108 \cdot 33 \cdot 32$ | $[192 \cdot 168 \cdot 1 \cdot 100]$ | ICMP | Echo reply |
| $\square$ | 5 |  | $[192 \cdot 168 \cdot 1 \cdot 100]$ | $[202 \cdot 108 \cdot 33: 32]$ | ICMP | Echo |



图 3-28

### 3.3.4 传输层协议报头结构

传输层协议主要有:

传输控制协议 (TCP)用户数据报协议(UDP)。

## 1 . 传输控制协议 (TCP)

TCP 协议在传输层提供面向连接的可靠传输服务。

$\mathrm{TCP}$ 的工作主要是建立连接, 然后从应用层程序中接收数据并进行传输。TCP 采用虚拟电路连接方式进行工作, 在发送数据前它需要在发送方和接收方建立一个连接, 数据在发送出去后, 发送方会等待接收方给出一个确认性的应答, 否则发送方将认为此数据丢失, 并重新发送此数据。

发送和接收方 TCP 实体以数据报的形式交换数据。一个数据报包含一个固定的 20 字节的头、一个可选部分以及 0 或多字节的数据。
$\mathrm{TCP}$ 报头结构,如图 3-29 所示。

| 源端口 (16) |  |  | 目的端口 (16) |
| :---: | :---: | :---: | :---: |
| 序列号 (32) |  |  |  |
| 确认号 (32) |  |  |  |
| T CP 偏移量(4) | $\mid$ 保留 (6) | 标志 (6) | 窗口(16) |
| 校验和 (16) |  |  | 紧急(16) |
| 选项 (0 或 32) |  |  |  |
| 数据(可变) |  |  |  |

图 3-29

下面,结合实例对照,图 3-30 介绍了 $\mathrm{TCP}$ 数据包结构 :



图 3-30

地址 $00 \mathrm{H} \sim 0 \mathrm{DH}: \mathrm{DLC}$ 包头。

地址 $0 \mathrm{EH} \sim 21 \mathrm{H}$ :IP 包头。

地址 $22 \mathrm{H} \sim 23 \mathrm{H}: 2$ 字节。源主机端口号, 此例为使用 HTTP 协议访问网页, 默认端口号为 $80(0050 \mathrm{H})$ 。
地址 $24 \mathrm{H} \sim 25 \mathrm{H}: 2$ 字节。目标主机端口号, 由应用程序随机产生。此例为 3545 (ODD9H)。

地址 $26 \mathrm{H} \sim 29 \mathrm{H}$ : 4 字节。序号: 指明了段在即将传输的段序列中的位置。TCP 连接是可靠的, 而且保证了传送数据包的顺序, 顺序是用序号来保证的。此例中序号为 2938112427(AF2009 ABH)。

地址 $2 \mathrm{AH} \sim 2 \mathrm{DH}: 4$ 字节。确认号: 作为收到数据的响应,连接成功后传输数据过程中此号为请求包序号十应答数据包长度, 若不进行通信仅进行连接时长度为 1 字节同步字节。此例为 $648543792+1=648543793(26$ A 7 FE31H)。

地址 $2 \mathrm{EH}: 1$ 字节。高 4 位为首部长度, 值为首部字节数/ 4 。低 4 位保留未用。此例 $\mathrm{TCP}$ 首部长度 20 字节, 故此字节高 4 位值 $=20 / 4=5$ 。

地址 $2 \mathrm{FH}: 1$ 字节。高 2 位保留未用。低 6 位为标志位。

U R G 紧急指针有效。

A C K 确认序号有效。

P S H 接收方应该尽快将这个报文段交给应用层。

R S T 重建连接。

S Y N 同步序号用来发起一个连接。

F I N 发端完成发送任务。

此例 ACK 位被置位, 表示这是一个确认连接包。

地址 $30 \mathrm{H} \sim 31 \mathrm{H}: 2$ 字节。窗口: 指定发送端能传输下一段的大小。此例为 65259 (FEEBH)。

地址 $32 \mathrm{H} \sim 33 \mathrm{H}: 2$ 字节。校验和: 用来校验段头和数据部分的可靠性。此例为 082DH。

地址 $34 \mathrm{H} \sim 35 \mathrm{H}: 2$ 字节。紧急指针: 指明段中包含紧急信息, 只有当 U R G 标志置 1 时紧急指针才有效。此例为 0 。

以下地址若有选项则连续 32 字节选项。此例没有选项字段。后面内容全部为被传输的数据。此例为以 HTTP 协议传输的超文本网页信息, 全部以明文方式传输。

下面再看一个捕获电子邮件登录信息的 TCP 数据包, 如图 3-31 所示。此 TCP 包的载荷是 POP3 协议接收的电子邮件。在第 68 行显示出电子邮件用户的帐户名, 第 71 行显示出电子邮件用户的登录密码。用户在下载邮件时也可以捕获邮件全部内容。



## 2. 用户数据报协议 (UDP)

前面介绍的 TCP 协议提供了可靠的数据传输, 并在进行相互通信的设备或服务之间保持一个虚拟连接。TCP 在数据包接收无序、丢失或在交付期间被破坏时,负责数据恢复。这一切减轻了应用软件中传输信息的负担,但是也带来了缺乏灵活性的问题。

在网络语音和视频通信中, 信息传输的时间同步性要求很高, 但是允许在传输过程中出现一些差错甚至是数据的丢失。在 TCP 协议中信息传输的正确性是由协议保障的,如果网络环境较差, 出现传输错误, TCP 协议一定要不厌其烦地反复重发, 直到数据正确传输到目的主机为止,这样可能会耗费很长的时间, 而应用软件无法对此进行干涉。

用户数据报协议 UDP 也是传输层协议, 和 TCP 协议处于一个分层中,但是与 TCP 协议不同, UDP 协议并不提供超时重传,出错重传等功能,是不可靠的协议。

UDP 将数据的校验交给应用软件来完成, 大大提高了信息传输的灵活性, 由应用软件判断数据报是否可以丢弃。对于可以忽略的部分应用软件可以自主将其丢弃, 以保障信息传递的时效性。因此, UDP 协议广泛应用于时效性要求高的场合, 比如网络电话、网络电视、视频监控等。

因为 UDP 协议任务简单,所以 UDP 包的结构也很简单, 如图 3-32 所示。

| 源端口号 | 目的端口号 |
| :---: | :---: |
| UDP 长度 | UDP 校验和 |
| 数据(如果有) |  |

图 3-32

下面结合实例介绍 UDP 包的结构 :

图 3-33 是一段捕获的收看网络电视的数据包。

地址 $00 \mathrm{H} \sim 0 \mathrm{DH}: \mathrm{DLC}$ 包头。

地址 $0 \mathrm{EH} \sim 21 \mathrm{H}: \mathrm{IP}$ 包头。

地址 $22 \mathrm{H} \sim 23 \mathrm{H}: 2$ 字节。源主机端口号, 此例为 $53124(\mathrm{CF} 84 \mathrm{H})$ 。

地址 $24 \mathrm{H} \sim 25 \mathrm{H}$ : 2 字节。目标主机端口号, 此例为 53124(CF84H)。

地址 $26 \mathrm{H} \sim 27 \mathrm{H}: 2$ 字节。UDP 部分数据长度, 此例为 $835 \mathrm{~B}(0343 \mathrm{H})$ 。

地址 $28 \mathrm{H} \sim 29 \mathrm{H}: 2$ 字节。校验和。

地址 $2 \mathrm{AH} \sim$ 结束: UDP 数据段。此例为网络电视数据。

## 3.4政据时安全

通过前面的学习, 大家了解到在网络中信息传输是很容易被捕获和分析的, 这样会给网络系统的安全性带来哪些问题呢?

### 3.4.1 安全隐患

## 1. 信息泄漏

在网络信息传递的过程中, 通常都是采用明码传送, 任何人只要将数据包捕获, 就可以





图 3-33

很容易地获得数据包中的信息。

在捕获的数据包中可以了解到通信双方的 IP 地址、主机物理地址、使用的通信协议、登录账户和密码以及通信的内容等。

图 3-34 是一个捕获数据包实例:



图 3-34

从这个数据包中可以看到通信双方计算机的 IP 地址分别为 192.168.1.100 和 202.108.37.68。双方物理地址分别是 001478CF7BDCH 和 000D608AF03F H。使用 HTTP 协议浏览网页,网页的内容是有关人大和政协会议等等。

而且通过 Sniffer Portable 可以很容易了解到各个主机上的信息流量和各主机访问或
被访问的状态,从中可以刺探到业务内容和业务量等商业敏感信息。

## 2. 网络攻击

黑客们利用协议实现的攻击方法, 都是故意错误地设定数据包头的一些重要字段, 使接收端在把接收到的数据包组装成一个完整的数据包的过程中出现错误。这样的包往往会造成系统宕机、挂起或系统崩溃等故障。

协议欺骗攻击技术是针对网络协议的缺陷, 采用欺骗的手段, 截获信息或取得特权并进行攻击。主要的协议欺骗攻击方式有: IP 欺骗、ARP 欺骗、DNS 欺骗和源路由欺骗等。

下面以 IP 欺骗攻击为例介绍利用协议进行攻击的方法。

IP 欺骗技术就是通过伪造某台主机的 IP 地址骗取特权从而进行攻击的技术。通常应用程序认为如果数据包能够使其自身沿着路由到达目的地, 而且应答包也可以回到源地, 那么源 IP 地址一定是有效的, 而这正是使源 IP 地址欺骗攻击成为可能的前提。

假设同一网段内有两台主机 $\mathrm{A} 、 \mathrm{~B}$, 另一网段内有主机 $\mathrm{X}$ 。 $\mathrm{B}$ 授予 $\mathrm{A}$ 某些特权。 $\mathrm{X}$ 为获得与 A 相同的特权,所做欺骗攻击如下: 首先, X 冒充 A, 向主机 B 发送一个带有随机序列号的 SYN 包。主机 B 响应, 回送一个应答包给 A, 该应答号等于原序列号加 1 。然而, 此时主机 A 已被主机 X 利用拒绝服务攻击“淹没”了, 导致主机 A 服务失效。结果, 主机 A 将 B 发来的包丢弃。为了完成三次握手, $\mathrm{X}$ 还需要向 $\mathrm{B}$ 回送一个应答包,其应答号等于 $\mathrm{B}$ 向 $\mathrm{A}$发送数据包的序列号加 1 。此时主机 X 并不能检测到主机 B 的数据包 (因为不在同一网段), 只有利用 TCP 顺序号估算法来预测应答包的顺序号并将其发送给目标机 B。如果猜测正确, $\mathrm{B}$ 则认为收到的 $\mathrm{ACK}$ 是来自内部主机 $\mathrm{A}$ 。此时, $\mathrm{X}$ 即获得了主机 $\mathrm{A}$ 在主机 B 上所享有的特权,并开始对这些服务实施攻击。

### 3.4.2 提高网络安全性,防止网络嗅探的措施

## 1 . 防止嗅探

通过前面分析可以看到, 网络嗅探是对网络安全的重大威胁,必须及早发现并阻止网络嗅探器。

但网络嗅探器出于被动工作状态, 它通常不主动向网络上发送信息, 而是默默无闻地被动接收信息,这对发现网络嗅探器的存在带来很大的困难。

探测局域网中的 Sniffer 的方法:

由于 Sniffer 是一种静态的工作于被动方式的软件,工作中不会留下任何日志, 我们要主动的去探测它。鉴于 Sniffer 的原理是设置网卡为混杂模式,那么, 我们就可以想办法探测网络中被设置为混杂模式的网卡, 以此来判断是否存在 Sniffer。

这里, 让我们再来看看计算机接收数据包的规则。在正常模式下, 首先由网卡判断数据包的目的 MAC 地址, 如果为本机 MAC 地址或为广播地址, 那么数据包将被接收进人系统核心, 否则将被丢弃。而如果网卡被设置为混杂模式, 那么所有的数据包都将直接进人系统核心。数据包到达系统核心后, 系统还将进一步对数据包进行第选: 系统只会对目的 MAC 地址为本机 MAC 地址或广播地址的数据包做出响应一一如果接收到的是 ARP 请求报文,那么系统将回馈一个 ARP应答报文。

但是, 不同的是, 系统核心和网卡对广播地址的判断有些不一样: 以 Windows 系统为例, 网卡会判断 M AC 地址的所有六位, 而系统核心只判断 MAC 地址的前两位(Win98 甚
至只判断前一位), 也就是说, 对于系统核心而言, 正确的广播地址 FF-FF-FF-FF-FF-FF 和错误的广播地址 FF-FF-FF-FF-FF-FE 是一样的, 都被认为是广播地址, 甚至 FF-FF-00-0000-00 也会被系统核心认为是广播地址！

如果我们构造一个目的 MAC 地址为 FF-FF-FF-FF-FF-FE 的 ARP 请求报文, 那么, 对于在正常工作模式下的网卡,数据包将被丢弃, 当然也就不会回馈任何报文; 而对于在混杂模式下网卡,数据包将被接收进人系统核心。而系统核心会认为这个 M AC 地址是广播地址, 因此就会回馈一个ARP 应答报文。这样, 根据能否收到应答报文就可以判断出这台主机上是否存在 Sniffer了。

以上方法手工实现很困难,可以使用专用工具软件。

ARPKiller 就是一款小巧的混杂模式探测软件。支持 Windows 98 和 Windows 2000 系统。

该软件是免费绿色软件, 直接从网上下载解压后就可直接启动 ARPKiller. exe 程序。启动后的工作窗口如图 3-35 所示。



图 3-35

该软件既可以实现 ARP 欺骗, 也可以探测网络嗅探器。在这里我们只介绍网络嗅探器的使用。启动程序后点击选择“Sniffer 检测工具”, 选择探测主机所在的 IP 地址段。

点击 “开始检测”按钮,如图 3-36 所示。系统开始检测指定网段中工作于混杂模式的网卡,一旦发现有工作于混杂模式的网卡就会将其列表显示出来。结果如图 3-37 所示。



图 3-36



图 3-37

## 2.使用安全拓扑结构阻止啲探

使用上述探测方法可以发现网络中的 sniffer 主机,但是不能阻止网络唣探行为。
如何阻止网络嗅探, 保护网络的安全呢? 保护网络不受 sniffer 监听的根本方法就是不要让网络信息广播到 sniffer 主机的网络端口。

把网络分段,从物理上将敏感主机与危险主机相隔绝,使敏感主机间传输的信息不被广播到可能装有 sniffer 系统的主机上,可以从根本上防止敏感信息被嗅探。

如果网络环境不允许将主机从物理上相互隔绝, 可以在敏感主机和风险主机之间安置防火墙设备, 对进出的数据包进行检测, 阻拦敏感数据对外泄漏。

采用交换机替代集线器, 可以抑制网络中信息的广播, 对防止网络嗅探也可以起到一定的作用。

## 3. 采用加密技术对网络中传输的敏感数据进行加密

信息的发送方对传输的数据事先进行加密, 网络中传输的是加密后的密文, 密文到达目的主机后, 目的主机使用正确的密钥对信息进行解密, 将信息还原成正确的明文。密文信息在传输过程中如果被非法嗅探捕获, 因为非法主机没有正确的密钥, 无法用捕获的数据包还原出正确的原文，达到防止机密信息泄漏的目的。

## 实验题

## 实验 3.1 网络嗅探环境的配置与数据包的捕获分析

实验目的

通过实验理解网络嗅探的原理, 掌握捕获数据包的方法。

实验环境

Windows 操作系统, Sniffer Portable 软件, 集线器。

实验内容

1.建立网络数据包捕获环境

硬件连接。

以三台计算机为一组, 分别命名为 $A 、 B$ 和 $C$, 通过集线器连接到一起, 两台计算机之间进行正常通信, 第三台对其进行数据包捕获操作。

网络配置。

配置三台计算机 IP 地址为同一网段内不同 IP 地址。

## 2.捕获并分析数据

计算机 A 使用 Ping 命令向 B 计算机发送 ICMP 包, 使用计算机 C 进行捕获, 观察捕获数据包, 说明使用 ping 命令建立连接和返回应答的过程。并察看数据包的内容。

计算机 B 开启 IIS, 建立 WWW 和 FTP 服务。使用计算机 A 访问计算机 B 的 WWW 网页和通过 FTP 进行上传与下载。计算机 C 捕获 A 与 B 之间的数据包, 分析建立连接的过程及观察捕获的数据包内容。

观察能否捕获 FTP 登录时帐户名和密码。

3 . 有针对性地捕获

设置捕获策略,仅捕获计算机 A 从计算机 B 获取的网页内容。

提示: 可以通过设置 IP 地址及信息流方向限定捕获信息的流动方向, 通过设置协议设定仅捕获 HTTP协议。

## 习习题

3.1 什么是分组交换和数据包?

3.2 各层协议主要内容有什么?

3.3 网卡都有哪些工作模式?

3.4 如何实现网络信息的捕获?

3.5 为什么要对 Sniffer Portable 进行配置捕获过滤策略?

## 习题参考答案

3.1 将要传输的报文分割成一个个小的数据片段, 称为 “分组”, 在每一个分组的数据前加上传输数据所必需的信息“报头”, 就构成了网络数据传输的基本部件“数据包”。

3.2 常用的应用层协议有: HTTP、FTP、TELNET、SMTP、DNS、SNMP、DHCP、 MMS 等。

常用传输层协议有 TCP 和 UDP 等。

常用网络层协议有 IP 和 DLG 协议。

3.3 网卡常用的工作模式有:广播、多播、直接、混杂。

3.4 在监视计算机上安装网络数据包捕获软件, 使网卡工作在混杂模式, 并通过集线器与被监视计算机处于同一网段。

3.5 Sniffer Portable 捕获能力很强, 可以捕获一切到达本机网络端口的网络数据, 如果不加以过滤,会使捕获得到的数据过于繁杂, 无法找到所需信息。

## 第

## 数据加密技术



数据加密的基本方法、对称密码体制 DES 算法和非对称密码体制 RSA

## 教学要求

本章介绍数据加密技术, 在介绍了一些基本概念之后给出了几种在 Internet中常见的数据加密技术, 使学生掌握数据保护的有关知识。通过本章的学习, 理解数据加密技术的基本概念, 了解对称密码体制和非对称密码体制的基本思想,掌握 DES 算法, IDEA 算法、AES 算法和 RSA 算法。

近年来,随着信息技术突飞猛进的发展和计算机技术的广泛应用,计算机通信网络得到了长足的发展, 特别是随着 Internet 用户的激增, 世界正步人网络经济的新时代。对更有效的生产和产品销售渠道的需求,引发了人们对高技术生产力的要求, 由此产生了一批具有代表性的网络经济模式, 比如电子商务(Electronic Commerce)、电子现金(Electronic Cash)、数字货币(Digital Cash)、网络银行 (Network Bank) 等。有专家预言, 到 2010 年, 发生在 Internet上的贸易金额将会达到 100000 亿美元。伴随这种高增长的, 就是对网络经济的安全需求。为了保障计算机网络的安全,需要采取各种技术。其中, 密码学是保证计算机网络安全的理论基础。密码技术的发展与应用,对解决网络经济的安全难题,保障私密数据信息的安全,起着不可忽视的作用。

本章主要介绍了密码学的基本概念、数据加密的基本方法和 Internet 中常用的数据加密技术以及 DES、IDEA、AES 和 RSA 算法等。

## 数据加密技术摡迷

密码学是一门古老的学科, 在古代就已经得到应用, 但仅限于外交和军事等重要领域。随着现代计算机技术的飞速发展, 密码技术正在不断向更多其他领域渗透。密码技术是保障信息安全的核心技术,是保证计算机网络安全的理论基础。

密码学是结合数学、计算机科学、电子与通信等诸多学科于一身的交叉学科。它的主要任务是研究计算机系统和通信网络内信息的保护方法以实现系统内信息的安全、保密、真实和完整。所以,使用密码技术不仅可以保证信息的机密性,而且可以保证信息的完整性和正确性,防止信息被篡改、伪造和假冒。随着计算机网络不断参透到各个领域, 密码学的应用也随之扩大。数字签名和身份鉴别等都是由密码学派生出来的新技术和应用。

### 4.1.1 密码技术的起源和发展

密码学的起源可能要追溯到人类尝试通信的时候。早在几千年前, 人类就已经有了保密通信的思想和方法, 但这些保密方法都是非常朴素、原始和低级的, 而且大多数是无规律的。相传最早使用一些技术手段来加密通信内容的是古希腊人。公元前 6 世纪, 古希腊人使用一根叫做 scytale 的棍子来加密。送信人先在棍子上绕一张纸条,然后把信息坚写在纸条上,最后打开纸条送给收信人。如果不知道棍子的宽度, 就不能正确地恢复信息。人类有记载的通信密码始于公元前 400 多年, 当时的古希腊人发明了置换密码。

密码学从其发展来看,可分为两大阶段: 传统密码学和现代密码学。

传统密码学阶段: 从古代到 1949 年为密码学诞生的前夜。在这一阶段中, 虽然人类有众多的密码实践, 比如两次世界大战中通信密码的大规模应用和密码的破译活动, 但密码技术不是一种科学, 而可以称之为一种艺术。这一时期的密码专家主要是靠人工进行信息加密、传输和破译。

现代密码学阶段开始于 1949 年,香农 (Claude Shannon)在《贝尔系统技术杂志》上发表论文《保密系统的通信理论》, 为单钥密码系统奠定了理论基础, 从此密码成为一门科学。而从 1949 年到 1975 年这段时期内, 密码学的理论进展不大。直到 1976 年,狄非 (W Diffie) 和海尔曼( M.E.Hellman) 发表了《密码学的新方向》一文, 建立了公钥密码系统 (双钥系统),引发了密码学上的一次革命性的变革。

### 4.1.2 密码学的基本概念

加密: 把信息从一个可理解的明文形式变换成一个错乱的、不可理解的密文形式的过程。

明文(Plain Text):原来的信息(报文)和消息,就是网络中所说的报文(Message)。

密文(Cipher Text): 经过加密后得到的信息。

解密: 将密文还原为明文的过程。

密钥 (Key): 加密和解密时所使用的一种专门信息 (工具)。
密码算法 (Algorithm) : 加密和解密变换的规则 (数学函数), 有加密算法和解密算法。加密系统: 加密和解密的信息处理系统。

加密过程是通过某种算法并使用密钥来完成的信息变换。

如图 4-1 所示, 加密实际上是要完成某种函数运算 $\mathrm{C}=f(\mathrm{P}, \mathrm{K})$, 对于一个确定的加密密钥 $K_{e}$, 加密过程可看作是只有一个自变量的函数, 记作 $E_{k}$, 加密变换为:



图 4-1 简单的密码系统示意图

$$
C=E_{k}(P) \quad(\text { 加密变换作用于明文 } P \text { 后得到密文 } C)
$$

同样, 解密也完成某种函数的运算 $P=g(C, K)$, 对于确定的解密密钥 $K_{d}$, 解密过程为:

$$
P=D_{k}(C) \quad \text { (解密变换作用于密文 } C \text { 后得到明文 } P \text { ) }
$$

由此可见,密文 C 经解密后还原成原来的明文, 必须有

$$
P=D_{k}\left(E_{k}(P)\right)=D_{k} \text { i } E_{k}(P)
$$

此处“ $\mathrm{i}$ ”是复合运算,因此要求

## $D_{k}$ i $E_{k}=I$

$\mathrm{I}$ 为恒等变换, 即 $\mathrm{D}_{k}$ 与 $\mathrm{E}_{k}$ 是互逆变换

### 4.1.3 密码的分类

按密码的历史发展阶段和应用技术分: 手工密码、机械密码、电子机内乱密码和计算机密码; 按密码转换的操作类型分: 替代密码和移位密码; 按保密程度划分, 有理论上保密的密码、实际上保密的密码和不保密的密码; 按明文加密时的处理方法分: 分组密码和序列密码;按密钥的类型分: 对称密钥密码和非对称密钥密码。后两种分类方法是当前比较常用的分类方法,下面将对其作重点介绍。

## 1.处理方法分类

(1) 分组密码

分组密码的加密方式是: 首先将明文序列以固定长度进行分组,每组明文用相同的密钥和算法进行变换,得到一组密文。分组密码是以块为单位, 在密钥的控制下进行一系列线性和非线性变换而得到密文的。

分组密码的加/解密运算是: 输出块中的每一位是由输人块的每一位和密钥的每一位共同决定。

加密算法中重复地使用替代和移位两种基本的加密变换,即 Shannon 1949 年发现的隐藏信息的两种技术:打乱和扩散。

打乱: 就是改变数据块,使输出位与输人位之间没有明显的统计关系(替代);

扩散: 就是通过密钥位转移到密文的其他位上(移位)。

分组密码的特点: 良好的扩散性; 对插人信息的敏感性; 较强的适应性; 加/解密速度慢;
差错的扩散和传播。

(2)序列密码

序列密码加密过程是: 把报文、语音和图像等原始信息转换为明文数据序列, 再将其与密钥序列进行 “异或”运算, 生成密文序列发送给接收者。接收者用相同的密钥序列与密文序列再进行逐位解密(异或), 恢复明文序列。

序列密码加/解密的密钥, 是采用一个比特流发生器随机产生二进制比特流而得到的。它与明文结合产生密文, 与密文结合产生明文。序列密码的安全性主要依赖于随机密钥序列。

序列密码一直是作为军事和外交场合使用的主要密码技术之一。它的主要原理是: 通过有限状态机产生性能优良的伪随机序列, 使用该序列加密信息流, 得到密文序列。所以,序列密码算法的安全强度完全决定于它所产生的伪随机序列的好坏。产生好的序列密码的主要途径之一是利用移位寄存器产生伪随机序列。目前要求寄存器的阶数大于 100 阶, 才能保证必要的安全。序列密码的优点是错误扩展小、速度快、利于同步和安全程度高。

## 2 . 密钥的类型分类

加密和解密过程都要使用密钥。如果加密密钥和解密密钥相同或相近, 由其中一个很容易地得出另一个, 这样的系统称为对称密钥系统, 加密密钥和解密密钥都是保密的; 如果加密密钥与解密密钥不同, 且由其中一个不容易得到另一个, 则这种密码系统是非对称密钥系统, 往往其中一个密钥是公开的,另一个是保密的。

前者也称为传统密钥密码体制, 后者称为公开密钥密码体制。相应地, 这两种密码体制各有一些典型算法。对称密钥密码体制的主要算法有 DES、IDEA、TDEA(3DES)、MD5、 RC5 等, 也叫单密钥算法; 公开密钥密码体制的主要算法有 RSA、Elgamal、背包算法、 Rabin、DH 等。

## 4. 2 <br> 传统密码体制

在计算机出现前, 密码学由基于字符的密码算法构成。不同的密码算法是字符之间互相代换或者是互相之间换位, 好的密码算法是结合这两种方法, 每次进行多次运算。

现在事情变得复杂多了,但原理还是没变。重要的变化是算法对比特而不是对字母进行变换, 实际上这只是字母表长度上的改变, 从 26 个元素变为 2 个元素。大多数好的密码算法仍然是代替和换位的元素组合。

传统加密方法加密的对象是文字信息。文字由字母表中的字母组成, 在表中字母是按顺序排列的, 赋予它们相应的数字标号, 即可用数学方法进行变换了。将字母表中的字母看作是循环的,则字母的加减形成的代码可用求模运算来表示了。如 $\mathrm{A}+4=\mathrm{E}, \mathrm{X}+6=\mathrm{D}$ $(\bmod 26)$ 。

### 4.2.1 代替密码

代替密码就是明文中每一个字符被替换成密文中的另外一个字符。接收者对密文进行逆替换就恢复出明文来。在经典密码学中 (如图 4-2 所示), 有简单代替、多名码代替、多字
母代替和多表代替加密法,其中最有代表性的是简单代替密码。

简单代替密码指的是明文的字母用相应的密文字母代替。其思想非常简单, 是根据密钥形成一个新的字母表, 与原明文字母表有相应的对应关系。典型的一种代替密码是凯撒密码, 又叫循环移位密码。其加密方法就是将明文中的每个字母都用其右边固定步长的字母代替, 构成密文。

例如: 步长为 4 , 则明文 $A 、 B 、 C 、 \cdots 、 Y 、 Z$ 可分别由 $E 、 F 、 G 、 \cdots 、 C 、 D$ 代替。如果明文是 “about”,则变为密文“efsyx”,其密钥 $k=+4$ 。两个循环的字母表对应。
(a)






(b)


(c)



(a)移位映射 (b)倒映射 (c)步长映射(步长为 3 )

图 4-2 代替加密

## 4.2 .2 移位密码

在移位密码中, 明文的字母保持相同, 但顺序被打乱了。只对明文字母重新排序, 位置变化了, 而不隐藏它们。是一种打乱原文顺序的替代法。在简单的纵行移位密码中, 明文以固定的宽度水平地写在一张图表纸上, 密文按垂直方向读出, 解密就是将密文按相同的宽度垂直地写在图表纸上, 然后水平地读出明文。

如明文为 “this is a bookmark”,将其分为三行五列,则为以下形式:



按列从左至右读,可得到密文:

tskhamibasoriok

如果把明文字母按一定顺序排列成矩阵形式, 用另一种顺序选择相应的列输出得到密文。如用“china”为密钥,对“this is a bookmark”排列成矩阵如下:



按“china”各字母排序“23451”顺序, 输出得到密文 ioktskhamibasor。

再如: 对于句子“移位密码加密时只对明文字母重新排序字母位置变化但它们没被隐藏”, 可选择密钥 “362415”, 并循环使用该密钥对上句进行移位加密。密钥的数字序列代表明文字符(汉字)在密文中的排列顺序。
按照该密钥加密可得到一个不可理解的新句子(密文)“密密位码移加对字只明时文新字重排母序置但位变母化没藏们被它隐”。解密时只需按密钥 362415 的数字从小到大顺序将对应的密文字符排列, 即可得到明文。

### 4.2.3 一次一密詮密码

一次一密钥密码是一种理想的加密方案。就是一个随机密码字母集, 包括多个随机密码, 这些密码就好像一个本本, 其中每页上记录一条密码。类似日历的使用过程, 每使用一个密码加密一条信息后, 就将该页撕掉作废,下次加密时再使用下一页的密码。

一次一密钥密码可推广到二进制数据的加密。用二进制数据组成一次密码本, 用异或代替加法, 对二进制密码和明文进行操作; 解密时用同样的密码和密文进行异或, 得到明文。

一次一密钥密码必须是随机产生的,这样才可做到最好效果的保密。

发送者使用密钥本中每个密钥字母串去加密一条明文字母串, 加密过程就是将明文字母串和密钥本中的密钥字母串进行模 26 加法运算。

接收者有一个同样的密钥本, 并依次使用密钥本上的每个密钥去解密密文的每个字母串。接收者在解密信息后也销毁密钥本中用过的一页密钥。

例如,如果消息是: ONETIMEPAD

密钥本中的一页密钥是: GIN TBDEYWX

则可得到密文: VWSNKQJOXB

这是因为: $0+G=V(\bmod 26)$

$\mathrm{N}+\mathrm{I}=\mathrm{W}(\bmod 26)$

$\mathrm{E}+\mathrm{N}=\mathrm{S}(\bmod 26)$

... ... ... ...

一次一密的密钥字母必须是随机产生的。对这种方案的攻击实际上是依赖于产生密钥序列的方法。不要使用伪随机序列发生器产生密钥, 因为它们通常有非随机性。如果采用真随机序列发生器产生密钥,这种方案就是安全的。

一次一密密码在今天仍有应用,主要用于高度机密的低带宽信道。美国与前苏联之间的热线电话据说就是用一次一密密钥本加密的,许多前苏联间谍传递的信息也是用一次一密钥密码加密的。至今这些信息仍是保密的,并将一直保密下去。



### 4.3.1 对称密码体制

对称密码体制是从传统的简单换位发展而来的。其基本思想 (如图 4-3 所示) 就是加解密双方在加解密过程中要使用完全相同的一个密钥, 而且通信双方都必须获得这把钥匙,并保持钥匙的秘密。对称密码算法有: DES、IDEA、TDEA (3DES)、MD5、RC5 和 AES 等,使用最广泛的是 DES(Data Encryption Standard)密码算法。

对称密码技术的安全性依赖于以下两个因素。第一,加密算法必须是足够强的,仅仅基
于密文本身去解密信息在实践上是不可能的; 第二, 加密方法的安全性依赖于密钥的秘密性, 而不是算法的秘密性, 因此, 我们没有必要确保算法的秘密性, 而需要保证密钥的秘密性。对称加密系统的算法实现速度极快, 从 AES 候选算法的测试结果看, 软件实现的速度都达到了每秒数兆或数十兆比特。由于对称密钥密码系统具有加解密速度快和安全强度高的优点,目前被越来越多地应用在军事、外交以及商业等领域。



图 4-3 对称加密体制模型

### 4.3.1.1 DES 算法

## 1.DES 概述

$\operatorname{DES}$ (数据加密标准) 算法是个块加密算法, 64 位二进制数码组成的数据块在 64 位密钥的控制下进行加密和解密变换。加密与解密使用相同的算法和密钥, 只是稍作改变, 64 位密钥中有 8 位作为校验位 (第 $8 、 16 、 24 、 32 、 40 、 48,56$ 和 64 位), 因此真正成为密钥的只有 56 位。

图 4-4 所示是 DES 加密算法的完整过程, 初学者很难看懂如此复杂的过程, 所以把该过程总结为六个主要步骤 (如图 4-5 所示), 这样理解起来也相对容易。简单的说, DES 利用加密的两个基本属性。替换(混淆)与变换(扩散), DES 共 16 步, 每一步称为 1 轮, 每一轮进行替换与变换步骤, 具体为:



图 4-4 DES 算法框图

(1) 将 64 位明文块送人初始置换 (初始置换只发生一次,是在第一轮之前);

(2)对明文进行初始置换；

(3) 初始置换产生转换块的两半, 假设为左明文和右明文;

(4) 每个左明文与右明文经过 16 轮加密过程, 各有自己的密钥;

(5)最后, 将左明文与右明文重接起来,对组成的块进行最终置换;

(6)结果得到 64 位密文。



输出64位密文(明文)

图 4-5 DES 主要步骤

## 2.DES 算法的主要过程

(1) 初始置换 IP

DES 的第一阶段包括 64 位分组的置换,改变每个分组中位的顺序。在表 4-1 中具体给出了这个置换。DES 标准使用这个表格来进行初始置换。因此, 在置换后的第 1 位是置换前的第 58 位。在置换后的第 2 位是置换前的第 50 位。置换后数据的最后一位在最初是明文中的第 7 个数据位。 64 位明文分组 $\mathrm{x}$ 经过一个初始置换函数 IP, 产生 64 位的输出 $\mathrm{X}_{\circ}$,再将分组 X。分成 32 位左半部分 $\mathrm{L}_{\circ}$ 和 32 位右半部分 R。 。

表 4-1

DES 初始置换

| 58 | 50 | 42 | 34 | 26 | 18 | 10 | 2 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 60 | 52 | 44 | 36 | 28 | 20 | 12 | 4 |
| 62 | 54 | 46 | 38 | 30 | 22 | 14 | 6 |
| 64 | 56 | 48 | 40 | 32 | 24 | 16 | 8 |
| 57 | 49 | 41 | 33 | 25 | 17 | 9 | 1 |
| 59 | 51 | 43 | 35 | 27 | 19 | 11 | 3 |
| 61 | 53 | 45 | 37 | 29 | 21 | 13 | 5 |
| 63 | 55 | 47 | 39 | 31 | 23 | 15 | 7 |

(2)子密钥生成

DES 加密算法的密钥长度为 56 位, 但一般表示为 64 位, 其中, 每个第 8 位用于奇偶校验。在 DES 加密算法中, 将用户提供的 64 位初始密钥经过一系列的处理得到 $K_{1}, K_{2}, \cdots$, $\mathrm{K}_{16}$, 分别作为 1 16 轮运算的 16 个子密钥, 如图 4-6 所示。首先, 将 64 位密钥去掉 8 个校验位, 用密钥置换 PC-1 置换剩下的 56 位密钥; 再将 56 位分成前 28 位 Co和后 28 位 D。两部分, 即密钥置换 PC-1 如表 4-2 所示。
外部输人的 56 位密钥 (64 位中去掉 8 个校验位) 通过置换和移位操作生成加密和解密需要的 16 个 48 位的子密钥。

前面得到 56 位密钥,每一轮从这个 56 位密钥产生不同的 48 位子密钥, 称为密钥变换。 56 位密钥分成两半各 28 位, 循环左移一位或两位, 例如, 如果轮号是 $1,2,9,16$, 则只移一位,否则移两位。

相应移位后, 选择 56 位中的 48 位, 由于密钥变换要进行置换和选择 56 位中的 48 位,因此称为压缩置换。



图 4-6 子密钥生成算法框图

具体步骤如下：

第一步: 56 位密钥通过置换选择 PC-1 (见表 4-2) 置换,然后分为左右各 28 位;

表 4-2

| 57 | 49 | 41 | 33 | 25 | 17 | 9 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 1 | 58 | 50 | 42 | 34 | 26 | 18 |
| 10 | 2 | 59 | 51 | 43 | 35 | 27 |
| 19 | 11 | 3 | 60 | 52 | 44 | 36 |
| 63 | 55 | 47 | 39 | 31 | 23 | 15 |
| 7 | 62 | 54 | 46 | 38 | 30 | 22 |
| 14 | 6 | 61 | 53 | 45 | 37 | 29 |
| 21 | 13 | 5 | 28 | 20 | 12 | 4 |

第二步:两个 28 位按其轮数进行不同位数的左移 (见表 4-3);

表 4-3

| 轮数 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 位数 | 1 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 1 | 2 | 2 | 2 | 2 | 2 | 2 | 1 |

第三步: 移动后, 将两部分合并成 56 位后通过压缩置换 PC-2(如表 4-4)后得到 48 位子密钥。

表 4-4

压缩置换 PC-2

| 14 | 17 | 11 | 24 | 1 | 5 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 3 | 28 | 15 | 6 | 21 | 10 |
| 23 | 19 | 12 | 4 | 26 | 8 |
| 16 | 7 | 27 | 20 | 13 | 2 |
| 41 | 52 | 31 | 37 | 47 | 55 |
| 30 | 40 | 51 | 45 | 33 | 48 |
| 44 | 49 | 39 | 56 | 34 | 53 |
| 46 | 42 | 50 | 36 | 29 | 32 |

(3)乘积变换:

此过程与密钥有关, 且非常复杂, 是加密/解密过程的关键。该过程包括线性变换和非线性变换。DES 采用的是分组加密。该过程通过多次重复的替代和置换方法, 打乱原输人数据组,加大非规律性, 增加系统分析的难度。

该过程包括如下步骤, 如图 4-7 所示。



图 4-7 乘积变换算法框图

扩展置换:

第一步: 经过 IP 置换 (初始置换)后的 64 位明文分为左右各 32 位两部分 $L_{i-1}$ 和 $R_{i-1}$,分别称为左明文和右明文;

第二步: 将 $\mathrm{R}_{\mathrm{i}-1}$ 的 32 位进行扩展置换 ( $\mathrm{E}$ 盒子变换), 扩展置换将右明文从 32 位扩展到

48 位, 过程如下:

(1) 将 32 位右明文分成 8 块,每块各有 4 位;

(2) 将上一步的每 4 位块扩展为 6 位块, 即每个 4 位块增加 2 位(实际上是重复 4 位块的第一位和第四位), 第二位和第四位口令输人一样写出。

也可以直接通过 E 盒子变换表(表 4-5) 输出。

| 表 4-5 | E 盒子变换表 |  |  |  |  |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 32 | 1 | 2 | 3 | 4 | 5 |
| 4 | 5 | 6 | 7 | 8 | 9 |
| 8 | 9 | 10 | 11 | 12 | 13 |
| 12 | 13 | 14 | 15 | 16 | 17 |
| 16 | 17 | 18 | 19 | 20 | 21 |
| 20 | 21 | 22 | 23 | 24 | 25 |
| 24 | 25 | 26 | 27 | 28 | 29 |
| 28 | 29 | 30 | 31 | 32 | 1 |

密钥变换将 56 位秘钥压缩成 48 位,而扩展置换将 32 位右明文扩展为 48 位, 现在, 48 位密钥与 48 位右明文进行异或运算, 将结果传递到下一步, 即 $S$ 盒置换。

$\mathrm{S}$ 盒置换, 如图 4-8 所示。



图 4-8 $\mathrm{S}$ 盒置换算法框图

$S$ 盒置换过程从压缩密钥与扩展右明文异或运算得到的 48 位输人用替换法得到 32 位输出。替换用 8 个替换盒, 也称其为 $\mathrm{S}$ 盒, 每个 $\mathrm{S}$ 盒有 6 位输人和 4 位输出。48 位输人块分成 8 个子块 (各有 6 位), 每个子块指定一个 $\mathrm{S}$ 盒。每个 $\mathrm{S}$ 盒的 6 位输人变换为 4 位输出。因此, 48 位输人经过 8 个 $\mathrm{S}$ 盒变换,得到 32 位输出,该过程也叫压缩变换。

表 4-6 中每个 $\mathrm{S}$ 盒是一个 4 行 16 列的表, 盒中的每一项都是一个 4 位二进制数对应的
十进制数。 $\mathrm{S}$ 盒的 6 位输人决定了其对应的输出在哪一行哪一列。

如 6 位输人的第 1 位和第 6 位组合构成了 2 位二进制数, 可表示十进制数 $0 \sim 3$, 它对应着表中的一行; 6 位输人的第 2 到第 5 位组合构成了 4 位二进制数, 可表示十进制数 $0 \sim 15$,它对应着表中的一列。例如, 第 8 个 $\mathrm{S}$ 盒的输人为 001011 , 前后 2 位形成的二进制数为 01 , 对应第 8 个 $\mathrm{S}$ 盒的第 1 行 : 中间 4 位为 0101, 对应同一 $\mathrm{S}$ 盒的第 5 列。从表 4-6 中可得 $\mathrm{S} 8$ 盒的第 1 行第 5 列的数为 3 , 于是就用 0011 代替原输人 001011 。

表 4-6

| S8 | 0 | 13 | 2 | 8 | 4 | 6 | 15 | 11 | 1 | 10 | 9 | 3 | 14 | 5 | $\cdot$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  | 1 | 1 | 15 | 13 | 8 | 10 | 3 | 7 | 4 | 12 | 5 | 6 | 11 | 0 | $\cdot$ |
|  | 2 | 7 | 11 | 4 | 1 | 9 | 12 | 14 | 2 | 0 | 6 | 10 | 13 | $\cdot$ | $\cdot$ |

所有 $\mathrm{S}$ 盒的输出组成 32 位块, 传递到下一阶段, 即 $\mathrm{P}$ 盒置换。

$\mathrm{P}$ 盒置换:

8 个 $\mathrm{S}$ 盒的 32 位输出再经过一个线性变换 ( $\mathrm{P}$ 置换), 得到 32 位输出; $\mathrm{P}$ 盒置换机制只是进行简单的置换 (即按表 4-7 指定把一位换成另一位, 而不进行扩展的压缩)。

表 4-7

$\mathbf{P}$ 盒置换

| 16 | 7 | 20 | 21 |
| :---: | :---: | :---: | :---: |
| 29 | 12 | 28 | 17 |
| 1 | 5 | 23 | 26 |
| 5 | 18 | 31 | 10 |
| 2 | 8 | 24 | 14 |
| 32 | 27 | 3 | 9 |
| 19 | 13 | 30 | 6 |
| 22 | 11 | 4 | 15 |

产生新明文:

最后, 将 $\mathrm{P}$ 盒置换的 32 位输出与 64 位分组的左半部分 $\mathrm{L}_{\mathrm{i}-1}$ 异或, 得到新的 32 位右明文输出即 $\mathrm{R}_{\mathrm{i}}$, 然后左、右半部分交换, 接着开始下一轮计算。

(4)末置换(逆序置换):

末置换是 DES 算法的最后一步, 是一次简单的数码移位, 也与密钥无关。它是把乘积变换输出的 64 位码, 按表 4-8 所示进行重新排列, 改变每个分组中位的顺序, 这与第 1 阶段的操作类似,只是前后者使用不同的表格。因此,在置换后的第 1 位是预输出的第 40 位。在置换后的第 2 位是预输出的第 8 位。而密文的最后一位是预输出的第 25 个数据位。这次置换的输出结果就是密文,其结果即为 64 位密文。该组密文与其他各组明文加密得到的密文合在一起,即为原报文的加密结果。
表 4-8

DES 逆序置换

| 40 | 8 | 48 | 16 | 56 | 24 | 64 | 32 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 39 | 7 | 47 | 15 | 55 | 23 | 63 | 31 |
| 38 | 6 | 46 | 14 | 54 | 22 | 62 | 30 |
| 37 | 5 | 45 | 13 | 53 | 21 | 61 | 29 |
| 36 | 4 | 44 | 12 | 52 | 20 | 60 | 28 |
| 35 | 3 | 43 | 11 | 51 | 19 | 59 | 27 |
| 34 | 2 | 42 | 10 | 50 | 18 | 58 | 26 |
| 33 | 1 | 41 | 9 | 49 | 17 | 57 | 25 |

## 3.DES 解密

DES 的解密算法与加密算法相同, 解密密钥也与加密密钥相同。只是解密时逆向取用加密时用的密钥顺序。即加密时第 $1-16$ 轮回迭代使用的子密钴顺序是 $\mathrm{k}_{1}, \cdots, \mathrm{k}_{16}$, 而解密时使用的子密钥顺序是 $\mathrm{k}_{16}, \cdots, \mathrm{k}_{1}$, 产生子密钥时的循环移位是向右的。

DES 加密过程的数学模型
$\mathrm{L}_{0} \mathbf{R}_{0}=\operatorname{IP}($ M64)
(M64 为 64 位输人明文)
$\mathrm{K}_{\mathrm{i}}=\mathrm{ks}(\mathrm{i}$, key $)$

$$
i=1,2, \cdots, 16
$$

( $\mathrm{ks}$ 表示密钥运算函数,产生 48 位的子密钥)

$$
\mathrm{Li}_{\mathrm{i}}=\mathrm{R}_{\mathrm{i}-1} / \mathrm{R}_{\mathrm{i}}=\mathrm{L}_{\mathrm{i}-1} \oplus \mathrm{f}\left(\mathrm{R}_{\mathrm{i}-1}, \mathrm{~K}_{\mathrm{i}}\right)
$$

$\mathrm{f}\left(\mathrm{R}_{\mathrm{i}-1}, \mathrm{~K}_{\mathrm{i}}\right)$ 中涉及到 $\mathrm{E}$ 变换、 $\mathrm{S}$ 盒代替、 $\mathrm{P}$ 盒变换和异或运算等步骤

$$
\mathrm{C} 64=\mathrm{IP}^{-1}\left(\mathrm{~L}_{16}, \mathrm{R}_{16}\right)
$$

DES 解密过程的数学模型

$\mathrm{L}_{16} \mathrm{R}_{16}=\operatorname{IP}(\mathrm{C} 64)$

$\mathrm{K}_{\mathrm{i}}=\mathrm{ks}_{\mathrm{s}}(\mathrm{i}$, key $) \quad \mathrm{i}=16,15, \cdots, 1$

$\mathrm{R}_{\mathrm{i}-1}=\mathrm{L}$

$\mathrm{Li}^{-1}=\mathrm{Ri}_{\mathrm{i}} \oplus \mathrm{f}\left(\mathrm{R}_{\mathrm{i}}, \mathrm{K}_{\mathrm{i}}\right)$

$\mathrm{M} 64=\mathrm{IP}^{-1}\left(\mathrm{~L}_{0}, \mathrm{R}_{0}\right)$

### 4.3.1.2 分组密码的操作模式

分组密码在加密时, 明文分组的长度是固定的, 而实际应用中待加密消息的数据量是不定的, 数据格式是多种多样的。为了能在各种场合使用 DES, 美国在 FIPS PUS 74 和 81 中定义了 DES 的 4 种运行模式。这些模式也可用于其他分组密码, 下面以 DES 为例来介绍这 4 种模式。

## 电码本 (ECB) 模式

ECB(Electronic Code Book)模式是最简单的运行模式, 它一次对一个 64 比特长的明文分组加密, 而且每次的加密密钥都相同, 如图 4-10 所示。当密钥取定时, 对明文的每一个分组, 都有一个惟一的密文与之对应。因此形象地说, 可以认为有一个非常大的电码本, 对任意一个可能的明文分组,电码本中都有一项对应于它的密文。

如果消息长于 64 比特, 则将其分为长为 64 比特的分组, 最后一个分组如果不够 64 比特, 则需要填充。解密过程也是一次对一个分组解密, 而且每次解密都使用同一密钥。图 4-10 中, 明文是由分组长为 64 比特的分组序列 $\mathrm{P}_{1}, \mathrm{P}_{2}, \cdots, \mathrm{P}_{\mathrm{N}}$ 构成, 相应的密文分组序列是
$\mathrm{C}_{1}, \mathrm{C}_{2}, \cdots, \mathrm{C}_{\mathrm{N}}$ 。




(a)加密



(b)解密


图 4-10 ECB 模式示意图

$\mathrm{ECB}$ 在用于短数据 (如加密密钥) 时非常理想, 因此如果需要安全地传递 DES 密钥, $\mathrm{ECB}$ 是最合适的模式。

$\mathrm{ECB}$ 的最大特性是同一明文分组在消息中重复出现的话, 产生的密文分组也相同。 ECB 用于长消息时可能不够安全, 如果消息有固定结构,密码分析者有可能找出这种关系。例如, 如果已知消息总是以某个预定义字段开始,那么分析者就可能得到很多明文密文对。如果消息有重复的元素而重复的周期是 64 的倍数,那么密码分析者就能够识别这些元素。以上这些特性都有助于密码分析者,有可能为其提供对分组的代换或重排的机会。

密码分组链接 $(\mathrm{CBC})$ 模式

为了解决 ECB 的安全缺陷, 可以让重复的明文分组产生不同的密文分组, CBC (Cipher Block Chaining)模式就可满足这一要求。

图 4-11 是 CBC 模式示意图, 它一次对一个明文分组加密, 每次加密使用同一密钥, 加密算法的输人是当前明文分组和前一次密文分组的异或, 因此加密算法的输人不会显示出与这次的明文分组之间的固定关系, 所以重复的明文分组不会在密文中暴露出这种重复关系。

解密时, 每一个密文分组被解密后, 再与前一个密文分组异或, 从而产生出明文分组。在产生第 1 个密文分组时, 需要有一个初始向量 IV 与第 1 个明文分组异或。解密时, IV 和解密算法对第 1 个密文分组的输出进行异或以恢复第 1 个明文分组。IV 对于收发双方都应是已知的, 为使安全性最高, IV 应像密钥一样被保护, 可使用 ECB 加密模式来发送 IV 。保护 IV 的原因如下: 如果敌手能欺骗接收方使用不同的 IV 值,敌手就能够在明文的第 1 个分组中插人自己选择的比特值。

由于 $\mathrm{CBC}$ 模式的链接机制, $\mathrm{CBC}$ 模式对加密长于 64 比特的消息非常合适。 $\mathrm{CBC}$ 模式除能够获得保密性外, 还能用于认证。

密码反馈 (CFB) 模式


(a)加密


(b)解密

图 4-11 CBC 模式示意图

如上所述, DES 是分组长为 64 比特的分组密码, 但利用 CFB (Cipher Feed Back) 模式或 OFB 模式可将 DES 转换为流密码。流密码不需要对消息填充, 而且运行是实时的。因此如果传送字母流, 可使用流密码对每个字母直接加密并传送。流密码具有密文和明文一样长这一性质, 因此, 如果需要发送的每个字符长为 8 比特, 就应使用 8 比特密钥来加密每个字符。如果密钥长超过 8 比特, 则造成浪费。

图 4-12 是 CFB 模式示意图, 设传送的每个单元(如一个字符)是 $j$ 比特长, 通常取 $j=8$,与 $\mathrm{CBC}$ 模式一样, 明文单元被链接在一起,使得密文是前面所有明文的函数。

加密时, 加密算法的输人是 64 比特移位寄存器, 其初值为某个初始向量 IV。加密算法输出的最左 (最高有效位) $\mathrm{j}$ 比特与明文的第一个单元 $\mathrm{P}_{1}$ 进行异或, 产生出密文的第 1 个单元 $\mathrm{C}_{1}$, 并传送该单元。然后将移位寄存器的内容左移 $\mathrm{j}$ 位并将 $\mathrm{C}_{1}$ 送人移位寄存器最右边 (最低有效位) $\mathrm{j}$ 位。这一过程继续到明文的所有单元都被加密为止。解密时, 将收到的密文单元与加密函数的输出进行异或。

CFB 模式除能获得保密性外,还能用于认证。

输出反馈 (OFB) 模式

OFB(Output Feed Back)模式的结构类似于 CFB, 见图 4-13。不同之处在于: OFB 模式是将加密算法的输出反馈到移位寄存器, 而 CFB 模式中是将密文单元反馈到移位寄存

器。

OFB 模式的优点是传输过程中的比特错误不会被传播。例如 $C_{1}$ 中出现 1 比特错误，在解密结果中只有 $P_{1}$ 受到影响, 以后各明文单元则不受影响。而在 CFB 中, $C_{1}$ 也作为移位寄存器的输人, 因此它的 1 比特错误会影响解密结果中各明文单元的值。

OFB 的缺点是它比 CFB 模式更易受到对消息流的篡改攻击, 比如在密文中取 1 比特



(a)加密


(b)解密

图 4-12 CFB 模式示意图

的补, 那么在恢复的明文中相应位置的比特也为原比特的补。因此使得敌手有可能通过对消息校验部分的篡改和对数据部分的篡改,而以纠错码不能检测的方式篡改密文。

### 4.3.1.3 IDEA 算法

瑞士联邦技术学院来学嘉 (X. J. Lai) 和 J. L. Massey 提出的第 1 版 IDEA (International Data Encryption Algorithm, 国际数据加密算法)于 1990 年公布, 当时称为 PES(Proposed Encryption Standard,建议加密标准)。1991 年,在 Biham 和 Shamir 提出差分密码分析之后, 设计者推出了改进算法 IPES, 即改进型建议加密标准。1992 年, 设计者又将 IPES 改名为 IDEA。这是近年来提出的各种分组密码中一个很成功的方案, 已在 PGP 中采用。

## 设计原理

算法中明文和密文分组长度都是 64 比特, 密钥长 128 比特。其设计原理可从强度和实现两方面考虑。

(1) 密码强度

算法的强度主要是通过有效的混淆和扩散特性而得以保证。混淆是通过使用以下 3 种运算而获得, 3 种运算都有两个 16 比特的输人和一个 16 比特的输出:

1) 逐比 $2^{16}$ 特异或,表示为 $\oplus$ 。
2) 模 $2^{16}$ (即 65536) 整数加法, 表示为, 其输人和输出作为 16 位无符号整数处理。
3) 模 $2^{16}+1$ (即 65537 ) 整数乘法, 表示为 $\odot$,其输人、输出中除 16 位全为 0 作为 216 处


(a)加密


(b)解密

图 4-13 OFB 模式示意图

理外,其余都作为 16 位无符号整数处理。例如

$$
0000000000000000 \odot 1000000000000000=1000000000000001
$$

这是因为 $2^{16} \times 2^{15} \bmod \left(2^{16}+1\right)=2^{15}+1$ 。

3 种运算结合起来使用可对算法的输人提供复杂的变换, 从而使得对 IDEA 的密码分析比对仅使用异或运算的 DES 更为困难。

算法中扩散是由称为乘加 (Multiplication/Addition, MA) 结构 (见图 4-14) 的基本单元实现的。该结构的输人是两个 16 比特的子段和两个 16 比特的子密钥, 输出也为两个 16 比特的子段。这一结构在算法中重复使用了 8 次, 获得了非常有效的扩散效果。

IDEA 实现

IDEA 可方便地通过软件和硬件实现。

1)软件实现采用 16 比特子段处理, 可通过使用容易编程的加法和移位等运算实现算法的 3 种运算。

2)硬件由于加、解密相似, 差别仅为使用密钥的方式, 因



图 4-14 M A 结构此可用同一器件实现。再者, 算法中规则的模块结构, 可方便 VLSI 的实现。

## 加密过程

加密过程 (如图 4-15 所示) 由连续的 8 轮迭代和一个输出变换组成,算法将 64 比特的明文分组分成 4 个 16 比特的子段,每轮迭代以 4 个 16 比特的子段作为输人,输出也为 4 个 16 比特的子段。最后的输出变换也产生 4 个 16 比特的子段,链接起来后形成 64 比特的密文分组。每轮迭代还需使用 6 个 16 比特的子密钥, 最后的输出变换需使用 4 个 16 比特的子密钥, 所以子密钥总数为 52 。图 4-15 的右半部分表示由初始的 128 比特密钥产生 52 个子密钥的子密钥生成器。



图 4-15 IDEA 的加密框图

## 轮结构

图 4-16 是 IDEA 第 1 轮的结构示意图, 以后各轮也都是这种结构, 但所用的子密钥和轮输人不同。每轮开始时有一个变换,该变换的输人是 4 个子段和 4 个子密钥,变换中的运算是两个乘法和两个加法, 输出的 4 个子段经过异或运算形成了两个 16 比特的子段作为 M A 结构的输人。M A 结构也有两个输人的子密钥, 输出是两个 16 比特的子段。

最后,变换的 4 个输出子段和 $\mathrm{MA}$ 结构的两个输出子段经过异或运算产生这一轮的 4 个输出子段。注意, 由 $\mathrm{X}_{2}$ 产生的输出子段和由 $\mathrm{X}_{3}$ 产生的输出子段交换位置后形成 $\mathrm{W}_{12}$ 和 $\mathrm{W}_{13}$, 目的在于进一步增加混淆效果, 使得算法更易抵抗密码分析。

算法的第 9 步是一个输出变换,如图 4-17 所示。它的结构和每一轮开始的变换结构一样, 不同之处在于输出变换的第 2 个和第 3 个输人首先交换了位置, 目的在于撤销第 8 轮输出中两个子段的交换。还需注意, 第 9 步仅需 4 个子密钥,而前面 8 轮中每轮需要 6 个子密钥。



图 4-16 IDEA 第 1 轮的结构示意图



图 4-17 IDEA 的输出变换

## 子密钥的产生

加密过程中 52 个 16 比特的子密钥是由 128 比特的加密密钥按如下方式产生的: 前 8 个子密钥 $Z_{1}, Z_{2}, \cdots, Z_{8}$ 直接从加密密钥中取, 即 $Z_{1}$ 取前 16 比特 (最高有效位), $Z_{2}$ 取下面的 16 比特, 依次类推。然后加密密钥循环左移 25 位, 再取下面 8 个子密钥 $Z_{9}, Z_{10}, \cdots, Z_{16}$, 取法与 $\mathrm{Z}_{1}, \mathrm{Z}_{2}, \cdots, \mathrm{Z}_{8}$ 的取法相同。这一过程重复下去, 直到 52 个子密钥都被产生为止。

## 解密过程

解密过程和加密过程基本相同, 但子密钥的选取不同。解密子密钥 $U_{1}, U_{2}, \cdots, U_{52}$ 是由加密子密钥按如下方式得到 (将加密过程最后一步的输出变换当作第 9 轮)

(1) 第 $i(i=1, \cdots, 9)$ 轮解密的前 4 个子密钥由加密过程第 $(10-i)$ 轮的前 4 个子密钥得
出: 其中第 1 和第 4 个解密子密知取为相应的第 1 和第 4 个加密子密钥的模 $2^{16}+1$ 乘法逆元, 第 2 和第 3 个子密钥的取法为: 当轮数 $i=2, \cdots, 8$ 时, 取为相应的第 3 个和第 2 个加密子密钥的模 $2^{16}$ 加法逆元。 $i=1$ 和 9 时, 取为相应的第 2 个和第 3 个加密子密钥的模 $2^{16}$ 加法逆元。

(2) 第 $\mathrm{i}(\mathrm{i}=1, \cdots, 8)$ 轮解密的后两个子密钥等于加密过程第 $(9-\mathrm{i})$ 轮的后两个子密钥。


图 4-18 IDEA 加密和解密框图

### 4.3.1.4 AES 算法—Rijndael

1997 年 4 月 15 日,美国 ANSI 发起征集 AES(Advanced Encryption Standard)的活动,并为此成立了 AES 工作小组。此次活动的目的是确定一个非保密的、可以公开技术细节的和全球免费使用的分组密码算法, 以作为新的数据加密标准。1997 年 9 月 12 日, 美国联邦登记处公布了正式征集 AES 候选算法的通告。对 AES 的基本要求是: 比三重 DES 快、至少与三重 DES 一样安全、数据分组长度为 128 比特和密钥长度为 $128 / 192 / 256$ 比特。1998 年 8 月 12 日,在首届 AES 候选会议 (first AES candidate conference) 上公布了 AES 的 15 个候选算法, 任由全世界各机构和个人攻击和评论, 这 15 个候选算法是 CAST256、CRY PTON、E2、DEAL、FROG、SAFER +、RC6、MAGENTA、LOKI97、SERPENT、MARS、Rijndael、DFC、Twofish、HPC。1999 年 3 月, 在第 2 届 AES 侯选会议 (second AES candidate conference) 上经过对全球各密码机构和个人对候选算法分析结果的讨论, 从 15 个候选算法中选出了 5 个。这 5 个是 RC6、Rijndael、SERPENT、Twofish 和 MARS。2000 年 4 月 13 日至 14 日,召开了第 3 届 AES 候选会议 (third AES candidate conference), 继续对最后 5 个候选算法进行讨论。2000 年 10 月 2 日, NIST 宣布 Rijndael 作为新的 AES。至此, 经过 3 年多的讨论,Rijndael 终于脱颖而出。

Rijndael 由比利时的 Joan Daemen 和 Vincent Rijmen 设计, 算法的原型是 Square 算法。

## Rijndael 的数学基础和设计思想有限域 $\mathbf{G F}\left(\mathbf{2}^{\mathbf{8}}\right)$

有限域中的元素可以用多种不同的方式表示。对于任意素数的方幕, 都有惟一的一个有限域, 因此 $\operatorname{GF}\left(2^{8}\right)$ 的所有表示是同构的, 但不同的表示方法会影响到 $\operatorname{GF}\left(2^{8}\right)$ 上运算的复杂度, 本算法采用传统的多项式表示法。将 $\mathrm{b}_{7} \mathrm{~b}_{6} \mathrm{~b}_{5} \mathrm{~b}_{4} \mathrm{~b}_{3} \mathrm{~b}_{2} \mathrm{~b}_{1} \mathrm{~b}_{0}$ 构成的字节 $\mathrm{b}$ 看成系数在 $\{0$, $1\}$ 中的多项式 $\mathrm{b}_{7} \mathrm{x}^{7}+\mathrm{b}_{6} \mathrm{x}^{6}+\mathrm{b}_{5} \mathrm{x}^{5}+\mathrm{b}_{4} \mathrm{x}^{4}+\mathrm{b}_{3} \mathrm{x}^{3}+\mathrm{b}_{2} \mathrm{x}^{2}+\mathrm{b}_{1} \mathrm{x}+\mathrm{b}_{0}$ 。例如: 十六进制数 “ 57 , 对应的二进制为 01010111 , 看成一个字节, 对应的多项式为 $x^{6}+x^{4}+x^{2}+x+1$ 。在多项式表示中, $\mathrm{GF}\left(2^{8}\right)$ 上两个元素的和仍然是一个次数不超过 7 的多项式, 其系数等于两个元素对应系数的模 2 加 (比特异或)。例如: ‘ $57 '+{ }^{\prime} 83$ ' $={ }^{\prime} \mathrm{D} 4$ ', 用多项式表示为 $\left(x^{6}+x^{4}+x^{2}+x+\right.$ 1) $+\left(x^{7}+x+1\right)=x^{7}+x^{6}+x^{4}+x^{2}(\bmod m(x))$ 。用二进制表示为 $01010111+10000011=$ 11010100 , 由于每个元素的加法逆元等于自己, 所以减法和加法相同。要计算 GF $\left(2^{8}\right)$ 上的乘法, 必须先确定一个 $G F(2)$ 上的 8 次不可约多项式; $G F\left(2^{8}\right)$ 上两个元素的乘积就是这两个多项式的模乘 (以这个 8 次不可约多项式为模)。在 Rijndael 密码中, 这个 8 次不可约多项式确定为 $m(x)=x^{8}+x^{4}+x^{3}+x+1$,

它的十六进制表示为 “11B'。例如, “ 57 ', ' 83 ' = $\mathrm{C} 1$ '可表示为以下的多项式乘法:

$\left(x^{6}+x^{4}+x^{2}+x+1\right) \cdot\left(x^{7}+x+1\right)=x^{7}+x^{6}+1(\bmod m(x))$ 。乘法运算虽然不是标准的按字节的运算,但也是比较简单的计算部件。

以上定义的乘法满足交换律, 且有单位元 ' 01 ’。另外, 对任何次数小于 8 的多项式 $b$ $(\mathrm{x})$, 可用推广的欧几里得算法得 $\mathrm{b}(\mathrm{x}) \mathrm{a}(\mathrm{x})+\mathrm{m}(\mathrm{x}) \mathrm{c}(\mathrm{x})=1$, 即 $\mathrm{a}(\mathrm{x}) \cdot \mathrm{b}(\mathrm{x})=1 \bmod \mathrm{m}(\mathrm{x})$,因此 $a(x)$ 是 $b(x)$ 的乘法逆元。再者, 乘法还满足分配律: $a(x) \cdot(b(x)+c(x))=a(x) \cdot b$ $(x)+a(x) \cdot c(x)$ 。所以, 256 个字节值构成的集合, 在以上定义的加法和乘法运算下, 有有限域 $\mathrm{GF}\left(2^{8}\right)$ 的结构。

$\mathrm{GF}\left(2^{8}\right)$ 上还定义了一个运算, 称之为 $\mathrm{x}$ 乘法, 其定义为 $\mathrm{x} \cdot \mathrm{b}(\mathrm{x})=\mathrm{b}_{7} \mathrm{x}^{8}+\mathrm{b}_{6} \mathrm{x}^{7}+\mathrm{b}_{5} \mathrm{x}^{6}+$ $b_{4} x^{5}+b_{3} x^{4}+b_{2} x^{3}+b_{1} x^{2}+b_{0} x(\bmod m(x))$, 如果 $b_{7}=0$, 求模结果不变, 否则为乘积结果减去 $\mathrm{m}(\mathrm{x})$, 即求乘积结果与 $\mathrm{m}(\mathrm{x})$ 的异或。由此得出 $\mathrm{x}$ (十六进制数 ${ }^{\circ} 02$ ') 乘 $\mathrm{b}(\mathrm{x})$ 可以先对 $\mathrm{b}$ $(\mathrm{x})$ 在字节内左移一位 (最后一位补 0 ), 若 $\mathrm{b}_{7}=1$, 则再与 “ $1 \mathrm{~B}$ ’ (其二进制为 00011011 ) 做逐比特异或来实现, 该运算记为 $b=x$ time (a)。在专用芯片中, $x$ time 只需 4 个异或。 $x$ 的幕乘运算可以重复应用 xtime 来实现。而任意常数乘法可以通过对中间结果相加实现。例如, '57'. '13'可按如下方式实现:

'57'. '02' =xtime(57)='AE';

${ }^{57} \cdot \cdot \cdot 04 '=x \operatorname{xtime}(\mathrm{AE})={ }^{\prime} 47$ ';

${ }^{57} \cdot \cdot{ }^{\circ} 08,=x \operatorname{time}(47)={ }^{\prime} 8 \mathrm{E}$ ';

' $57 \cdot \cdot \cdot 10$ ' $=$ xtime $(8 \mathrm{E})={ }^{\prime} 07$ ';



$$
={ }^{\circ} 57, \oplus{ }^{\prime} \mathrm{AE}, \oplus{ }^{\circ} 07,={ }^{\prime} \mathrm{FE} \prime
$$

系数在 $\mathrm{GF}\left(2^{8}\right)$ 上的多项式

4 个字节构成的向量可以表示为系数在 GF $\left(2^{8}\right)$ 上的次数小于 4 的多项式。多项式的加法就是对应系数相加; 换句话说, 多项式的加法就是 4 字节向量的逐比特异或。规定多项
式的乘法运算必须要取模 $\mathrm{M}(\mathrm{x})=\mathrm{x}^{4}+1$, 这样使得次数小于 4 的多项式的乘积仍然是一个次数小于 4 的多项式, 将多项式的模乘运算记为, 设 $a(x)=a_{3} x^{3}+a_{2} x^{2}+a_{1} x+a_{0}, b(x)=$ $\mathrm{b}_{3} \mathrm{x}^{3}+\mathrm{b}_{2} \mathrm{x}^{2}+\mathrm{b}_{1} \mathrm{x}+\mathrm{b}_{0}, \mathrm{c}(\mathrm{x})=\mathrm{a}(\mathrm{x}) \cdot \mathrm{b}(\mathrm{x})=\mathrm{c}_{3} \mathrm{x}^{3}+\mathrm{c}_{2} \mathrm{x}^{2}+\mathrm{c}_{1} \mathrm{x}+\mathrm{c}_{0}$ 。由于 $\mathrm{x}^{j} \bmod \left(\mathrm{x}^{4}+1\right)=$ $\mathrm{x}^{\mathrm{j} \text { mod } 4}$, 所以

$\mathrm{c}_{0}=\mathrm{a}_{0} \mathrm{~b}_{0} \oplus \mathrm{a}_{3} \mathrm{~b}_{1} \oplus \mathrm{a}_{2} \mathrm{~b}_{2} \oplus \mathrm{al}_{2} \mathrm{~b}_{3} ;$

$\mathrm{c}_{1}=\mathrm{a}_{1} \mathrm{~b}_{0} \oplus \mathrm{a}_{0} \mathrm{~b}_{1} \oplus \mathrm{a}_{3} \mathrm{~b}_{2} \oplus \mathrm{a}_{2} \mathrm{~b}_{3} ;$

$\mathrm{c}_{2}=\mathrm{a}_{2} \mathrm{~b}_{0} \oplus \mathrm{a}_{1} \mathrm{~b}_{1} \oplus \mathrm{a}_{0} \mathrm{~b}_{2} \oplus \mathrm{a}_{3} \mathrm{~b}_{3} ;$

$\mathrm{c}_{3}=\mathrm{a}_{3} \mathrm{~b}_{0} \oplus \mathrm{a}_{2} \mathrm{~b}_{1} \oplus \mathrm{a}_{1} \mathrm{~b}_{2} \oplus \mathrm{a}_{0} \mathrm{~b}_{3}$ 。

可将上述计算表示为

$$
\left(\begin{array}{l}
c_{0} \\
c_{1} \\
c_{2} \\
c_{3}
\end{array}\right)=\left(\begin{array}{llll}
a_{0} & a_{3} & a_{2} & a_{1} \\
a_{1} & a_{0} & a_{3} & a_{2} \\
a_{2} & a_{1} & a_{0} & a_{3} \\
a_{3} & a_{2} & a_{1} & a_{0}
\end{array}\right)\left(\begin{array}{l}
b_{0} \\
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right)
$$

注意到 $M(x)$ 不是 $G F\left(2^{8}\right)$ 上的不可约多项式(甚至也不是 GF(2) 上的不可约多项式), 因此非 0 多项式的这种乘法不是群运算。不过在 Rijndael 密码中, 对多项式 $b(x)$, 这种乘法运算只限于乘一个固定的有逆元的多项式 $a(x)=a_{3} x^{3}+a 2 x^{2}+a 1 x+a 0$ 。

## 设计思想

Rijndael 密码的设计力求满足以下 3 条标准:

(1) 抵抗所有已知的攻击。

(2) 在多个平台上速度快, 编码紧凑。

(3) 设计简单。

## 算法说明

Rijndael 是一个迭代型分组密码, 其分组长度和密钥长度都可变, 各自可以独立地指定为 128 比特、192 比特、256 比特。

## 状态、种子密钥和轮数

类似于明文分组和密文分组,算法的中间结果也需分组,称算法中间结果的分组为状态, 所有的操作都在状态上进行。状态可以用以字节为元素的矩阵阵列表示, 该阵列有 4 行, 列数记为 $N_{b}, N_{b}$ 等于分组长度除以 32 。种子密钥类似地用一个以字节为元素的矩阵阵列表示, 该阵列有 4 行, 列数记为 $N_{k}, N_{k}$ 等于分组长度除以 32 。有时可将这些分组当作一维数组, 其每一元素是上述阵列表示中的 4 字节元素构成的列向量, 数组长度可为 $4 、 6 、 8$,数组元素下标的范围分别是 $0 \sim 3,0 \sim 5$ 和 $0 \sim 7$ 。 4 字节元素构成的列向量有时也称为字。

算法的输人和输出被看成是由 8 比特字节构成的一维数组, 其元素下标的范围是 $0 \sim$ ( $\left.4 \mathrm{~N}_{\mathrm{b}}-1\right)$, 因此输人和输出以字节为单位的分组长度分别是 16.24 和 32 , 其元素下标的范围分别是 $0 \sim 15 、 0 \sim 23$ 和 $0 \sim 31$ 。输人的种子密钥也看成是由 8 比特字节构成的一维数组, 其元素下标的范围是 $0 \sim\left(4 \mathrm{~N}_{\mathrm{k}}-1\right)$, 因此种子密钥以字节为单位的分组长度也分别是 16、24 和 32,其元素下标的范围分别是 0 15、0 23 和 $0 \sim 31$ 。

算法的输人 (包括最初的明文输人和中间过程的轮输人) 以字节为单位按 $\mathrm{a}_{0} \mathrm{a}_{10} \mathrm{a}_{20} \mathrm{a}_{30} \mathrm{a}_{01}$ $a_{11} a_{21} a_{31} \cdots$ 的顺序放置到状态阵列中。同理, 种子密钥以字节为单位按 $k_{00} k_{10} k_{20} k_{30} k_{01} k_{11} k_{21}$ $\mathrm{k}_{31}$ 的顺序放置到种子密钥阵列中。而输出(包括中间过程的轮输出和最后的密文输出) 也
是以字节为单位按相同的顺序从状态阵列中取出。若输人 (或输出) 分组中第 $\mathrm{n}$ 个元素对应于状态阵列的第 $(i, j)$ 位置上的元素, 则 $n$ 和 $(i, j)$ 有以下关系:

$\mathrm{i}=\mathrm{n} \bmod 4 ; \mathrm{j}=[n / 4] ; n=i+4 \mathrm{j}$ 。迭代的轮数记为 $\mathrm{N}_{\mathrm{r}}, \mathrm{N}_{\mathrm{r}}$ 与 $\mathrm{N}_{\mathrm{b}}$ 和 $\mathrm{N}_{\mathrm{k}}$ 有关。

## 轮函数

Rijndael 的轮函数由 4 个不同的计算部件组成, 分别是: 字节代换 (ByteSub)、行移位 (ShiftRow)、列混合 (MixColumn)、密钥加(AddRoundKey)。

(1) 字节代换(ByteSub)

字节代换是非线形变换,独立地对状态的每个字节进行。代换表 (即 S一盒)是可逆的，由以下两个变换的合成得到:

(1) 首先, 将字节看作 $\mathrm{GF}\left(2^{8}\right)$ 上的元素, 映射到自己的乘法逆元, ${ }^{\circ} 00$ 映射到自己。

(2) 其次,对字节做如下的 (GF(2)上的,可逆的)仿射变换:

$$
\left(\begin{array}{c}
\mathrm{y}_{0} \\
\mathrm{y}_{1} \\
\mathrm{y}^{2} \\
\mathrm{y}_{3} \\
\mathrm{y}_{4} \\
\mathrm{y}_{5} \\
\mathrm{y}_{6} \\
\mathrm{y}_{7}
\end{array}\right)=\left(\begin{array}{llllllll}
1 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\
1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 \\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1
\end{array}\right)\left(\begin{array}{l}
\mathrm{x}_{0} \\
\mathrm{x}_{1} \\
\mathrm{x}_{2} \\
\mathrm{x}_{3} \\
\mathrm{x}_{4} \\
\mathrm{x}_{5} \\
\mathrm{x}_{6} \\
\mathrm{x}_{7}
\end{array}\right)+\left(\begin{array}{l}
1 \\
1 \\
0 \\
0 \\
0 \\
1 \\
1 \\
0
\end{array}\right)
$$

上述 S 盒对状态的所有字节所做的变换记为 ByteSub (State)。

| $a_{00}$ | $a_{01}$ | $a_{02}$ | $a_{03}$ | $a_{04}$ | $a_{05}$ | S盒 | $b_{00}$ | $b_{01}$ | $b_{02}$ | $b_{03}$ | $b_{04}$ | $b_{05}$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| $a_{10}$ | $a_{11}$ | $a$ | $a_{i j}$ | $2_{14}$ | $a_{15}$ |  | $b_{10}$ | $b_{1}$ | $b_{i j}$ | 13 | $b_{14}$ | $b_{15}$ |
| $a_{20}$ | $a_{21}$ | $a_{22}$ | $a_{23}$ | $a_{24}$ | $a_{25}$ |  | $b_{20}$ | $b_{21}$ | $b_{22}$ | $b_{23}$ | $b_{24}$ | $b_{25}$ |
| $a_{30}$ | $a_{31}$ | $a_{32}$ | $a_{33}$ | $a_{34}$ | $a_{35}$ |  | $b_{30}$ | $b_{31}$ | $b_{32}$ | $b_{33}$ | $b_{34}$ | $b_{35}$ |

图 4-19 字节代换

ByteSub 的逆变换由代换表的逆表做字节代换,可通过如下两步实现: 首先进行仿射变换的逆变换,再求每一字节在 $\mathrm{GF}\left(2^{8}\right)$ 上逆元。

(2) 行移位(ShiftRow)

行移位是将状态阵列的各行进行循环移位, 不同状态行的位移量不同。第 0 行不移动,第 1 行循环左移 $C_{1}$ 个字节, 第 2 行循环左移 $C_{2}$ 个字节, 第 3 行循环左移 $C_{3}$ 个字节。位移量 $\mathrm{C}_{1} 、 \mathrm{C}_{2}$ 和 $\mathrm{C}_{3}$ 的取值与 $\mathrm{N}_{\mathrm{b}}$ 有关。

按指定的位移量对状态的行进行的行移位运算记为 ShiftRow (State)。图 4-20 是行移位示意图。

| $a_{00}$ | $a_{01}$ | $a_{02}$ | $a_{03}$ | $a_{04}$ | $a_{05}$ | 左移 0 位 | $a_{00}$ | $a_{01}$ | $a_{02}$ | $a_{03}$ | $a_{04}$ | $a_{05}$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| $a_{10}$ | $a_{11}$ | $a_{12}$ | $a_{13}$ | $a_{14}$ | $a_{15}$ | 左移0位 | $a_{11}$ | $a_{12}$ | $a_{13}$ | $a_{14}$ | $a_{15}$ | $a_{10}$ |
| $a_{20}$ | $a_{21}$ | $a_{22}$ | $a_{23}$ | $a_{24}$ | $a_{25}$ | 左移 0 位 | $a_{22}$ | $a_{23}$ | $\overline{a_{24}}$ | $a_{25}$ | $a_{20}$ | $a_{21}$ |
| $a_{30}$ | $a_{31}$ | $a_{32}$ | $a_{33}$ | $a_{34}$ | $a_{35}$ |  | $a_{33}$ | $a_{34}$ | $a_{35}$ | $a_{30}$ | $a_{31}$ | $a_{32}$ |

图 4-20 行移位

ShiftRow 的逆变换是对状态阵列的后 3 列分别以位移量 $N_{b}-C_{1} 、 N_{b}-C_{2} 、 N_{b}-C_{3}$ 进行循环移位, 使得第 $\mathrm{i}$ 行第 $\mathrm{j}$ 列的字节移位到 $\left(\mathrm{j}+\mathrm{N}_{\mathrm{b}}-\mathrm{C}_{\mathrm{i}}\right) \bmod \mathrm{N}_{\mathrm{b}}$ 。

(3) 列混合 (MixColumn)

在列混合变换中, 将状态阵列的每个列视为 $G F\left(2^{8}\right)$ 上的多项式, 再与一个固定的多项式 $c(x)$ 进行模 $x^{4}+1$ 乘法。当然要求 $c(x)$ 是模 $x^{4}+1$ 可逆的多项式,否则列混合变换就是不可逆的,因而会使不同的输人分组对应的输出分组可能相同。Rijndael 的设计者给出的 $\mathrm{c}(\mathrm{x})$ 为 (系数用十六进制数表示) $\mathrm{c}(\mathrm{x})={ }^{\prime} 03^{\prime} \mathrm{x}^{3}+{ }^{\prime} 01^{\prime} \mathrm{x}^{2}+{ }^{\prime} 01^{\prime} \mathrm{x}+{ }^{\prime} 02^{\prime}, \mathrm{c}(\mathrm{x})$ 是与 $\mathrm{x}^{4}+1$互素的, 因此是模 $x^{4}+1$ 可逆的。列混合运算也可写为矩阵乘法。设 $b(x)=c(x) \otimes a(x)$,则

$$
\left(\begin{array}{l}
b_{0} \\
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right)=\left(\begin{array}{llll}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02
\end{array}\right)\left(\begin{array}{c}
a_{0} \\
a_{1} \\
a_{2} \\
a_{3}
\end{array}\right)
$$

这个运算需要做 $\mathrm{GF}\left(2^{8}\right)$ 上的乘法,但由于所乘的因子是 3 个固定的元素 $02,03,01$,所以这些乘法运算仍然是比较简单的。对状态 State 的所有列所做的列混合运算记为 MixColumn (State)。图 4-21 是列混合运算示意图。

| $a_{00}$ | $a_{01}$ | $a_{02}$ | $a_{0 j}$ | $a_{04}$ | $a_{05}$ | $\otimes c(x)$ | $\widehat{b_{00}}$ | $b_{1}$ | $b_{0 j}$ | $b_{03}$ | $b_{04}$ | $b_{05}$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| $a_{10}$ | $a_{11}$ | $a_{12}$ | $a_{1 j}$ | $a_{14}$ | $a_{15}$ |  | $b_{10}$ | $b_{11}$ | $b_{1 j}$ | $a_{13}$ | $b_{14}$ | $b_{15}$ |
| $a_{20}$ | $a_{21}$ | $a_{22}$ | $a_{2 j}$ | $a_{24}$ | $a_{25}$ |  | $b_{20}$ | $b_{21}$ | $b_{2 j}$ | $b_{23}$ | $b_{24}$ | $b_{25}$ |
| $a_{30}$ | $a_{31}$ | $a_{32}$ | $a_{3 j}$ | $a_{34}$ | $a_{35}$ |  | $b_{30}$ | $b_{31}$ | $b_{3 j}$ | $b_{33}$ | $b_{34}$ | $b_{35}$ |

图 4-21 列混合运算示意图

列混合运算的逆运算是类似的,即每列都用一个特定的多项式 $d(x)$ 相乘。 $d(x)$ 满足


$+{ }^{\prime} 09{ }^{\prime} \mathrm{x}+{ }^{\circ} 0 \mathrm{E}$ '。

(4) 密钥加 (AddRoundKey)

密钥加是将轮密钥简单地与状态进行逐比特异或。轮密钥由种子密钥通过密钥编排算法得到, 轮密钥长度等于分组长度 $N_{b}$ 。状态 State 与轮密钥 RoundKey 的密钥加运算表示
为 AddRoundKey (State, RoundKey)。图 4-22 是密钥加运算示意图。

| $a_{00}$ | $a_{11}$ | $a_{02}$ | $a_{03}$ | $a_{04}$ | $a_{05}$ |
| :--- | :--- | :--- | :--- | :--- | :--- |
| $a_{10}$ | $a_{11}$ | $a_{12}$ | $a_{13}$ | $a_{14}$ | $a_{15}$ |
| $a_{20}$ | $a_{21}$ | $a_{22}$ | $a_{23}$ | $a_{24}$ | $a_{25}$ |
| $a_{30}$ | $a_{31}$ | $a_{32}$ | $a_{33}$ | $a_{34}$ | $a_{35}$ |



图 4-22 密钥加运算

密钥加运算的逆运算是其自身。

综上所述, 组成 Rijndael 轮函数的计算部件简捷快速, 功能互补。轮函数的伪 C 代码如下:



结尾轮的轮函数与前面各轮不同, 将 Mix Column 这一步去掉, 其伪 C 代码如下:

FinalRound (State, RoundKey)

\{

ByteSub (State);

ShiftRow (State);

AddRoundKey (State, RoundKey);

\}

## 密钥编排

密钥编排指从种子密钥得到轮密钥的过程, 它由密钥扩展和轮密钥选取两部分组成。其基本原则如下：

- 轮密钥的比特数等于分组长度乘以轮数加 1 ;
- 种子密钥被扩展成为扩展密钥;
- 轮密钥从扩展密钥中取, 其中第 1 轮轮密钥取扩展密钥的前 $\mathrm{N}_{\mathrm{b}}$ 个字, 第 2 轮轮密钥取接下来的 $\mathrm{N}_{\mathrm{b}}$ 个字, 如此下去。


## 密钥扩展

扩展密钥是以 4 字节字为元素的一维阵列, 表示为 $W\left[N_{b} *\left(N_{r}+1\right)\right]$, 其中前 $N_{k}$ 个字取为种子密钥, 以后每个字按递归方式定义。扩展算法根据 $\mathrm{N}_{\mathrm{k}} \leqslant 6$ 和 $\mathrm{N}_{\mathrm{k}}>6$ 有所不同。

## 轮密钥选取

轮密钥 $i$ (即第 $\mathrm{i}$ 个轮密钥) 由轮密钥缓冲字 $W\left[N_{b} * i\right]$ 到 $W\left[N_{b} *(i+1)\right]$ 给出, 如图 4-23所示。

| $\mathrm{W}_{0}$ | $\mathrm{~W}_{1}$ | $\mathrm{~W}_{2}$ | $\mathrm{~W}_{3}$ | $\mathrm{~W}_{4}$ | $\mathrm{~W}_{5}$ | $\mathrm{~W}_{6}$ | $\mathrm{~W}_{7}$ | $\mathrm{~W}_{8}$ | $\mathrm{~W}_{9}$ | $\mathrm{~W}_{10}$ | $\mathrm{~W}_{11}$ | $\mathrm{~W}_{12}$ | $\mathrm{~W}_{13}$ | $\mathrm{~W}_{14}$ | $\cdots$ |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 轮密钥 0 |  |  | 轮密钥 1 |  |  | $\ldots$ |  |  |  |  |  |  |  |  |  |

图 4-23 $\mathrm{N}_{\mathrm{b}}=6$ 且 $\mathrm{N}_{\mathrm{k}}=4$ 时的密钥扩展与轮密钥选取

## 加密算法

加密算法为顺序完成以下操作: 初始的密钥加; ( $\left.\mathrm{N}_{\mathrm{r}}-1\right)$ 轮迭代; 一个结尾轮。即 Rijndael (State, CipherKey)

KeyExpansion (CipherKey, ExpandedKey);

AddRoundKey (State, Expanded Key);

for $(\mathrm{i}=1$; i $<\mathrm{Nr} ; \mathrm{i}++$ )

Round (State, ExpandedKey $+\mathrm{Nb} * \mathrm{i}$ );

FinalRound (State, Expanded Key $+\mathrm{Nb} * \mathrm{Nr}$ );

\}

其中 CipherKey 是种子密钥, ExpandedKey 是扩展密钥。密钥扩展可以事先进行 (预计算), 且 Rijndael 密码的加密算法可以用这一扩展密钥来描述, 即

Rijndael (State, Expanded Key)

AddRoundKey (State, ExpandedKey);

for $(\mathrm{i}=1 ; \mathrm{i}<\mathrm{Nr} ; \mathrm{i}++$ )

Round (State, ExpandedKey $+\mathrm{Nb} * \mathrm{i}$ );

FinalRound (State, Expanded Key $+\mathrm{Nb} * \mathrm{Nr}$ );

\}

## 解密算法

Rijndael 密码的解密算法为顺序完成以下操作: 初始的密钥加; ( $\mathrm{N}_{\mathrm{r}}-1$ ) 轮迭代; 一个结尾轮。轮函数为

InvRound (State, RoundKey)

\{

InvByteSub (State);

InvShiftRow (State);

Inv MixColumn (State);

AddRoundKey (State, RoundKey);

\}

解密算法的结尾轮为

InvFinalRound (State, RoundKey)

\{

InvByteSub（State）;

InvShiftRow (State);

AddRoundKey (State, RoundKey); \}

### 4.3.2 非对称密码体制

W.Diffie 和 M.Hellman 1976 年在 IEEE Trans.on Information 刊物上发表了 “New Direction in Cryptography” 文章,提出了 “非对称密码体制即公开密钥密码体制” 的概念, 开创了密码学研究的新方向。

在种种加密技术当中, 公钥密码体系无疑是其中闪亮的一颗明珠。在公开密钥密码体制中 (如图 4-24), 加密密钥是公开的, 解密密钥是保密的, 加/解密算法都是公开的, 因此,密钥的分配和管理就很简单。加密密钥与解密密钥不同, 且由其中一个推算不出另一个, 则这种密码系统是非对称密钥系统。其中一个密钥是公开的, 另一个是保密的。因此, 相应的密码体制叫公开密钥密码体制。

公钥密码体系不要求通信双方事先传递密钥或有任何约定就能完成保密通信, 并且密钥管理方便, 可实现防止假冒和抵赖, 因此, 更适合网络通信中的保密通信要求。公开密钥密码体制的主要算法有 RSA、Elgamal、背包算法、Rabin 和DH 等, 使用最广泛的是 RSA (Data Encryption Standard)密码算法。非对称密钥加密的工作原理如下:

(1) A 要向 B 发送消息, A 和 B 都要产生一对用于加密和解密的公钥和私钥。

(2) $\mathrm{A}$ 的私钥保密, $\mathrm{A}$ 的公钥告诉 $\mathrm{B} ; \mathrm{B}$ 的私钥保密, B 的公钥告诉 $\mathrm{A}$ 。

(3) A 要给 $B$ 发消息时, A 用 B 的公钥加密消息,因为 A 知道 B 的公钥。

(4) $\mathrm{A}$ 将这个消息发给 $\mathrm{B}$ (已经用 $\mathrm{B}$ 的公钥加密消息)。

(5) $\mathrm{B}$ 收到这个消息后, $\mathrm{B}$ 用自己的私钥解密 $\mathrm{A}$ 的消息。其他所有收到这个报文的人都无法解密, 因为只有 B 才有 B 的私有密钥。



图 4-24 非对称密钥加密模型

用 $K_{e}$ 对明文加密后, 再用 $K_{d}$ 解密, 即可恢复出明文, 加密和解密运算可以对调, 但加密密钥不能用来解密, 在计算上很容易产生密钥对 $K_{c}$ 和 $K_{d}$, 已知 $K_{c}$ 是不能推导出 $K_{d}$ 的,或者说从 $K_{e}$ 得到 $K_{d}$ 是“计算上不可能的”。

### 4.3.2.1 数论基础

(1) 模运算

同余: 如果 $a=b+k n, k$ 为整数,则

$$
a \equiv b \bmod n
$$

含义: $\mathrm{b}$ 是 $\mathrm{a}$ 除以 $\mathrm{n}$ 的余数;

$b$ 为 $a$ 模 $n$ 的余数;

$\mathrm{a}$ 与 $\mathrm{b}$ 模 $\mathrm{n}$ 同余。
$a \bmod n: a$ 模 $n$ 操作,表示 $\mathrm{a}$ 除以 $\mathrm{n}$ 的余数,为 0 到 $\mathrm{n}-1$ 之间的整数。

例如: $(7+8) \bmod 12=15 \bmod 12=3$

$$
\Leftrightarrow 15 \equiv 3 \bmod 12
$$

模运算 (+、一) 满足交换律、结合律和分配律。

按模计算原理: 对中间结果作模运算与做完了全部运算后再做模运算结果相同。

(2) 素数

一个只能被 1 和它本身整除的正整数。如以下各数为素数: $2,3,5,7,11,13,17,19$, $23,29,31,37,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113, \cdots, 2521$ 等都是素数。

(3) 两数互素

两个数的最大公因子为 1 , 则两数互素。

$\operatorname{gcd}(\mathrm{a}, \mathrm{n})=1 \quad \mathrm{a}$ 和 $\mathrm{n}$ 互素

15 与 28 互素, 13 与 500 互素, 而 15 与 27 不是互素。一个素数与它的倍数以外的任何其他数都是互素的。

(4) 因子分解

对于一个数进行因子分解, 就是找出其各个素数因子, 如: $15=3 * 5$, $80=2 * 2 * 2 * 2 * 5,252601=41 * 61 * 101$ 等。在数论中, 因子分解是一个古老的问题。分解一个数很简单, 但其过程很费时。

### 4.3.2.2 RSA 算法

## 1. RSA 算法概述

RSA 算法是 1978 年由三名美国 MIT 科学家 Rivest, Shamir 和 Adelman 提出的一种著名的公开密钥密码算法(以该三位姓氏的第一个字母命名)。

经过多年的分析研究, 在众多的公钥体制中, RSA 倍受推崇, 已被 ISO/TC97 的数据加密技术分委员会 SC20 推荐为公钥数据加密标准。RSA 算法是建立在素数理论 (Euler 函数和欧几里德定理) 基础上的算法。RSA 算法基于这样的数学事实:两个大素数很容易相乘, 而对得到的积求因子则很难。

由数论知识可知, 将一个具有大素数因子的合数进行分解是很困难的, 或者说这个计算量是令人望而生畏的。RSA 正是建立在这个理论基础之上的。

$R S A$ 算法的加密密钥 $K_{e}$ 是公开的,而解密密聅 $K_{d}$ 是保密的。

在此不介绍 RSA 的理论基础(复杂的数学分析和理论推导), 只简单介绍密钥的选取和加、解密的实现过程。

假设用户 $\mathrm{A}$ 要对发送给 $\mathrm{B}$ 的数据加密, 则可根据以下步骤选择密钥和进行密码变换:

(1) 随机地选取两个不同的大素数 P, Q(一般为 100 位以上的十进制数) 予以保密。

(2) 计算 $\mathrm{N}=\mathrm{P} * \mathrm{Q}$ 。

(3) 选择一个公钥 $E$ (加密密钥), 使其不是 $(P-1)$ 与 $(Q-1)$ 的因子。

(4) 选择私钥 D(解密密钥), 满足下列条件:

$$
(D * E) \bmod (P-1) *(Q-1)=1
$$

(5)加密时,明文转换密文的公式如下:

$$
\mathrm{CT}=\mathrm{PT}^{\mathrm{E}} \bmod \mathrm{N}
$$

(6) 将密文 CT 发送接收方。

(7) 接收方解密公式如下:

$$
\mathrm{PT}=\mathrm{CT}^{\mathrm{D}} \bmod \mathrm{N}
$$

## 2. RSA 算法举例

例 1 对“688”进行加密:

(1)选择密钥

1)选择两个大素数 $P=47, Q=71$ 。

2)计算 $\mathrm{N}=\mathrm{P} * \mathrm{Q}=47 * 71=3337$ 。

3 ) 选择一个公钥 $E$ (加密密钥), 使其不是 $(P-1)$ 与 ( $Q-1$ ) 的因子。

(1)求出 $(47-1) *(71-1)=46 * 70=3220$ 。

(2) 3220 的因子为 $2 、 2 、 5 、 7$ 和 23 。 $(3220=2 * 2 * 5 * 7 * 23)$

(3)因此, $\mathrm{E}$ 不能含有因子 $2,5,7$ 和 23 。

(4)取 $\mathrm{E}=79$, 也可以取其他值, 只要不含有因子 2、5、7、23。

4) 选择私钥 $D$ (解密密钥), 满足下列条件: ( D*E) $\bmod (P-1) *(Q-1)=1$ 。

(1) 将 $E 、 P$ 与 $Q$ 的值代人公式: $(D * 79) \bmod (47-1) *(71-1)=1$, 得 $D=1019$ 。

(2)验证 $(1019 * 79) \bmod (47-1) *(71-1)=1$, 满足条件。

(2)加密

密文 $\mathrm{CT}=\mathrm{PT}^{\mathrm{E}} \bmod \mathrm{N}=688^{79} \bmod 3337=1570$ 。

(3)将密文 CT(1570) 发送接收方

(4) 解密

明文 $\mathrm{PT}=\mathrm{CT}^{\mathrm{D}} \bmod \mathrm{N}=1570^{1019} \bmod 3337=688$ 。

例 2 对“HI”进行加密:

$A$ 是发送方, $B$ 是接收方。可以用编码机制编码字母: $A=01, B=02, \cdots, Z=26$ 。假设用这个机制编码字母, 那么其工作如下, 发送方 A 要向接收方 B 发送两个字母 H 和 I。利用 RSA 算法, 字母 H 和 I 的编码如下: 则明文 $H I=0809$ 。

(1) 用字母编号机制 (如 $A=1, B=2, \cdots, Z=26$ ), 这里 $F$ 为 6 , 因此首先将 $F$ 编码为 6 。

(2) 选择密钥

1) 选择两个素数 $P=5, Q=11$ 。
2) 计算 $\mathrm{N}=\mathrm{P} * \mathrm{Q}=55$ 。
3) 选择一个公钥 $\mathrm{E}=3$, 私钥 $\mathrm{D}=27$ 。

(3) 加密

设明文编码为: 空格 $=00, A=01, B=02, \cdots, Z=26$, 则明文 $H I=0809$ 。

$\mathrm{C} 1=(08)^{3} \bmod 55=512 \bmod 55=17$

$\mathrm{C} 2=(09)^{3} \bmod 55=729 \bmod 55=14$

$\mathrm{N}=14, \mathrm{Q}=17$

所以, 密文为 “ $Q N$ ”。

(4) 解密 (恢复明文)

$\mathrm{M} 1=\mathrm{Cd}=(17)^{27} \bmod 55=08$

$\mathrm{M} 2=\mathrm{Cd}=(14)^{27} \bmod 55=09$
因此明文为“HI”。

可以看出 RSA 算法本身很简单, 关键是选择正确的密钥。假设 B 要接收 A 的保密消息, 则要生成私钥 $(D)$ 和公钥 $(E)$, 然后将公钥和数字 $N$ 发给 $A$ 。 $A$ 用 $E$ 和 $N$ 加密消息, 然后将加密的消息发给 $B$ 。 $B$ 用私钥 (D) 解密消息。既然 $B$ 能计算和求出 $D$, 别人也能计算和求出 $\mathrm{D}$, 但并不容易, 这就是 RSA 的关键所在。



对称密钥密码体制存在的最主要问题是: 由于加/解密双方都要使用相同的密钥,因此在发送和接收数据之前, 必须完成密钥的分发。所以,密钥的分发便成了该加密体系中的最薄弱、也是风险最大的环节, 所使用的手段均难保障安全地完成此项工作。这样, 密钥更新的周期加长, 给他人破译密钥提供了机会。对称加密算法另一个缺点是不能实现数字签名。

对称密钥密码算法的特点是算法简单,加/解密运算速度快; 但其密钥管理复杂, 不便于数字签名。而公开密钥密码算法的特点是密钥管理简单, 便于数字签名; 但算法的理论复杂,加/解密运算速度慢。两者的优缺点互补。

在实际应用中, 公开密钥加密系统并没有完全取代对称密钥加密系统, 这是因为公开密钥加密系统是基于尖端的数学难题, 计算非常复杂, 它的安全性更高, 但它实现速度却远赶不上对称密钥加密系统。采用对称密钥加密方法与公开密钥加密方法相结合 (混合) 的方式, 在实际应用中可利用二者的各自优点, 采用对称加密系统加密文件, 采用公开密钥加密系统加密 “加密文件” 的密钥 (会话密钥), 这就是混合加密系统, 它较好地解决了运算速度问题和密钥分配管理问题。因此, 公钥密码体制通常被用来加密关键性的、核心的机密数据,而对称密码体制通常被用来加密大量的数据。如图 4-25 所示。



图 4-25 混合密码体制模型

这种混合加密方式的原理是: 在发送端先使用 DES 或 IDEA 对称算法加密数据, 然后使用公开算法 RSA 加密前者的对称密钥; 到接收端, 先使用 RSA 算法解密出对称密钥, 再用对称密钥解密被加密的数据。要加密的数据量通常很大,但因对称算法对每个分组的处理仅需很短的时间就可完成, 因此对大量数据的加密/解密不会影响效率(若使用 DES 加密芯片,则速度会更快)。

用 RSA 算法将对称密钥加密后就可公开了, 而 RSA 的加密密钥也可以公开, 整个系统
需保密的只有少量 RSA 算法的解密密钥, 因此这些密钥在网络中就很容易被分配和传输了; 又因为对称密钥的数据量很少 (64/128 位), RSA 只需对其做 1 2 个分组的加密/解密即可, 也不会影响系统效率的。因此, 使用这种混合加密方式既可以体现对称算法速度快的优势,也可发挥公钥算法密钥管理方便的优势, 二者各取其优,扬长避短。



随着网络应用的蓬勃发展, Internet 正在融人到社会的方方面面, 网络用户成分越来越复杂, 网络应用越来越深地渗透到了科研、生产、商务和金融等领域, Internet 上也出现了各种目的的数据监听和网络人侵等对他人构成威胁的现象。为了使 Internet 变得更安全些,人们在重要信息传输上选择了数据加密和基于加密技术的身份认证, 在一定程度上防止了信息在网络上被拦截和窃取的问题。

SSL、SET 和 PGP 是当前 Internet 上比较常用的数据加密方法, 它们在各自的应用范围内都拥有很大的用户群。下面将对这三种流行的加密方法做详细介绍。

SSL 协议是由 Netscape 首先发表的网络资料安全传输协定, 其首要目的是在两个通信间提供秘密而可靠的连接。该协议由两层组成, 底层是建立在可靠的传输协议 (例如 TCP)上的是 SSL 的记录层, 用来封装高层的协议。SSL 握手协议准许服务器端与客户端在开始传输数据前, 能够通过特定的加密算法相互鉴别。SSL 的先进之处在于它是一个独立的应用协议,其他更高层协议能够建立在 SSL 协议上。

SSL 是利用公开密钥的加密技术 (RSA) 来作为用户端与主机端在传送机密资料时的加密通讯协定。目前大部分的 WEb Server 及 Browser 都广泛使用 SSL 技术。因此, 可以利用这个功能, 将部分具有机密性质的网页设定在加密的传输模式, 如此即可避免资料在网络上传送时被其他人窃听。

对消费者而言,SSL已经解决了大部分的问题。但是,对电子商务而言问题并没有完全解决, 因为 SSL 只做能到资料保密, 厂商无法确定是谁填下了这份资料, 即使这一点做到了,还有和银行清算的问题。而 SET 的问世,正好填补了这个空白。

SET(Secure Electronic Transaction)是 IBM、信用卡国际组织 (VISA/MasterCard) 以及相关厂商针对网络电子交易共同制定的安全协议, 它运用了 RSA 安全的公钥加密技术,具有资料保密性、资料完整性、资料来源可辨识性及不可否认性, 是用来保护消费者在 $\mathrm{In}^{-}$ ternet 持卡付款交易安全中的标准。SET 1.0 版于 1997 年 6 月正式问世。现在,SET 已成为国际上所公认的在 Internet 电子商业交易中的安全标准。

SET 协议用在安全电子银行卡的支付系统中, 使用客户端的浏览器, 应用于从商业站点到商业银行中。网上银行使用已经存在的程序和设备通过确认信用卡, 清算客户银行户头完成交易。SET 协议则通过隐藏信用卡号来保证整个支付过程的安全。所以, SET 必须保证信用卡持有者与银行在现存系统和网络上, 能够保持持续的联系。SET 协议为在不同的系统中使用信用卡创建了一套完整的解决办法。可靠的身份验证使 SET 成为一个非常好的在线支付系统。它使交易中每个合法参与者能够拥有一个合理的身份, 而对持卡者的身份验证是由银行来进行的。当然这其中还包括其他服务, 比如: 身份认证和客户服务等。
这是建立另外一个可靠的用户连接的方法。同时可以方便在发生纠纷时进行仲裁。

PGP(Pretty Good Privacy) 是一个公钥加密程序, 与以前的加密方法不同的是 PGP 公钥加密的信息只能用私钥解密。在传统的加密方法中, 通常一个密钥既能加密也能解密。那么在开始传输数据前, 如何通过一个不安全的信道传输密钥呢? 使用 PGP 公钥加密法,你可以广泛传播公钥, 同时安全地保存好私钥。由于只有你可拥有私钥, 所以,任何人都可以用你的公钥加密写给你的信息,而不用担心信息被窃听。

使用 PGP 的另一个好处是可以在文档中使用数字签名。一个使用私钥加密的密钥只能用公钥解密。这样, 如果人们阅读用你的公钥解密后的文件, 他们就会确定只有你才能写出这个文件。

PGP 提供了可以用于电子邮件、文件存储和应用的保密及鉴别服务, 选择最可用的加密算法作为系统的构造模块, 且将这些算法集成到一个通用的应用程序中, 该程序独立于操作系统和处理器, 且基于一个使用方便的小命令集。PGP 程序和文档在 Internet 上公开, 由于其免费, 可用于多平台, 使用生命力和安全性都为公众认可的算法等等的特点, 使 PGP 在全世界范围内,各个领域都有广泛的应用,根据《财富》的排名,十大商业银行中 $90 \%$, 十大制药企业中 $80 \%$, 十大健康机构中的 $80 \%$, 十大能源机构中 $70 \%$, 前 15 位宇航及防御系统相关企业中 $73 \%$, 前 20 位电信公司的 $75 \%$, 前 20 位汽车相关制造企业中 $70 \%$, 都在使用 PGP 进行电子邮件及其他重要数据的加密。

一般来说,在开放式网络上进行金融交易以 SSL 及 SET 交易协定为主,其中又以 SET 被国际公认为最安全的, PGP 则被认为是一种非常好的连接网络与桌面的安全方法。

## 实验题

## 实验 4.1 对称数据加密

要求: 任选一款实现了 DES、TDES、IDEA 或 AES 的数据加解密软件(命令行界面或图形界面),下载安装后, 运行软件, 选择一个自己了解其内容的文件进行对称加密。加密后,浏览加密文件的内容, 然后, 再对加密文件进行解密, 之后再浏览其内容。(提示: 记住加密时所用的对称密钥)

## 实验 4.2 混合密钥加密

要求: 在发送端选择一份将要在 Internet 上传输的 Word 文档, 用 IDE A 对称加密算法软件对文件加密, 然后使用非对称算法加密软件 PGP 加密 IDEA 的对称密钥; 发送密文 (包括文件密文和对称密钥密文) 到接收端, 接收端首先使用 PGP 解密出 IDEA 对称密钥, 然后再用对称密钥解密被加密的文件。

## 习 题

4.1 DES 加密算法的工作原理。

4.2 非对称密钥加密的工作原理。

$4.3 \mathrm{p}=43, \mathrm{q}=59, \mathrm{n}=\mathrm{p} \cdot \mathrm{q}=43 * 59=2537, \varphi(\mathrm{n})=(\mathrm{p}-1)(\mathrm{q}-1)=42 * 58=$ 2436 , 取 $\mathrm{e}=13$, 求 $\mathrm{e}$ 的逆元 $\mathrm{d}$ 。

4.4 已知 RSA 密码体制的公开密钥为 $n=51, e=11$, 试加密明文 $\mathrm{M} 1=3$ 。

4.5 已知 $\mathrm{p}=47, \mathrm{q}=71, \mathrm{e}=79, \mathrm{M}=688$, 求 $\mathrm{C}=$ ?

4.6 DES 和 RSA 算法的特点和比较。

## 实验题参考答案

## 实验 4.1 对称数据加密

(略)

## 实验 4.2 混合密钥加密

实验步骤:

在实践中,对称与非对称密钥加密结合起来, 提供了相当高效的安全方案,工作如下,这里假设 $\mathrm{A}$ 是发送方, $\mathrm{B}$ 是接收方。

(1) 计算机 A 和 B下载、安装 IDEA 程序。

(2) 计算机 A 和 B 下载、安装 PGP 程序。

(3) 计算机 B 通过 PGP 程序产生公钥 $\left(K_{2}\right)$ 和私钥 ( $\left.K_{3}\right)$, 保留私钥, 发布公钥。

(4) 计算机 A 通过 DES/IDEA 程序产生对称密钥 ( $\left.K_{1}\right)$ 。

(5) A 的计算机利用 DES/IDEA 对称密钥加密算法加密明文消息 (PT),产生密文消息 (CT)。这个操作使用的密钥 $\left(K_{1}\right)$ 称为一次性对称密钥, 用完即放弃。

(6) A 要取第 1 步的一次性对称密钥 $\left(K_{1}\right)$, 用 $B$ 的公钥 $\left(K_{2}\right)$ 加密 $K_{1}$ 。这个过程称为对称密钥的密钥包装 (key wrapping)。

(7) 现在, A 把密文 CT 和加密的对称密钥一起放在数字信封 (digital envelope)中。

(8) 这时 $A$ 将数字信封 (包含密文 ( $T$ ) 和用 $B$ 的公钥包装的对称密钥 ( $K_{1}$ ) 用基础传输机制 (网络) 发送给 B。这里假设数字信封包含上述两个项目。

(9) B 接收并打开数字信封。B 打开信封后, 收到密文 CT 和用 B 的公钥包装的对称密钥 $\left(K_{1}\right)$ 。

(10)B 可以用 A 所用的非对称密钥算法和自己的私钥 ( $K_{3}$ ) 解密 (即打开) 逻辑箱, 其中包含 $B$ 的公钥包装的对称密钥 ( $\left.K_{1}\right)$, 这个过程的输出是一次性对称密钥 $K_{1}$ 。

(11) 最后, B 用 $A$ 所用的对称密钥算法和对称密钥 $K_{1}$ 解密密文 (CT), 这个过程得到明文 PT。

## 习题参考答案

4.1 简单的说, DES 利用加密的两个基本属性。替换(混淆)与变换(扩散), DES 共 16 步,每一步称为 1 轮, 每一轮进行替换与变换步骤, 具体为:

(1) 将 64 位明文块送入初始置换 (初始置换只发生一次, 是在第一轮之前);

(2)对明文进行初始置换;

(3)初始置换产生转换块的两半, 假设为左明文和右明文;

(4)每个左明文与右明文经过 16 轮加密过程, 各有自己的密钥;

(5)最后, 将左明文与右明文重接起来, 对组成的块进行最终置换;

(6)结果得到 64 位密文。

4.2 非对称密钥加密的工作原理如下:

(1) A 要向 B 发送消息, A 和 B 都要产生一对用于加密和解密的公钥和私钥。

(2) $\mathrm{A}$ 的私钥保密, $\mathrm{A}$ 的公钥告诉 $\mathrm{B} ; \mathrm{B}$ 的私钥保密, B 的公钥告诉 $\mathrm{A}$ 。

(3) $A$ 要给 $B$ 发消息时, $A$ 用 $B$ 的公钥加密消息,因为 $A$ 知道 B 的公钥。

(4) $\mathrm{A}$ 将这个消息发给 $\mathrm{B}$ (已经用 $\mathrm{B}$ 的公钥加密消息)。

(5) B 收到这个消息后, B 用自己的私钥解密 $\mathrm{A}$ 的消息。其他所有收到这个报文的人都无法解密, 因为只有 $\mathrm{B}$ 才有 $\mathrm{B}$ 的私有密钥。

4.3 解方程 $\mathrm{d} \cdot \mathrm{e}=1 \bmod 2436$

$2436=13 * 187+5,13=2 * 5+3$

$5=3+2,3=2+1$

所以 $1=3-2,2=5-3,3=13-2 * 5$

$5=2436-13 * 187$

所以, $1=3-2=3-(5-3)=2 * 3-5$

$=2 *(13-2 * 5)-5=2 * 13-5 * 5$

$=2 * 13-5 *(2436-13 * 187)$

$=937 * 13-5 * 2346$

即 $937 * 13 \equiv 1 \bmod 2436$

取 $\mathrm{e}=13$ 时 $\mathrm{d}=937$

4.4 答案: $\mathrm{C} 1=24, \mathrm{M} 2=12$

$\mathrm{C} 1=311 \bmod 51=24$

$4.5(\mathrm{p}-1)(\mathrm{q}-1)=46 * 70=3220$

$\mathrm{d}=\mathrm{e}-1 \bmod 3220=79-1 \bmod 3220=1019$

将明文 3 位一组 (分组), $m=688$

加密: $\mathrm{c}=\operatorname{me} \bmod \mathrm{n}=68879 \bmod 3337=1570$

$\mathrm{C}=1570$

解密: $\mathrm{m}=\mathrm{cd} \bmod \mathrm{n}=15701019 \bmod 3337=688$

4.6 (1) DES 的特点:

可靠性较高 (16 轮变化, 增大了混乱性和扩散性, 输出不残存统计信息);

加密/解密速度快;

算法容易实现 (可由软件和硬件实现, 硬件实现速度快), 通用性强;

算法具有对称性, 密钥位数少, 存在弱密钥和半弱密钥, 便于穷尽攻击;密钥管理复杂。

(2) RSA 算法的特点:

密钥管理简单 (网上每个用户仅保密一个密钥, 且不需密钴配送);

便于数字签名;

可靠性较高 (取决于分解大素数的难易程度);

算法复杂, 加密/解密速度慢, 难于实现。

## 第

## 密钥 管理



教学要求

本章介绍密钥管理方法, 包括密钥的管理内容、分配技术, 重点介绍与当前网络应用的发展密切相关的公开密钥管理体制, 使学生能掌握密钥的管理方法和管理体制。通过本章的学习,理解密钥的管理内容,密钥的分配技术,着重掌握公开密钥的全局管理体制。



在现代密码学研究中, 加解密算法一般都是公开的。当密码算法确定后, 密码系统的保密程度就完全取决于密钥的保密程度。因此, 密钥管理是数据加解密技术中的重要一环, 其在整个保密系统中占有重要地位。若密钥得不到合理的保护和管理, 无论算法设计得多么精巧和复杂, 保密系统也是脆弱的。密钥管理的目的就是确保密钥的安全性,即密钥的真实性和有效性,进而来保证数据保密系统的安全性。

一个好的密钥管理系统应该做到:

(1)密钥难以被窃取;

(2) 在一定条件下密钥被窃取也没有用,密钥有使用范围和时间限制;

(3)密钥的分配和更换过程对用户透明,用户不一定要亲自管理密钥。

本章将就密钥管理的内容、密钥的分配技术、公开密钥的全局管理机制、基于“授权”的证书体系 SPKI、组播通信的密钥管理及密钥托管系统进行阐述, 使读者对密钥管理有一个全面的认识。



密钥的管理是整个加密系统中最薄弱的环节, 密钥的泄漏将直接导致明文内容的泄漏。例如曾经有一种计算机使用了 DES 算法来实现一个文件加密工具, 它将密钥与密文保存在一起, 用户可以选择用密文或明文形式保存文件, 而且加密/解密过程是透明的, 使用很方
便。但是, 对于了解密文格式的攻击者而言, 他可以很容易地发现密文的密钥, 从而发现明文。显然从密钥管理的途径窃取机密比用破译的方法花费的代价要小得多, 所以对密钥的管理和保护格外重要。

密钥管理包括密钥生成、密钥储存和保护、密钥更新、密钥分发、密钥验证、密钥使用和密钥销毁等。所有管理过程都是为了正确地解决密钥从生成到使用全过程的安全性和实用性, 另外还涉及密钥的行政管理制度和管理人员的素质。密钥管理最主要的过程是密钥生成、保护和分发。

## 5.1 .1 密钥的组织结构

从信息安全的角度看,密钥的生存期越短, 破译者的可乘之机就越小。所以,理论上一次一密钥最安全。在实际应用中, 尤其是在网络环境下, 多采用层次化的密钥管理结构。用于数据加密的工作密钥平时不存于加密设备中, 需要时动态生成, 并由其上层的密钥加密密钥进行加密保护; 密钥加密密钥可根据需要由其上一级的加密密钥进行保护。最高层的密钥被称为主密钥, 它是整个密钥管理体系的核心。在多层密钥管理系统中, 通常下一层的密钥由上一层密钥按照某种密钥算法来生成, 因此, 掌握了主密钥, 就有可能找出下层的各个密钥。

工作密钥通常被称为会话密钥,建立会话密钥的目的在于:

(1)重复使用密钥容易导致泄漏,因此应经常更换;

(2)若使用相同的密钥,攻击者可将以前截获的信息插人当前的会话中而不被发现;

(3) 密钥一旦被破译,则使用这一密钥加密的信息都会失密,而使用会话密钥的会话信息也会失密;

(4)如果对方不可靠,则更换会话密钥可防止对方以后窃取信息。

多层密钥管理体制大大增强了密码系统的安全性。由于用得最多的工作密钥经常更换,而高层密钥则用得较少,使得破译者可用的信息变得很少,增加了攻击的难度。

另外,多层密钥体制为自动化管理带来了方便, 因为下层密钥可由计算机系统自动产生和维护, 并通过网络自动分配和更换, 减少了接触密钥的人数, 也减轻了用户的负担。例如,在古典加密体制中有这样一种密钥管理方法：

(1) 指定一个公开出版并可广泛获得的出版物作为密码本, 这时这个出版物的名称成为主密钥;

(2) 将这个出版物的某个页号 P、行号 L 及字数 W 作为第二级密钥;

(3) 将 P、L、W 指定的内容作为具体的密钥,即第三级密钥。

这样在使用时, 主密钥是双方预知的, 不需交换; 通信时, 只要通知 P、L、W 就可得知加密的密钥, 而破译者由于不知道主密钥, 所以即使截获了密文和 $P 、 L 、 W$, 也无法破译。如果指定的是一个连续出版物, 则主密钥定期更换, 它的期号或卷号成为新的一级密钥。这种超数学的密码结构使得密文、明文和密钥之间不存在任何确定的函数关系. 破译者只能使用穷举法。当然破译者可通过分析加密者的生活习惯来缩小搜索范围。

密钥的连通是指在用户之间共享密钥的范围;而密钥的分割是指对这个范围的限制空间分割密钥,可区分不同的用户群,例如:

(1)不同密级的数据之间的密钥分割;

(2)不同业务部门、业务系统之间的密钥分割;

(3)上下级机关之间的密钥分割;

(4)应用系统和管理系统之间的密钥分割等等。

按时间分割密钥可实现让各个用户在不同的时期使用不同的密钥,使用户的使用权具有时间限制。分割的实现有两种方式:

(1)静态分割: 在给用户的加密设备注人密钥时就给定了用户的密钥连通范围,即用户只能使用注人的密钥;

(2)动态分割: 密钥分配中心定期向规定范围内的用户加密传送一个用于控制分割范围的通播密钥 (向指定用户广播的密钥) ,即收到什么, 使用什么。

## 5.1 .2 密钥生成

密钥的生成与所使用的生成算法有关。如果生成的密钥强度不一致,则称该算法构成的是非线性密钥空间; 否则称为线性密钥空间。另外密钥的表示方式对密钥空间的大小也有影响。

密码算法如果采用一个弱的密钥生成方法, 那么整个加密体制就是弱的。因为弱的密钥生成算法容易被破译, 密码分析者在破译了密钥后不用再去试图破译算法就可以得到他要得到的数据。所以,密钥的生成是密钥管理中的基本问题。

好的密钥是那些由自动处理设备生成的随机字符串。假如密钥有 128 位长, 每一个可能的 128 位密钥必须具有相等的可能性。因此, 密钥的生成首先要保证所产生的密钥具有良好的随机性, 避免出现简单、明显的密钥或一串容易记忆的字符或数字。现代网络的信息量越来越大,需要的密钥量也越来越大,密钥的产生需要能够自动、大量地进行。

密钥的产生主要利用噪声源技术, 该技术用来产生二进制的随机序列或与之对应的随机数。其主要理论基础是混沌理论。使用随机序列发生器可以自动地产生大量的随机密钥。

### 5.1.3 密钥储存和保护

现代密码系统需要众多的密钥, 在密钥生成后, 需要进行储存才能便于使用, 而且只有具有良好保护的储存才有实际的意义。

密钥大多数时间处于静态, 因此对密钥的保存是密钥管理的重要内容。密钥可以作为一个整体进行保存, 也可化整为零地进行保存, 这些方法在安全性和开销方面互不相同。

整体保存的方法有人工记忆、外部记忆装置、密钥恢复、系统内部保存。密钥整体保存的最简单方法是将其记忆在脑子中, 这种方法也最安全, 但使用不方便, 必须有人工干预。另一种简单的密钥整体保存方法是使用一个容易记忆的密钥 (如口令) 来加密保存。这种方法虽然使用上不方便, 但可以提高实际使用密钥的安全强度, 因为这种难以记忆的密钥通常也难以猜测。一种更方便的方法是使用智能卡一类的记忆装置, 它模仿了钥匙的物理形式,比较直观, 不需要记忆和手工输人。另外还可将智能卡分成两部分, 一部分在用户手中, 另一部分装在指定的机器里,这样就限制只能在指定的设备上使用这个智能卡。

密钥分散保存是为了尽量降低由于某个保管人或保管装置问题而导致密钥泄漏的危险。例如, 主密钥是很重要的, 系统中的数据将依赖于主密钥的可靠性。如果主密钥泄漏,
则数据会受到攻击; 若主密钥损坏, 则加密的数据将不可访问。如果拥有主密钥的人过少,则不利于主密钥的备份; 若掌握主密钥的人太多,则可靠性下降; 所以有必要寻找适当的密钥分散保存的方法。

Shamir 提出了一种密钥分散保存方案, 其基本思想是: 把主密钥分为 $n$ 个子密钥 $K_{1}$ 、 $\mathrm{K}_{2} 、 \cdots 、 \mathrm{~K}_{\mathrm{n}}$, 并把子密钥分发给 $\mathrm{n}$ 个有合法权力的人,并做到:

(1) 用 $\mathrm{n}$ 个子密钥中的任意 $\mathrm{t}$ 个计算主密钥 $\mathrm{x}$ 是容易的;

(2) 用 $\mathrm{n}$ 个子密钥中的任意少于 $\mathrm{t}$ 个确定主密钥是理论上不可解的问题, 因为缺少信息。分散保存的目的是尽量降低由于某个保管人或保管装置的问题而导致密钥的泄漏。

在密钥的保护中,通常采用层次化的保护方式。密钥的分层保护也叫主密钥保护体制,它是以对称密钥为基础的管理体制。该体制可把密钥分为几层, 高一层密钥保护低一层密钥。

一般把密钥分为主密钥、辅助主密钥和会话密钥三个层次。每个主密钥对多个辅助主密钥进行加密保护, 每个辅助主密钥对多个会话密钥进行加密保护。最后, 再用会话密钥对传输的具体信息进行加密保护。

主密钥保护了工作密钥,工作密钥保护敏感信息。

层次化的密钥管理方式中, 用于数据加密的工作密钥需要动态产生; 工作密钥由上层的加密密钥进行保护, 最上层的密钥即主密钥, 是整个密钥管理系统的核心; 多层密钥体制大大加强了密码系统的可靠性, 因为用得最多的工作密钥常常更换, 而高层密钥用的较少, 使得破译的难度增大。

可以使用公钥密码体制来保护会话密钥,方法如下:

在用户 A 与 B 的通信系统中,可采用如下步骤分发和保护会话密钥:

(1)用户 $\mathrm{A}$ 产生自己的公钥 $\mathrm{K}_{\mathrm{c}}$ 和私钥 $\mathrm{K}_{\mathrm{d}}$;

(2)用户 $\mathrm{A}$ 将 $\mathrm{K}_{\mathrm{e}}$ 传输给用户 $\mathrm{B}$;

(3)用户 $\mathrm{B}$ 用 $\mathrm{A}$ 的公钥 $\mathrm{K}_{\mathrm{e}}$ 加密自己产生的一个会话密钥 $\mathrm{K}_{s}$,并传输给 $\mathrm{A}$;

(4)用户 $A$ 用自己的私钥 $K_{d}$ 解密后得到 $K_{s}$;

(5)用户 $\mathrm{A}$ 用 $\mathrm{K}$ s 加密要发给 $\mathrm{B}$ 的数据; 通信结束后, $\mathrm{K}$ s 被清除。

## 5.1 .4 密钥更新

为安全起见,密钥需要定期更换。更换内容包括用户登记更新、密钥更新。

## 5.1 .5 密钥分发

密钥的分发 (分配或传递) 是指从密钥产生到使用者获得的过程。由于任何密钥都有使用期限, 因此密钥的定期 (或不定期) 更换是密钥管理的一个基本任务。为了尽可能地减少人的参与,密切的分配需要尽可能地自动进行。

## 5.1 .6 密钥验证

密钥在传输过程中如果出错, 会影响解密工作的正确进行。由于明文的使用是由系统自动进行的, 所以由密钥引起的错误不一定能够被发现, 进而引起错误的结果或后续处理。因此, 在传递密钥时通常要附带一个用密钥加密的密文, 其中的明文内容是接收者预知的,
接收者能够通过对这个密文进行解密来验证密钥的正确性。通常, 密钥的验证往往与接收者的身份认证联系在一起,因此可以用用户的某个标识作为明文内容。

## 5.1 . 密钥使用

密钥的使用要注意环境的影响。例如在多用户多任务的操作系统环境中进行软件加密是有风险的, 由于进程调度的原因操作系统可能会把加密的中间结果储存在内存中, 因此有可能被人截获。从这个意义上说,使用硬件加密要安全得多。

## 5.1 .8 密钥备份

密钥的保存机制重点在于安全问题,但也有可靠性问题,因此密钥的备份机制也是必要的。

密钥的备份可采用与密钥保存类似的分散方法, 以避免知道密钥的人太多。密钥的备份也可以采用职责分离方式, 使保管备份密钥的人不能接触数据。另外密钥的备份可以和使用结合起来考虑, 例如使用智能卡方式: 持卡人可以使用密钥来进行加密/解密, 但不知密钥的具体内容,同时对卡的使用可以进行审计。

## 5.1 .9 密钥销毁

密钥的销毁需要管理和仲裁机制, 否则密钥会被无意或有意地丢失, 从而造成对使用行为的否认。

## 5.9 в

密钥的传递分集中传送和分散传送两类。集中传送是指将密钥整体传送,这时需要使用主密钥来保护会话密钥的传递, 并通过安全渠道传递主密钥。分散传送是指将密钥分解成多个部分, 用秘密分享的方法传递, 只要有部分到达就可以恢复, 这种方法适用于在不安全的信道中传输。

密钥的分配技术解决的是网络环境中需要进行安全通信的端实体之间建立共享的对称密钥问题, 最简单的解决办法是预先约定一个对称密钥序列并通过安全渠道送达对方, 以后按约定使用并更换密钥。这种方式对于具备安全渠道(它本身就可能直接用来传输数据内容) 且密钥使用量不大的通信双方是合适的。如果密钥用量较大, 更换频繁, 则密钥的传递就会成为严重负担, 而且多数用户之间可能并没有安全的传输渠道存在, 因此需要研究在不安全的通信信道中传递对称密钥的方法。

## 5.2 .1 密詮分配中心方式

Kerberos 是一种使用对称密钥加密算法实现通过可信任的第三方密钥分配中心 KDC (Key Distribute Center) 的身份验证系统。Kerberos 的主要功能之一是解决保密密钥的管理与分发问题。

Kerberos 中有三个通信参与方: 需要验证身份的通信双方和一个双方都信任的第三
方, 即密钥分配中心 (KDC)。KDC 可以看作是一个秘密密钥源, 与 $\mathrm{DES}$ 一起使用; 也可以是一个公开密钥源。

Kerberos 就建立在这个安全的、可信赖的密钥分配中心的概念上。建有 KDC 的系统用户只需保管与 KDC 之间使用的密钥加密密钥—— KDC 通信的密钥即可。

这是当前一种主流方式。每个节点或用户只需保管与 KDC 之间使用的密钥加密密钥, 而 KDC 为每个用户保管一个互不相同的密钥加密密钥。当两个用户需要通信时, 需向 KDC 申请, KDC 将工作密钥( 也称会话密钥) 用这两个用户的密钥加密密钥分别进行加密后送给这两个用户。在这种方式下, 用户不用保存大量的工作密钥, 而且可以实现一报一密,但缺点是通信量大,而且需要有较好的鉴别功能, 以识别 KDC 和用户。

KDC 方式还可以变形为电话号码本方式,适用于非对称密码体制。通过建立用户的公开密码表, 在密钥的连通范围内进行散发, 也可以采用目录方式进行动态查询, 用户在进行保密通信前, 首先产生一个工作密钥并使用对方的公开密钥加密传输, 对方获悉这个工作密钥后,使用对称密码体制与其进行保密通信。

此外还有 Diffie-Hellman 方法和智能卡方式,基本的思想是利用数学的方法使得别人无法获得密钥。

KDC 的工作过程简述如下:

(1) 假设用户 $\mathrm{A}$ 要与 B 通信, $\mathrm{A}$ 先向 $\mathrm{KDC}$ 提出申请与 $\mathrm{B}$ 的联系和通信会话密钥;

(2) $K D C$ 为用户 $A$ 和 $B$ 选择一个会话密钥 $K s$, 分别用 $A$ 和 $B$ 知道的密钥进行加密,然后分别传送给 $\mathrm{A}$ 和 $\mathrm{B}$;

(3) 用户 $A$ 和 $B$ 得到 KDC 加密过的信息后, 分别解密之,得到会话密钥 $K s$;

(4) 至此,用户 A 与 B 即可利用 $K_{s}$ 进行保密通信了。通信结束后, $K_{s}$ 随即被销毁。

目前, 各主要操作系统都支持 Kerberos 验证系统, 比如 Windows NT。Kerberos 实际上已成为工业界的事实标准。Kerberos 使用对称密钥算法来实现通过 KDC 的验证服务,它提供了网络通信方相互验证身份的手段,且并不依赖于主机操作系统和地址。

### 5.2.2 Diffie-Hellman 方法

Diffie-Hellman 密钥交换是 W. Diffie 和 M. Hellman 于 1976 年提出的第一个公钥密码算法, 已在很多商业产品中得以应用。算法的惟一目的是使得两个用户能够安全地交换密钥, 得到一个共享的会话密钥, 算法本身不能用于加密/解密。算法的安全性基于求离散对数的困难性。

设 $\mathrm{p}$ 是一个质数, $\mathrm{a}$ 是 $\mathrm{p}$ 的一个本原元, 要求 $\mathrm{a}$ 和 $\mathrm{p}$ 是公开的, 网络中的每个用户选一个小于 $\mathrm{p}$ 的整数 $\mathrm{K}$ 作为秘密密钥。设 $\mathrm{A}$ 和 $\mathrm{B}$ 是两个用户, 他们的秘密密钥分别是 $X_{A}$ 和 $X_{B}$, 则他们可以基于数学方法用下面的过程建立会话密钥。

(1) 双方各自计算 $Y_{A}=a^{X_{A}} \bmod p$;

$$
Y_{B}=a^{X_{B}} \bmod p
$$

(2) 交换 $Y_{A}$ 和 $Y_{B}$;

(3) 求出会话密钥 $K=Y_{B}{ }^{X_{A}} \bmod p=Y_{A}{ }^{X_{B}} \bmod p=a^{X_{A} X_{B}} \bmod p$ 。

因 $X_{A}, X_{B}$ 是保密的,敌手只能得到 $p, a, Y_{A}, Y_{B}$, 要想得到 $K$, 则必须得到 $X_{A}, X_{B}$ 中的一个,这意味着需要求离散对数。因此敌手求 $\mathrm{K}$ 是不可行的, 如图 5-1。



图 5-1 Diffie-Hellman 密钥交换

例如: $p=97, a=5, A$ 和 $B$ 分别秘密选 $X_{A}=36, X_{B}=58$, 并分别计算 $Y_{A}=536 \bmod 97=$


$75, \mathrm{~K}=\mathrm{Y}_{\mathrm{A}}{ }^{\mathrm{X}_{\mathrm{B}}} \bmod 97=5058 \bmod 97=75$ 。

这种方法不能防止从信道窃听, 因此需要某种加密机制的保护, 并且需要使用密钥协商机制来防止中间人的攻击(攻击者在通信双方之间进行双向冒充)。

后续研究者提出了一些改进的方法来避免中间人的攻击。

## 5 .2.3 加密的密詮交换

加密的密钥交换方法用共享的对称密钥 $\mathrm{p}$ 如口令来保护随机产生的公开密钥, 进而增强对会话密钥的保护。具体操作如下：

(1)用户 A 随机产生一个公开/秘密密钥对, 使用对称密钥算法将公开密钥 $K^{\prime}$ 加密, 然后将 $\left(A, E_{p}\left(K^{\prime}\right)\right.$ )送给用户 $\mathrm{B}$;

(2) B 收到后,再生成一个随机的会话密钥 $\mathrm{K}$, 然后向 $\mathrm{A}$ 发送 $E_{p}\left(E_{K^{\prime}}(K)\right)$;

(3) $\mathrm{A}$ 收到后, 解密出 $\mathrm{K}$, 然后生成一个随机串 $R_{A}$, 并向 $\mathrm{B}$ 发送 $E_{K}\left(R_{A}\right)$;

(4) B 收到后,生成一个 $R_{B}$, 向 $\mathrm{A}$ 发送 $E_{K}\left(R_{A}, R_{B}\right)$;

(5) $\mathrm{A}$ 收到后, 向 $\mathrm{B}$ 发送 $E_{K}\left(R_{B}\right)$;

(6) B 收到后, 若解密且确认正确,则双方密钥交换与鉴别成功,如图 5-2。



图 5-2 加密的密钥交换

这种方法的优点是即使口令被攻击者猜出, 他只能获得 $K^{\prime}$, 而这个公开密钥只能用于加密, 不能用于解密, 因此他仍然无法获得实际使用的会话密钥 $K$ 的内容。这种方法的缺点是交互次数较多, 比较繁琐。

## 5.2 .4 增强的密钥协商方法

增强的密钥协商方法可以用来防止弱口令和中间人攻击。该方法使用了带两个变量的哈希函数,其中一个变量可能有许多冲突,而另一个变量没有冲突, 如图 5-3 所示。

设 $H(K, X)$ 是一般的单向函数, 定义 $H^{\prime}(X, Y)=H\left(H(X, Y) \bmod 2^{m}, X\right), m>0$ 。设用户 $\mathrm{A}$ 和 $\mathrm{B}$ 共享一个口令 $\mathrm{P}$, 并用某种方法交换了密钥 $\mathrm{K}$, 用 $\mathrm{P}$ 来检查他们交换的 $\mathrm{K}$ 是否相同。

(1) A 计算 $H^{\prime}(P, K)$ 且发送给 B;

(2) B 作同样的计算并比较结果, 若相同则计算 $H^{\prime}(H(P, K), P)$ 并发送给 A;

(3) A 作同样的计算并比较结果。

在这种方法下, 攻击者若要进行中间人攻击, 必须首先用某种方式获得 P, 否则无法计算 $\mathrm{H}$ 值。但是因为第一个变量计算有长度限制, 因此冲突比较多, 这使得攻击者很难从散列值判定自己是否获得了正确的 P。



图 5-3 增强的密钥协商方法



公钥体制涉及到一对密钥,即公开密钥(公钥) 和秘密密钥(私钥),如何实现密钥管理是 PKI 服务系统的关键问题。其中, 私钥只能由证书持有者秘密掌握, 无需在网上传输。而公钥是公开的,需要在网上传送,故公钥体制的密钥管理主要是公钥的管理问题。

## 5.3 .1 公钥的用途

在公钥体制的实际应用中,公钥主要有两大类用途：

(1) 用于验证数字签名

信息接收者使用发送者的公钥对接收的信息的数字签名进行验证。

(2)用于加密信息

信息发送者使用接收者的公钥来加密用于对称加密信息的常规密钥, 从而进行加密密钥的传递。

## 5.3 .2 签名密钥和加密密钥

由于公钥所具有的两种不同用途, 在实际应用中, 需要分别配置用于数字签名/验证的
密钥对和用于数据加密/解密的密钥对, 这里分别称为签名密钥对和加密密钥对。这两对密钥由于用途不同,因此,对于密钥的管理也就有着不同的要求。

(1)签名密钥对的管理

签名密钥对由签名私钥和验证公钥组成。

签名私钥是发送方身份的证明,具有日常生活中公章、私章的效力。为保证其惟一性,签名私钥绝对不能够做备份和存档, 丢失后只需重新生成新的密钥对。验证公钥需要存档,用于验证旧的数字签名。

用做数字签名的这一对密钥一般可以有较长的生命期。

(2)加密密钥对的管理

加密密钥对由加密公钥和解密私钥组成。

为防止密钥丢失时数据无法恢复, 解密私钥应该进行备份, 同时还可能需要进行存档,以便能在任何时候解密历史密文数据。加密公钥则无需备份和存档, 加密公钥丢失时, 只需重新生成密钥对即可。

这种密钥应该频繁更换,故加密密钥对的生命周期较短。

不难看出, 这两对密钥的密钥管理要求存在互相冲突的地方, 因此, 必须针对不同的用途使用不同的密钥对。尽管有的公钥体制算法如 RSA, 既可以用于加密, 又可以用于签名,但由于这两对密钥在管理上截然不同的要求,在使用中仍然必须为用户配置两对密钥: 其一用于数字签名, 另一用于加密。而采用一对密钥, 既用于加密, 又用于签名, 这种做法是不安全的。

## 5.3 .3 公钥的产生

用户的公钥可有两种生成方式:

(1)用户生成

在这种方式中,用户自己生成密钥对, 然后将公钥以安全的方式传送给 CA。

(2) $\mathrm{CA}$ 生成

这种方式是 CA 替用户生成密钥对, 然后将其以安全的方式传送给用户。该过程必须确保密钥对的机密性、完整性和可验证性。该方式下由于用户的私钥为 CA 所产生, 故对 CA 的可信性有更高的要求。如果是签名密钥, CA 必须在事后销毁用户的私钥。

### 5.3.4 公钥的获取

用户在网上可通过两种方式获取通信对方的公钥, 以用来传送加密数据, 实现安全通信。

（1）由通信对方将自己的公钥随同发送的正文信息一起传送给用户。

(2) 所有的证书集中存放于一个证书库中,用户在网上可从该地点取得通信对方的证书。

### 5.3.5 密钥备份和恢复

在 PKI 环境中, 有时用户会丢失他们的私钥。这通常是由于以下原因: (1)遗失或忘记口令。虽然用户的加密私钥在物理上是存在的,但实际上不可使用。(2)介质的破坏。如硬
盘和 IC 卡损坏。如果用户由于某种原因丢失了解密私钥, 则被加密的数据因无法解开, 而造成数据的丢失。例如, 在某项业务中的重要文件被对称密钥加密, 而对称密钥又被某个用户的公钥加密起来, 假如该用户的解密私钥丢失了,这些文件将无法恢复。

为了避免这种情况的发生, PKI 提供了密钥备份与解密密钥的恢复机制, 这就是 PKI 的密钥备份与恢复系统。但值得强调的是, 密钥备份与恢复只能针对解密密钥, 而签名密钥不能做备份。

密钥的备份与恢复形成了 PKI 定义的重要部分。

公开密钥密码体制主要是针对开放型的大型互联网络应用环境而设计的,在这种环境中,需要有一个协调管理机制,来保证公开密钥的可靠性。

公开密钥的管理通常基于公证机制,也就是需要一个通信的双方都信任的第三方来证明通信双方的公开密钥的可靠性, 这需要第三方分别对通信双方的公开密钥进行数字签名,生成一个证明这个公开密钥可靠性的证书。在大型网络中, 这样的公证中心可以有多个, 另外, 如果这些公证中心存在信任关系,那么用户可以通过一个签名链来验证一个公证中心签发的证书。

公开密钥管理的另一个重要方面是如何撤消过去签发但现在已经失效的密钥证书。

### 5.3.6 基于 X.509 证书的 PKI

这是一种行业标准或者行业解决方案, 在 X. 509 标准中, 默认的加密体制是公钥密码体制。为了进行身份认证, X. 509 标准及公共密钥加密系统提供了数字签名的方案。用户可生成一段信息及其摘要,然后用秘密密钥对摘要加密以形成签名,接收者用发送者的公开密钥对签名解密, 并将之与收到的信息摘要进行比较, 来确定其真实性。

PKI 是提供公钥加密和数字签名服务的系统或平台, 其目的是管理密钥和证书。它能够为所有网络应用透明地提供加密和数字签名等密码服务所必需的密钥和证书管理。一个机构或组织通过采用 PKI 系统或平台管理用户密钥和证书能够建立一个安全的网络环境。

CA 机构, 又称为证书授权 (Certificate Authority) 中心, 是电子商务交易中受信任和具有权威性的第三方, 承担公钥体系中公钥的合法性检验的责任。CA 中心要为每个使用公开密钥的客户发放数字证书, 该证书的作用是证明证书中列出的客户拥有证书中列出的公开密钥。CA 机构的数字签名使得恶意的第三方不能随意伪造和篡改证书。CA 中心负责生成、分配并管理所有参与网上信息交换各方所需的数字证书,并提供一系列密钥生命周期内的管理服务,是安全电子信息交换的核心。

## 1. 认证中心的功能

认证中心在密码管理方面的作用如下：

(1) 自身密钥的产生、存储、备份/恢复、归档和销毁

从根 CA 开始到直接给客户发放证书的各层次 CA, 都有其自身的密钥对。CA 中心的密钥对一般由硬件加密服务器在机器内直接产生, 并存储于加密硬件内, 或以一定的加密形式存放于密钥数据库内。加密备份于 IC 卡或其他存储介质中, 并以高等级的物理安全措施保护起来。密钥的销毁要以安全的密钥冲写标准, 彻底清除原有的密钥痕迹。需要强调的是, 根 CA 密钥的安全性至关重要, 它的泄露意味着整个公钥信任体系的崩溃, 所以 CA 的密钥保护必须按照最高安全级的保护方式来进行设置和管理。

(2) 为认证中心与各地注册审核发放机构的安全加密通信提供安全密钥管理服务

在客户证书的生成与发放过程中,除了有 CA 中心外,还有注册机构、审核机构和发放机构 (对于有外部介质的证书) 的存在。行业使用范围内的证书, 其证书的审批控制, 可由独立于 CA 中心的行业审核机构来完成。CA 中心在与各机构进行安全通信时, 可采用多种手段。对于使用证书机制的安全通信, 各机构的密钥产生、发放与管理维护, 都可由 CA 中心来完成。

(3) 确定客户密钥生存周期, 实施密钥吊销和更新管理

每一张客户公钥证书都有有效期, 密钥对生命周期的长短由签发证书的 CA 中心来确定。各 CA 系统的证书有效期限有所不同,一般大约为 $2 \sim 3$ 年。

密钥更新不外为以下两种情况: 密钥对到期、密钥泄露后需要启用新的密钥对证书吊销。密钥对到期时, 客户一般事先非常清楚, 可以采用重新申请的方式进行更新。采用证书的公钥吊销, 是通过吊销公钥证书来实现的。公钥证书的吊销来自于两个方向, 一个是上级的主动吊销, 另一个是下级主动申请证书的吊销。当上级 CA 对下级 CA 不能信赖时, 如上级 CA 发现下级 CA 的私钥有泄露的可能, 它可以主动停止下级 CA 公钥证书的合法使用。当客户发现自己的私钥泄露时, 也可主动申请公钥证书的吊销,防止其他客户继续使用该公钥来加密重要信息, 而使非法客户有盗取机密的可能。一般而言, 在电子商务实际应用中,可能会较少出现私钥泄露的情况, 多数情况是由于某个客户由于组织变动而调离该单位, 需要提前吊销代表企业身份的该客户的证书。

(4) 提供密钥对生成和分发服务

CA 中心可为客户提供密钥对的生成服务,它采用集中或分布式的方式进行。在集中的情形下, CA 中心可使用硬件加密服务器, 为多个客户申请成批的生成密钥对, 然后采用安全的信道分发给客户。也可由多个注册机构分布生成客户密钥对并分发给客户。

(5) 提供密钥托管和密钥恢复服务

CA 中心可根据客户的要求提供密钥托管服务,备份和管理客户的加密密钥对。当客户需要时可以从密钥库中提出客户的加密密钥对, 为客户恢复其加密密钥对, 以解开先前加密的信息。这种情形下, CA 中心的密钥管理器, 采用对称加密方式对各个客户私钥进行加密, 用于密钥加密的密钥在加密后即销毁, 保证了私钥存储的安全性。密钥恢复时, 采用相应的密钥恢复模块进行解密, 以保证客户的私钥在恢复时没有任何风险和不安全因素。同时, CA 中心也应有一套备份库,避免密钥数据库的意外毁坏而无法恢复客户私钥。

(6) 其他密钥生成和管理、密码运算功能

CA 中心在自身密钥和客户密钥管理方面的特殊地位和作用, 决定了它具有主密钥、多级密钥加密密钥等多种密钥的生成和管理功能。

对于为客户提供公钥信任、管理和维护整个电子商务密码体系的 CA 中心来讲, 其密钥管理工作是一项十分复杂的任务, 它涉及到 CA 中心自身的各个安全区域和部件、注册审核机构以及客户端的安全和密码管理策略。

## 2 . 密钥/证书的生命周期

密钥/证书的生命周期主要分初始化一颁发一取消三个阶段。

(1) 初始化阶段

初始化阶段是用户实体在使用 PKI 的支持服务之前, 必须经过初始化进人 PKI。初始
化(注册)阶段由以下几部分组成:

实体注册。

密钥对产生。

证书创建和密钥/证书分发。

证书分发。

密钥备份。

(2)颁发阶段

颁发阶段是私钥和公钥证书一旦被产生即可进人颁发阶段。主要包括:

证书检索——远程资料库的证书检索。

证书验证一一确定一个证书的有效性。

密钥恢复一一不能正常解读加密文件时, 从 CA 中恢复。

密钥更新一一当一个合法的密钥对将要过期时, 新的公/私钥对自动产生并颁发。

(3)取消阶段

取消阶段是密钥/证书生命周期管理的结束。它包括如下内容:

证书过期一一 证书的自然过期。

证书撤消——宣布一个合法证书 (及相关私钥) 不再有效。

密钥历史一一维护一个有关密钥资料的历史记录, 以便对以后过期的密钥所加密的数据进行解密。

密钥档案—为了密钥历史恢复、审计和解决争议的目的, 密钥历史档案由 CA 储存。

综上所述, 密钥备份与恢复在整个密钥/证书的生命周期中, 贯穿于每一个阶段, 起着十分重要的作用。

## 3. 密钥备份

用户在申请证书的初始阶段, 如果在注册时声明公/私密钥对是用于数据加密, 则出于对数据机密性的安全需求,在初始化阶段,可信任的第三方机构 $\mathrm{CA}$,即可对该用户的密钥和证书进行备份。

密钥备份功能可以由颁发相应证书的 CA 机构执行。

## 4. 密钥恢复

密钥恢复功能发生在密钥管理生命周期的颁发阶段, 它的功能就是将终端用户因为某种原因而丢失的加密密钥予以恢复。

密钥的恢复和密钥备份一样, 只适用于用户的加密密钥。这种恢复由可信任的密钥恢复中心或 CA 来完成。密钥恢复的手段可以从远程设备恢复, 也可由本地设备恢复。

## 5. 证书撤消

认证机构 CA 签发证书来为用户的身份和公钥进行捆绑,可是因种种原因,还必须存在一种机制来撤消这种捆绑关系, 将现行的证书撤消。

这种撤消的原因通常有: 用户身份姓名的改变、私钥被窃或泄露、用户与其所属企业关系变更等。这样就必须存在一种方法警告其他用户不要再使用这个公钥。在 PKI 中, 这种警告机制,被称作证书撤消。而使用的手段就是前面所提到的证书撤消列表(CRL)。

证书撤消列表的结构是按 X. 509 证书标准定义的,其结构如图 5-4 所示。

(1) 版本号
版本号字段指出 CRL 的版本号, 如果本字段为空, 则表示是版本 1 的 CRL, 如果是 2 ,则表示本字段在版本 1 的 CRL 里没有定义。

| 版本号 |
| :--- |
| 签名 |
| 颁布者 |
| 本次更新 |
| 下次更新 |
| 扩展域 |
| 由授权颁布者签发 |
| $\cdots$ |
| 撤消的证书列表 |
| $\cdots$ |
| CRL 的版本识别符(例如, V2) |
| 用于签 CRL 的算法识别符 |
| CRL 颁布者的惟一名字 |
| 本次 CRL 被颁布的日期/时间 |
| 证书序列号,撤销日期/时间, CRL 实体扩展(可选的) |
| 每项 CRL 扩展 |
| 本次 CRL 过期的日期/时间 |

图 5-4 CRL 的结构

(2)签名

签名字段是计算 CRL 的数字签名所使用的算法的对象标识符。

(3)颁布者

颁布者字段是 CRL 颁布者 (即 CRL 的签名者) 的可识别名 (DN), 本字段必须写出且惟

(4)本次更新

本次更新字段是 CRL 的发布时间。

(5)下次更新

下次更新字段属可选项,表示下一 CRL 的发布时间。此字段的时间表示形式和本次更新字段一样。

(6) 撤消的证书列表

撤消的证书列表是每个证书对应一个惟一的标识符, 它含有已撤消证书的惟一序列号,并不是实际的证书。列表中的每一项都含有证书不再有效的时间,并且作为可选项,它可以包括每一项的扩展。

(7)扩展域
X. 509 标准定义了四个可用于每项的扩展。这就使得在每个撤消里都可以携带额外信息。每项扩展如下:

1) 理由代码一证书撤消的理由。理由代码包括密钥损坏、CA 损坏、关系变动、取代、操作终止、证书控制、从 CRL 的去除, 以及未指明的理由。
2) 证书颁布者一一证书颁布者的名字。

3）控制指示代码一一用于证书的临时冻结。被怀疑的证书可以继续使用或是永久撤消。

4）无效日期一一本证书不再有效的时间。

由以上可以看出, CRL 是一种包含撤消的证书列表的签名数据结构。CRL 的完整性和可靠性由它本身的数字签名来保证。CRL 的签名者一般也就是颁发证书的签名者。

## 6 . 密钥自动更新

正如前面所提到的,证书也存在生存周期。也就是说,一个证书的有效期是有限的。这样规定既有理论上的原因,又有实际操作的因素。

从理论上来说, 主要是针对当前非对称算法和密钥长度的可破译性分析。同时,在实际应用中, 密钥必须有一定的更换频度, 才能得到密钥使用的安全性。因此, 在很多 PKI 环境中,一个已颁发的证书需要有过期的措施, 以便更换新的证书。这个过程被称为“密钥更新或证书更新”。

对 PKI 用户来说, 实践证明用手工操作的方式定期更新自己的证书是一件令人头痛的事情。因为用户常常会忘记自己的证书已过期,他们往往是在实际使用中, 经过认证失败时才发现问题, 这时为时已晚。为此, 用户必须完成密钥更新过程, 否则他们无法继续获取 PKI 的相关服务。

为解决密钥更新的复杂性和由人工干预所产生的麻烦,应由 PKI 本身自动完成密钥或证书的更新, 完全不需要用户的干预。无论用户的证书用于何种目的, 在认证时, 都会在线自动检查有效期,当失效日期到来之前的某时间间隔内,自动启动更新程序,生成一个新证书来代替旧证书,并且,新旧证书的序列号也是不一样的。

在很多环境中,对可操作的 PKI 来说,密钥自动更新是十分重要的,它也是 PKI 定义的一个组成部分。

(1)密钥更新

密钥更新发生在证书的颁发阶段。当证书被颁发时,它就被赋予了一个固定的生存期。当证书“接近”过期,就必须颁发一个新的公/私钥对和相关证书,这被称为密钥更新。

所谓“接近”过期,一般是指在证书到达有效期之前的时间“提前量”,这个提前量，通常规定为是整个密钥生存期的 $20 \%$ 左右,即一旦密钥生存周期被用到 $80 \%$ 时, 密钥更新就应发生。随后,新的密钥资料应该被用到更新后的所有的密码操作中。

实践证明,这是一个合理的转变时间,可以防止证书过期而得不到安全服务。我们强调密钥和证书更新应该在当前证书过期之前发生, 主要是为了避免任何延时和间隔可能使终端实体在处理交易时产生不必要的中断。

实际上,用做签名目的的私钥也可以有一个给定的有效生存期。这个给定的有效期可以小于或等于相关认证证书的过期时间。如果签名私钥是在它的相关联的认证证书之前过期,则为密钥的更新应该是基于签名私钥的过期时间，而不是认证证书的过期时间，以便使终端实体总是持有一个有效的签名密钥。这个过程也必须是自动的, 对终端用户而言, 也应该是透明的。

(2)证书更新与证书恢复

证书更新的概念与证书恢复是不相同的。它们的不同点在于：

1)证书恢复是保持最初的公/私钥对, 而密钥证书更新是在证书中产生了一个新的公
钥/私钥对。

2) 证书之所以能够做恢复, 是考虑到与最初证书的颁发有关的环境没有变化, 这时才使用恢复,并且还认为这个公/私密钥对仍然是可信的。

## 7 . 密钥历史/档案

在经过上述密钥更新概念的论述之后, 我们很容易地会得出以下结论, 即经过一段时间之后，每个用户都会形成多个“旧”证书和至少有一个“当前”的证书。这一系列“旧”证书和相应的私钥就组成了用户密钥和证书的历史档案,简称密钥历史/档案。

记录整个密钥历史是一件十分重要的事情, 比如说甲自己 5 年前加密的数据或其他人用甲的公钥为甲加密的数据, 无法用现在的私钥解密。那么, 甲就需要从他的密钥历史/档案中得到正确的解密密钥来解密数据。

与密钥更新相同, 管理密钥历史/档案也应当由 PKI 自动完成。在一个 PKI 的系统中,让用户自己去查找正确的私钥或用每个密钥去尝试解密数据, 这对用户来说是无法容忍的, PKI 必须保存所有密钥, 以便正确地备份和恢复密钥。同时,提供正确密钥的查找以便解密数据。

(1)密钥历史

因为加密密钥最后要过期, 所以如果没有采取适当措施, 没有将已过期的密钥采取适当办法存储起来, 就存在着加密后的数据可能变得无法恢复的危险。因此,即使密钥资料过期了,可靠地和安全地储存它们是必须的。在 PKI 中称为密钥历史。

对要保存密钥历史的需求, 主要是面向数据加密的服务。具体地说, 就是只有被用作解密的私有密钥资料才被存储, 其目的是, 在将来对加密密钥已加密的数据进行恢复。而对于那些用于数字签名目的的密钥只能够通过密钥档案, 适当地满足这种要求。

(2)密钥档案

密钥档案是指对被 CA 或其他信任机构所支持的密钥资料(包括密钥或证书)的长期储存。

密钥档案与密钥历史是不同的:

1)密钥档案主要用于审计和交易争端时使用。密钥历史一般直接与终端实体相结合,以便在访问被已过期的密钥加密的数据时, 方便地提供对该终端实体过期密钥资料进行访问。

2) 密钥档案一般是由第三方提供的服务, 并且它涉及与许多终端实体有关的密钥资料的储存。一个给定的终端实体的密钥历史, 可以由密钥档案设备存储起来, 以便将来响应来自密钥历史所有者的请求。

另外, 在此必须指出的是, 当试图验证一个已过期的密钥资料所创建的数字签名时, 密钥档案设备是必需的。因为, 在这种情况下, 要求恢复对该数字签名有用的公钥证书。

## 实验题

## 实验 5.1 公钥加密邮件

要求: 下载并安装 Internet 常用加密软件 PGP; 通过 PGP 对 Outlook Express 的邮件进行公钥加密收发。
实验 5.2 导出 PGP 公钥及对邮件签名

要求:在 NT下导出 PGP 公钥及对邮件签名。

## 习习题

5.1 密钥管理的主要内容是什么?

5.2 密钥的分配方法有哪些?

5.3 公钥的管理内容有哪些?

5.4 SPKI 的基本原理是什么?

5.5 组播通信中的密钥管理基本技术有哪些?

5.6 何谓密钥托管? 如何实现密钥托管?

## 实验题参考答案

## 实验 5.1

实验步骤:

一、PGP 的安装

1 .安装环境:

在 Windows XP 操作系统上完成 PGP 软件的安装。

2. 安装版本的选择:

安装文件:PGP Desktop 9.0 Final Candidate Installer-Windows-ZIP

来源:http://www$\cdot$pgp.com

文件大小: $12 \mathrm{MB}$

发布日期: 2005-4-29

3 . 安装过程

(1) 解开压缩包, 运行安装文件, 系统自动进人安装向导;

(2)安装选择“No, I’m a New User”;

(3) 确认安装的路径;

(4) 安装应用组件;

(5)重新启动计算机一次, 请按“Finish”重新开机。

至此, PGP Desktop 已安装在电脑上(工作列上多出一个 PGP 图标)。安装向导会继续 PGP Desktop 注册。

二、产生 PGP 密钥对

(1) 从系统托盘中选 Open PGP Desktop, 菜单中选择 New PGP Key…即在 Key Generation Winzard 提示向导下, 点击 Next, 开始创建密钢对。

(2) 设定姓名与 E-mail。

(3) Pass phrase 与 Confirmation 输人一组至少 8 个英文字母的密码。

实验中输人:I will welcome the day with love in my heart。

完成以上步骤, 系统即提示已经成功产生 PGP 密钥。接下来是设定电子邮件 Outlook 与 Outlook Express, 此步骤直接退出, 在以后的实验中完成。

三、邮件进行加密收发

(1) 打开 Outlook Express, 用于测试的邮件。

(2) 在发送之前, 选中邮件所有内容, 右键单击任务栏中的 PGP encryption 图标。

(3)选取 Current Window $\rightarrow$ Encrypt, 对邮件进行加密。

(4) 在提示输人密码时,输人你自己的私钥的 Pass phrase。

(5) 收到邮件双击打开后, 单击 Decrypt PGP Message 图标, 解密邮件。

实验 5.2

实验步骤:

1.打开 PGPkeys。

2. 右键单击公钥项, 选取 Export。
3. 在 Export Key to File 对话框中, 保持默认文件名并保存到教师机上, 路径为 $\backslash T$ eacher $\backslash$ share 下, 文件名为 student $x$ ( $x$ 为座位号)。

4.打开 Microsoft Outlook Express(开始>程序>Outlook Express)。

5. 配置 Outlook Express 如下: 帐户名- $\mathrm{sx}(\mathrm{x}$ 为座位号), 邮件地址- $\mathrm{sx} @$ linuxonline.com,POP3/SM TP 服务器地址-192.168.0.14(实际中可能会有所不同)。

6 . 发送公钥文件给合作伙伴, 或从路径 $\backslash$ Teacher $\backslash$ share 下获得合作伙伴的公钥文件。

7. 在 PGPkeys 中打开 Keys 菜单, 选择 Import。
8. 在 Select File Containing 对话框中, 定位并选择合作伙伴的公钥文件, 然后单击 Open 按钮。
9. 在 Select key(s)对话框中, 选中要导人的公钥文件, 选择 Import。
10. 右键单击导人的公钥, 选择 Sign。

11.加亮公钥并选中 Allow signature be exported 复选框。

12 . 在要求输人密码时, 输人你自己的私钥。

13. 右键单击合作伙伴的公钥, 选取 Key Properties。
14. 在出现的对话框底部, 将表示信任状态的滑动条由 Untrusted 拖至 Trusted。

如果不做上述一步的话, 当收到对方加密又签名的邮件, 解开后会发现在签名的状态旁会出现 invalid 提示, 意为没有对此密钥完全信任。

## 习题参考答案

5.1 密钥管理包括密钥生成、密钥储存和保护、密钥更新、密钥分发、密钥验证、密钥使用和密钥销毁等。所有管理过程都是为了正确地解决密钥从生成到使用全过程的安全性和实用性, 另外还涉及密钥的行政管理制度和管理人员的素质。密钥管理最主要的过程是密钥生成、保护和分发。

5.2 密钥的分配是指产生并使使用者获得一个密钥的过程; 密钥的传递分集中传送和分散传送两类。集中传送是指将密钥整体传送, 这时需要使用主密钥来保护会话密钥的传递, 并通过安全渠道传递主密钥。分散传送是指将密钥分解成多个部分, 用秘密分享的方法传递, 只要有部分到达就可以恢复, 这种方法适用于在不安全的信道中传输。

5.3 公钥的产生、公钥的获取、密钥备份和恢复等。

5.4 SPKI 证书直接定义了“授权 $\rightarrow$ 密钥” 映射, 其主要目的是给密钥持有者授权。如何解释证书里定义的属性或者授权是由使用证书的应用系统自主决定的。新授权的产生不
要求与任何其他人或组织进行交流, 而是在使用证书的应用系统的全面控制之下。SPKI 证书会携带一些信息, 如果将证书收集在一起可能会给攻击者提供某种线索, 从而妨碍隐私, 因此, SPKI 证书应该携带完成任务所必要的最少信息。另一方面, 为匿名访问提供基本权限的证书也是必要的, 因为在秘密投票或其他相似的应用中有可能使用 SPKI 证书, 所以 SPKI 证书必须能够为盲签名分配属性。

5.5 根据控制结构的不同,可以把组播密钥管理方案分为 3 大类: 集中控制式、分布式和分层分组式。

5.6 密钥托管技术又称为密钥恢复 (Key Recovery), 是一种能够在紧急情况下获取解密信息的技术。它用于保存用户的私钥备份, 既可在必要时帮助国家司法或安全等部门获取原始明文信息,也可在用户丢失、损坏自己的密钥的情况下恢复明文。

进行密钥托管的步骤如下:

(1) 用户选择若干个密钥托管代理, 分给每一个代理一部分私钥和一部分公钥。托管代理根据所得到的密钥分量产生相应的托管证书。证书中包括该用户的特定标识符 UID (Unique Identification)、被托管的那部分公钥和私钥、托管证书的编号。密钥托管代理再用自己的签名私钥对托管证书进行加密, 产生数字签名, 并将其附在托管证书上。

(2) 用户收到所有托管证书后, 将证书和完整的公钥递交给证书授权中心, 申请加密证书。

(3)证书授权中心验证每份托管证书的真实性, 即检验每一个托管代理是否都保管了一部分有效的私钥分量, 并对用户身份加以确认。完成所有的验证工作后, 证书授权中心生成加密证书,发送回用户。

## 第

## 数据的完整性保护



教学要求

本章介绍数据完整性保护技术, 包括信息摘录技术和数字签名技术, 使学生能掌握保护数据完整性的各种技术。通过本章的学习, 了解信息摘录技术的安全散列标准 SHS, 了解数字签名技术的一般概念和常见的数字签名技术, 掌握数字签名标准 DSS。



在计算机网络系统中, 数据一般有两种状态: 储存状态和传输状态。长期以来, 数据传输时的完整性得到了人们更多的关心。然而, 无论是在储存状态, 还是在传输状态, 数据既容易遭到人为的主动攻击, 又容易遭受非人为的异常变化。与传输状态相比, 处于储存状态的数据的完整性也应当受到关注, 这主要有三方面的原因: 一是储存状态的数据既有用户数据又有系统数据, 而传输状态的数据基本上是用户数据; 二是系统的工作主要依赖于储存状态的数据, 而不是传输状态的数据; 三是储存状态的数据系统级的完整性保护比较少, 而传输状态的数据则由网络的传输机制提供了一定程度上的完整性保护。

储存状态可以被看作是静态, 而传输状态则可以被看作是动态。为保证储存状态数据的完整性,可以采取多种措施,包括管理的和技术的。一般的系统都采用系统“准人”即口令机制和资源访问控制两种措施。这两种措施能对数据的完整性起到很好的保护作用, 尤其是能对人为的主动攻击起到积极的防御作用。但是也应该意识到, 无论是从管理上还是从技术上, 要想绝对地避免数据的完整性遭受破坏是不可能的。在这种情况下, 我们应该做的也是能够做的就是要找到一种办法能够对数据的完整性进行检测, 一旦发现数据遭到破坏，能够马上恢复其本来面目。这也是我们最后的武器。

数据校验技术就是这一要求的产物。根据数据校验技术, 可以对要保护的数据按照一定的规则产生一些校验码, 并且把这些校验码记录下来。以后在任何时候,我们可以按照同样的规则生成新的校验码, 并与原来的校验码做比较。依据比较结果, 即新校验码和原来的校验码是否一致, 我们就能够知道数据是否发生了变化因而采取相应的措施。这一工作也叫作完整性检查。

数据校验的方法很多, 不管采用何种方法都必须至少保证两点: 校验码对数据的变化比
较敏感,即校验码会随数据块的不同而不同; 根据校验码很难还原出原始数据。

本章主要来讨论信息摘要技术和数字签名技术。



### 6.1.1 基本原理

杂凑函数 $\mathrm{H}$ 是一公开函数, 用于将任意长的消息 $\mathrm{M}$ 映射为较短的、固定长度的一个值 $\mathrm{H}(\mathrm{M})$ 作为认证符,称函数值 $\mathrm{H}(\mathrm{M})$ 为杂凑值、杂凑码或消息摘要。杂凑码是消息中所有比特的函数,因此具有一种错误检测能力, 即改变消息中任何一个比特或几个比特都会使杂凑码发生改变。

在信息安全技术中,散列 (Hash) 函数提供了验证消息的完整性这一服务,它对不同长度的输人消息产生固定长度的输出。这个固定长度的输出称为原输人消息的“散列”或“信息摘要”( Message Digest)。一个安全的杂凑函数 H 必须具有以下属性:

(1) H 能够应用到长度可变的数据上;

(2) $\mathrm{H}$ 能够生成长度固定的输出;

(3) 对于任意给定的消息 $\mathrm{m}, \mathrm{H}(\mathrm{m})$ 的计算相对简单;

(4)对于任意给定的“散列” $h$, 要找到满足 $\mathrm{H}(\mathrm{m})=\mathrm{h}$ 的 $\mathrm{m}$ 在计算上是不可行的;

(5)对于任意给定的消息 $m$, 要找到满足 $H\left(m^{\prime}\right)=H(m)$ 而 $m^{\prime} \neq m$ 在计算上是不可行的;

(6)要找到符合 $\mathrm{H}\left(\mathrm{m}^{\prime}\right)=\mathrm{H}(\mathrm{m})$ 的 $\left(\mathrm{m}^{\prime}, \mathrm{m}\right)$ 对在计算上是不可行的。

如果单向杂凑函数满足 (6) 这一性质,则称其为强单向杂凑函数。

第 (5) 和第 (6) 个条件给出了杂凑函数无碰撞性的概念。如果杂凑函数对不同的输人可产生相同的输出,则称该函数具有碰撞性。

### 6.1.2 MD5 算法

M D5 算法是由 Rivest 在 1991 年设计的, 在 RFC 1321 中描述。MD5 以 512 位数据块为单位来处理输人,产生 128 位的消息摘要。

MD5 的特点:

（1）基本思想与 MD4 相同: 相同的信息块长度, 相同的信息摘录初值, 相同的填充;

(2) 比 MD4 更安全,但效率更低;

(3)与 MD4 的不同: 使用 4 遍扫描, 扰乱函数移位更多,对每一遍扫描中的每一个字都使用不同的常数,共 64 个。

此算法将对输人的任意长度的信息进行计算,产生一个 128 位长度的“指纹”或“报文摘要”, 假定两个不同的文件产生相同的报文摘要或由给定的报文摘要产生原始信息在计算上是行不通的。MD5 算法适合用在数据签名应用中, 在此应用中,一个大的文件必须在类似 RSA 算法的公用密钥系统中用私人密钥加密前被“压缩”在一种安全模式下。M D5 算法能在 32 位机器上能以很快的速度运行。另外, MD5 算法不需要任何大型的置换列表。
此算法编码很简洁。MD5 算法是 MD4 报文摘要算法的扩展。MD5 算法稍慢于 MD4 算法, 但是在设计上比 MD4 算法更加 “保守”。设计 MD5 是因为 MD4 算法被采用的速度太快, 以至于还无法证明它的正确性, 因为 MD4 算法速度非常快, 它处在遭受成功秘密攻击的 “边缘”。MD5 后退了一步, 它舍弃了一些速度以求更好的安全性。它集中了不同的评论家提出的建议, 并采取了一些附加的优化措施。它被放在公共的地方以求公众的评论意见。它可能作为一个标准被采纳。作为基于 OSI 的应用, MD5 的对象标识符是：

md5 OBJECT IDENTIFIER: : =iso(1) member - body (2)US(840)rsadsi(113549)digestAlgorithm(2) 5\}。在 X. 509 类型 AlgorithmIdentifier 中, MD5 算法参数应该包括 NULL 类型。

术语和符号: 本文中一个“字”是 32 位。一系列位串可看成是一系列字节的普通形式,其中连续的 8 位看成一个字节, 高位在前。同理一系列字节串可看成是一系列 32 位的字,其中每个连续的 4 个字节当作一个字, 低位在前。我们定义 $\mathrm{x}_{\mathrm{i}} \mathrm{i}$ 代表 “ $\mathrm{x}$ 减去 $\mathrm{i}$ ”。如果下划线右边是一个表达式, 则用括号括住, 如: $x_{-}\{i+1\}$ 。同样我们用代表求幕, 这样 $x^{\circ} \mathrm{i}$ 则代表 $\mathrm{x}$ 的 $\mathrm{i}$ 次幕。符号 “+” 代表字的加, $\mathrm{X}<<<_{\mathrm{s}}$ 代表 32 位的值 $\mathrm{X}$ 循环左移 $\mathrm{s}$ 位, $\operatorname{not}(\mathrm{X})$ 代表 $X$ 的按位补运算, $X v Y$ 表示 $X$ 和 $Y$ 的按位或运算, Xxor $Y$ 代表 $X$ 和 $Y$ 的按位异或运算, XY 代表 $\mathrm{X}$ 和 $\mathrm{Y}$ 的按位与运算。

## MD5 算法描述

假设有一个长度为 $\mathrm{b}$ 位的输人信号希望产生报文摘要。此处 $\mathrm{b}$ 是一个非负整数, $\mathrm{b}$ 也可能是 0 , 不一定是 8 的整数倍, 它可以是任意大的长度。我们设想信号的比特流如下所示: $\mathrm{m}_{0} \mathrm{~m}_{1} \cdots \cdots \mathrm{m}_{\mathrm{b}-1}$ 。

下面的 5 步计算信息的报文摘要。

(1) 补位

MD5 算法对输人的数据进行补位, 使得数据位长度 LEN 对 512 求余的结果是 448。即数据扩展至 $\mathrm{K} * 512+448$ 位。即 $\mathrm{K} * 64+56$ 个字节, $\mathrm{K}$ 为整数。补位操作始终要执行,即使数据长度 LEN 对 512 求余的结果是 448 。具体补位操作: 补一个 1 , 然后补 0 至满足上述要求。最少要补一位, 最多补 512 位。

(2) 补数据长度

用一个 64 位的数字表示数据的原始长度 $\mathrm{b}$, 把 $\mathrm{b}$ 用两个 32 位数表示。那么只取 $\mathrm{b}$ 的低 64 位。当遇到 b 大于 264 这种极少遇到的情况时, 这时, 数据就被填补成长度为 512 位的倍。也就是说, 此时的数据长度是 16 个字 (32 位) 的整数倍数。用 $\mathrm{M}[0 \cdots \cdots(\mathrm{N}-1)]$ 表示此时的数据, 其中的 $N$ 是 16 的倍数。

(3) 初始化 MD 缓冲器

用一个四个字的缓冲器 (A, B, C, D) 来计算报文摘要, A, B, C, D 分别是 32 位的寄存器,初始化使用的是十六进制表示的数字:

$$
\begin{aligned}
& A=0 X 01234567 \\
& B=0 X 89 \text { abcdef } \\
& C=0 X f e d c b a 98 \\
& D=0 X 76543210
\end{aligned}
$$

(4) 处理位操作函数

首先定义 4 个辅助函数, 每个函数的输人是三个 32 位的字, 输出是一个 32 位的字。

$X, Y, Z$ 为 32 位整数。

$\mathrm{F}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{XY} \operatorname{vnot}(\mathrm{X}) \mathrm{Z}$

$G(X, Y, Z)=X Z_{v} Y \operatorname{not}(Z)$

$\mathrm{H}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{XxorYxorZ}$

$\mathrm{I}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{Y} \operatorname{xor}(\mathrm{X} \operatorname{vnot}(\mathrm{Z}))$

这一步中使用一个有 64 个元素的常数数组 $\mathrm{T}$, 它由 $\sin$ 函数构成, $\mathrm{T}[\mathrm{i}]$ 表示数组中的第 $\mathrm{i}$ 个元素, 它的值等于经过 4294967296 次 $\operatorname{abs}(\sin (\mathrm{i})$ ) 后的值的整数部分 (其中 $\mathrm{i}$ 是弧度)。 $T[i]$ 为 32 位整数, 用十六进制表示, 数组元素在附录中给出。

具体过程如下:

$/ *$ 处理数据原文* /

For $\mathrm{i}=0$ to $\mathrm{N} / 16-1$ do

$/ *$ 每一次, 把数据原文存放在 16 个元素的数组 X中. */

For $\mathrm{j}=0$ to 15 do

Set $\mathrm{X}[\mathrm{j}]$ to $\mathrm{M}[\mathrm{i} * 16+\mathrm{j}]$

end /结束对 $\mathrm{j}$ 的循环

/* Save AasAA, BasBB, CasCC, and DasDD. * /

$\mathrm{AA}=\mathrm{A}$

$\mathrm{BB}=\mathrm{B}$

$\mathrm{CC}=\mathrm{C}$

$\mathrm{DD}=\mathrm{D}$

$/ *$ 第 1 轮*/

$/ *$ 以 [abcdksi]表示如下操作

$\mathrm{a}=\mathrm{b}+\left((\mathrm{a}+\mathrm{F}(\mathrm{b}, \mathrm{c}, \mathrm{d})+\mathrm{X}[\mathrm{k}]+\mathrm{T}[\mathrm{i}])<<<_{\mathrm{s}}\right) . * /$

$/ *$ Do the following 16 operations. * /

[ABCD071][DABC1122][CDAB2173][BCDA3224]

[ABCD475][DABC5126][CDAB6177][BCDA7228]

[ABCD879][DABC91210][CDAB101711][BCDA112212]

[ABCD12713][DABC131214][CDAB141715][BCDA152216]

$/ *$ 第 2 轮*/

/ * 以[abcdksi]表示如下操作

$\mathrm{a}=\mathrm{b}+((\mathrm{a}+\mathrm{G}(\mathrm{b}, \mathrm{c}, \mathrm{d})+\mathrm{X}[\mathrm{k}]+\mathrm{T}[\mathrm{i}])<<<\mathrm{s}) . * /$

/ * Do the following 16 operations. * /

[ABCD1517][DABC6918][CDAB111419][BCDA02020]

[ABCD5521][DABC10922][CDAB151423][BCDA42024]

[ABCD9525][DABC14926][CDAB31427][BCDA82028]

[ABCD13529][DABC2930][CDAB71431][BCDA122032]

$/ *$ 第 3 轮* /

/ * 以 [abcdksi]表示如下操作

$\mathrm{a}=\mathrm{b}+((\mathrm{a}+\mathrm{H}(\mathrm{b}, \mathrm{c}, \mathrm{d})+\mathrm{X}[\mathrm{k}]+\mathrm{T}[\mathrm{i}])<<<$ s $) . * /$

$/ *$ Do the following 16 operations. */

[ABCD5433][DABC81134][CDAB111635][BCDA142336]

[ABCD1437][DABC41138][CDAB71639][BCDA102340]

[ABCD13441][DABC01142][CDAB31643][BCDA62344]

[ABCD9445][DABC121146][CDAB151647][BCDA22348]

$/ *$ 第 4 轮 $* /$

$/ *$ 以 [abcdksi]表示如下操作

$\mathrm{a}=\mathrm{b}+((\mathrm{a}+\mathrm{I}(\mathrm{b}, \mathrm{c}, \mathrm{d})+\mathrm{X}[\mathrm{k}]+\mathrm{T}[\mathrm{i}])<<<\mathrm{s}) . * /$

$/ *$ Do the following 16 operations * /

[ABCD0649][DABC71050][CDAB141551][BCDA52152]

[ABCD12653][DABC31054][CDAB101555][BCDA12156]

[ABCD8657][DABC151058][CDAB61559][BCDA132160]

[ABCD4661][DABC111062][CDAB21563][BCDA92164]

/ * 然后进行如下操作 $*$ /

$\mathrm{A}=\mathrm{A}+\mathrm{AA}$

$\mathrm{B}=\mathrm{B}+\mathrm{BB}$

$\mathrm{C}=\mathrm{C}+\mathrm{CC}$

$\mathrm{D}=\mathrm{D}+\mathrm{DD}$

end $/ *$ 结束对 i 的循环 * /

(5) 输出结果

报文摘要产生后的形式为 : A, B, C, D。也就是以低位字节 A 开始, 以高位字节 $\mathrm{D}$ 结束。

MD5 有这样一个性质, 即杂凑码中的每一个比特是所有输人比特的函数, 因此获得了很好的混淆效果, 从而不可能随机选择两个具有相同杂凑值的消息。Rivest 猜想作为 128 比特长的杂凑值来说, MD5 的强度达到了最大。比如说找出具有相同杂凑值的两个消息需执行 $O\left(2^{64}\right)$ 次运算,而寻找具有给定杂凑值的一个消息需要执行 $O\left(2^{128}\right)$ 次运算。

M D5 算法实现很容易,它提供了任意长度的信息的“指纹”(或称为报文摘要)。据推测要实现两个不同的报文产生相同的摘要需要 2 64 次的操作, 要恢复给定摘要的报文则需要 2428 次操作。为寻找缺陷, M D5 算法已经过非常细致的检查。最后的结论是还需要相关的更好的算法和更进一步的安全分析。

## 6.1 . 3 安全散列标准

安全散列标准 SHA (Secure Hash Algorithm)算法由 NIST 开发,并在 1993 年作为联邦信息处理标准公布。在 1995 年公布了其改进版本 SHA-1。SHA 与 MD5 的设计原理类似,同样也按 2 比特数据块为单位来处理输人,但它产生 160 位的消息摘要,具有比 MD5 更强的安全性。

## 基本思想

(1)输人要求小于 264 比特, 输出为 160 比特 (5 个字,分别记为 $A 、 B 、 C 、 D 、 E$ );

(2)将输人信息分成若干个 512 比特固定长度的块;

(3)每一块与当前的信息摘要值结合, 产生下一个信息摘要的中间结果, 直至处理完毕;

(4)每一个信息块使用 5 遍扫描处理;

(5)填充方式与 MD4 相同,将输人信息填充为 512 比特的整数倍;

（6)效率略低于 MD5,但强度略高。

## 基本算法

算法的输人为小于 264 比特长的任意消息,分为 512 比特长的分组, 输出为 160 比特长的消息摘要。

算法的处理过程有以下几步:

(1)消息填充与 MD5 的步骤 (1)完全相同。

(2)附加消息的长度与 MD5 的步骤 (2)类似,不同之处在于以 big-endian 方式表示填充前消息的长度。即将步骤 (1)留出的 64 比特当作 64 比特长的无符号整数。

(3) M D 缓冲区初始化算法使用 160 比特长的缓冲区存储中间结果和最终杂凑值,缓冲区可表示为 5 个 32 比特长的寄存器 (A, B, C, D, E), 每个寄存器都以 big-endian 方式存储数据, 其初始值分别为 $\mathrm{A}=0 \mathrm{X} 67452301, \mathrm{~B}=0 \mathrm{XEFCDAB89}, \mathrm{C}=0 \mathrm{X} 98 \mathrm{BADCFB}, \mathrm{D}=$ OX10325476,E=0XC3D2E1F0。

(4) 以分组为单位对消息进行处理。每一分组 $Y_{q}$ 都经过一个压缩函数处理, 压缩函数由 4 轮处理过程 (如图 6-1 所示) 构成, 每一轮又由 20 步迭代组成。 4 轮处理过程结构一样,但所用的基本逻辑函数不同,分别表示为 $f_{1}, f_{2}, f_{3}, f_{4}$ 。每轮的输人为当前处理的消息分组 $Y_{q}$ 和缓冲区的当前值 $A, B, C, D, E$, 输出仍放在缓冲区以替代 $A, B, C, D, E$ 的旧值, 每轮处理过程还需加上一个加法常量 $K_{\mathrm{t}}$, 其中 $0 \leqslant \mathrm{t} \leqslant 79$ 表示迭代的步数。80 个常量中实际上只有 4 个不同取值。 $\mathrm{W}_{\mathrm{t}}(0 \leqslant \mathrm{t} \leqslant 79)$ 是由当前 512 比特分组导出的一个 32 比特字。



图 6-1 SHA 分组处理框图

第 4 轮的输出 (即第 80 步迭代的输出) 再与第 1 轮的输人 $\mathrm{CV}_{\mathrm{q}}$ 相加, 以产生 $\mathrm{CV}_{\mathrm{q}+1}$, 其中加法是缓冲区 5 个字中的每一个字与 $\mathrm{CV}_{\mathrm{q}}$ 中相应的字模 $2^{32}$ 相加。

(5)输出消息的 $\mathrm{L}$ 个分组都被处理完后,最后一个分组的输出即为 160 比特的消息摘要。

步骤(3)到步骤(5)的处理过程可总结如下:

$\mathrm{CV}_{0}=\mathrm{IV}$;

$\mathrm{CV}_{\mathrm{q}}+1=\mathrm{SUM} 32\left(\mathrm{CV}_{\mathrm{q}}, \mathrm{ABCDE}_{\mathrm{q}}\right) ;$

$\mathrm{MD}=\mathrm{CV}_{\mathrm{L}}$

其中 IV 是步骤 (3) 定义的缓冲区 $\mathrm{ABCDE}$ 的初值, $\mathrm{ABCDE}_{\mathrm{q}}$ 是第 $\mathrm{q}$ 个消息分组经最后一轮处理过程处理后的输出, L 是消息 (包括填充位和长度字段) 的分组数, SUM32 是对应字的模 $2^{32}$ 加法, MD 为最终的摘要值。

## SHA 与 MD5 的比较

由于 SHA 与 MD5 都是由 MD4 演化而来,所以两个算法极为相似。

(1)抗击穷搜索攻击的强度

由于 SHA 和 MD5 的消息摘要长度分别为 160 和 128 ,所以用穷搜索攻击寻找具有给定消息摘要的消息分别需做 $O\left(2^{160}\right)$ 和 $O\left(2^{128}\right)$ 次运算,而用穷搜索攻击找出具有相同消息摘要的两个不同消息分别需做 $O\left(2^{80}\right)$ 和 $O\left(2^{64}\right)$ 次运算。因此 SHA 抗击穷搜索攻击的强度高于 MD5。

(2) 抗击密码分析攻击的强度

由于 SHA 的设计准则未被公开,所以它抗击密码分析攻击的强度较难判断, 似乎高于 MD5。

(3) 速度

由于两个算法的主要运算都是模 $2^{32}$ 加法, 因此都易于在 32 位结构上实现。但比较起来, SHA 的迭代步数 (80 步) 多于 MD5 的迭代步数 (64 步), 所用的缓冲区 (160 比特) 大于 MD5 使用的缓冲区 (128 比特), 因此在相同硬件上实现时, SHA 的速度要比 MD5 的速度慢。

(4)简洁与紧致性

两个算法描述起来都较为简单, 实现起来也较为简单, 都不需要大的程序和代换表。

(5)数据的存储方式

M D5 使用 little-endian 方式, SH A 使用 big-endian 方式。两种方式相比看不出哪个更具优势, 之所以使用两种不同的存储方式是因为设计者最初实现各自的算法时,使用的机器的存储方式不同。

### 6.1.4 HMAC

数据认证算法反映了传统上构造 MAC 使用最为普遍的方法, 即基于分组密码的构造方法。但近年来研究构造 M AC 的兴趣已转移到基于密码杂凑函数的构造方法, 这是因为:

(1)密码杂凑函数 (如 MD5、SHA) 的软件实现快于分组密码 (如 DES) 的软件实现;

(2) 密码杂凑函数的库代码来源广泛;

(3) 密码杂凑函数没有出口限制, 而分组密码即使用于 MAC 也有出口限制;

(4) 杂凑函数并不是为 M AC 而设计的, 由于杂凑函数不使用密钥, 因此不能直接用于 $M A C$ 。目前已提出了很多将杂凑函数用于构造 MAC 的方法, 其中 HMAC 就是其中之一,
已作为 RFC2104 被公布, 并在 IPSec 和其他网络协议(如 SSL) 中得以应用。

RFC2104 列举了 HMAC 的以下设计目标:

(1) 可不经修改而使用现有的杂凑函数, 特别是那些易于软件实现的、源代码可方便获取且免费使用的杂凑函数;

（2）其中镶嵌的杂凑函数可易于替换为更快或更安全的杂凑函数。

(3) 保持镶嵌的杂凑函数的最初性能,不因用于 HMAC 而降低;

(4) 以简单方式使用和处理密钥;

（5）在对镶嵌的杂凑函数合理假设的基础上,易于分析 HMAC 用于认证时的密码强度。

其中前两个目标是 HMAC 被公众普遍接受的主要原因,这两个目标是将杂凑函数当作一个黑盒使用。这种方式有两个优点: 第一, 杂凑函数的实现可作为实现 HMAC 的一个模块, 这样一来, HM AC 代码中很大一块就可事先准备好, 无需修改就可使用; 第二, 如果 HMAC 要求使用更快或更安全的杂凑函数,则只需用新模块代替旧模块, 例如用实现 SHA 的模块代替 MD5 的模块。

最后一条设计目标则是 HMAC 优于其他基于杂凑函数的 MAC 的一个主要方面, HMAC 在其镶嵌的杂凑函数具有合理密码强度的假设下,可证明是安全的。

## 基本思想

利用对称密钥 $\mathrm{K}$ 和单向函数 $\mathrm{H}$ 生成信息鉴别码。

特点

(1)直接使用现有的单向函数,计算效率和安全强度依赖于所选用的单向函数, 密钥和单向函数的管理比较简单;

(2) 密钥可以为任意长度。若超过信息块长度 $\mathrm{b}$,则首先使用 $\mathrm{H}$ 函数缩短至 $\mathrm{b}$ 。密钥长度 $\mathrm{K}$ 不应小于 $\mathrm{H}$ 函数的输出长度 $\mathrm{L}$;

(3)计算效率较高,但预先计算的值需要像密钥那样保护得很好。

## 算法描述

图 6-2 是 HMAC 算法的运行框图, 其中 H 为嵌人的杂凑函数 (如 MD5、SHA), M 为 HMAC 的输人消息 (包括杂凑函数所要求的填充位), $\mathrm{Y}_{\mathrm{i}}(0 \leqslant \mathrm{i} \leqslant \mathrm{L}-1)$ 是 M 的第 $\mathrm{i}$ 个分组, $\mathrm{L}$ 是 $\mathrm{M}$ 的分组数, $\mathrm{b}$ 是一个分组中的比特数, $\mathrm{n}$ 为由嵌人的杂凑函数所产生的杂凑值的长度, $\mathrm{K}$ 为密钥, 如果密钥长度大于 $\mathrm{b}$, 则将密钥输人到杂凑函数中产生一个 $\mathrm{n}$ 比特长的密钥, $\mathrm{K}^{+}$是左边经填充 0 后的 $\mathrm{K}, \mathrm{K}^{+}$的长度为 $\mathrm{b}$ 比特, ipad 为 $\mathrm{b} / 8$ 个 $00110110, \mathrm{opad}$ 为 $\mathrm{b} / 8$ 个 01011010 。

算法的运行过程可描述如下:

(1) $\mathrm{K}$ 的左边填充 0 以产生一个 $\mathrm{b}$ 比特长的 $\mathrm{K}^{+}$(例如 $\mathrm{K}$ 的长为 160 比特, $\mathrm{b}=512$, 则需填充 44 个零字节 $0 \times 00)$;

(2) $\mathrm{K}^{+}$与 ipad 逐比特异或以产生 $\mathrm{b}$ 比特的分组 $\mathrm{S}_{\mathrm{i}}$;

(3) 将 $\mathrm{M}$ 链接到 $\mathrm{Si}_{\mathrm{i}}$ 后;

(4) 将 $\mathrm{H}$ 作用于步骤 (3) 产生的数据流;

(5) $\mathrm{K}^{+}$与 opad 逐比特异或,以产生 b 比特长的分组 $\mathrm{S}_{0}$;

(6) 将步骤 (4) 得到的杂凑值链接在 So 后;



图 6-2 HMAC 算法框图

(7) 将 $\mathrm{H}$ 作用于步骤 (6) 产生的数据流并输出最终结果。

注意, $\mathrm{K}^{+}$与 ipad 逐比特异或以及 $\mathrm{K}^{+}$与 opad 逐比特异或的结果是将 $\mathrm{K}$ 中的一半比特取反, 但两次取反的比特的位置不同。而 $\mathrm{S}$ 和 $\mathrm{S}_{0}$ 通过杂凑函数中压缩函数的处理, 则相当于以伪随机方式从 $\mathrm{K}$ 产生两个密钥。

在实现 HMAC 时, 可预先求出下面两个量：

f(IV , $\left(\mathrm{K}^{+} \oplus \mathrm{ipad}\right)$

f(IV, $\left(\mathrm{K}^{+} \oplus\right.$ opad)

其中 $\mathrm{f}(\mathrm{cv}$, block $)$ 是杂凑函数中的压缩函数, 其输人是 $\mathrm{n}$ 比特的链接变量和 $\mathrm{b}$ 比特的分组, 输出是 $\mathrm{n}$ 比特的链接变量。这两个量的预先计算只在每次更改密钥时才需进行。事实上这两个预先计算的量用于作为杂凑函数的初值 IV。

## HMAC 的安全性

基于密码杂凑函数构造的 MAC 的安全性取决于镶嵌的杂凑函数的安全性, 而 HMAC 最吸引人的地方是它的设计者已经证明了算法的强度和嵌人的杂凑函数的强度之间的确切关系, 证明了对 HMAC 的攻击等价于对内嵌杂凑函数的下述两种攻击之一:

(1) 攻击者能够计算压缩函数的一个输出,即使 IV 是随机的的秘密的。

(2)攻击者能够找出杂凑函数的碰撞, 即使 IV 是随机的和秘密的。

在第一种攻击中, 可将压缩函数视为与杂凑函数等价, 而杂凑函数的 $\mathrm{n}$ 比特长 IV 可视为 HMAC 的密钥。对这一杂凑函数的攻击可通过对密钥的穷搜索来进行, 也可通过第 II 类生日攻击来实施, 通过对密钥的穷搜索攻击的复杂度为 $O\left(2^{n}\right)$, 通过第 II 类生日攻击又可
归结为上述第二种攻击。

第二种攻击指攻击者寻找具有相同杂凑值的两个消息, 因此就是第 II 类生日攻击。对杂凑值长度为 $\mathrm{n}$ 的杂凑函数来说, 攻击的复杂度为 $O\left(2^{\frac{n}{2}}\right)$ 。因此第二种攻击对 MD5 的攻击复杂度为 $O\left(2^{64}\right)$, 就现在的技术来说, 这种攻击是可行的。但这是否意味着 MD5 不适合用于 HMAC? 答案是否定的,原因如下: 攻击者在攻击 MD5 时,可选择任何消息集合后脱线寻找碰撞。由于攻击者知道杂凑算法和默认的 IV, 因此能为自己产生的每个消息求出杂凑值。然而, 在攻击 HMAC 时, 由于攻击者不知道密钥 $\mathrm{K}$, 从而不能脱线产生消息和认证码对。所以攻击者必须得到 HMAC 在同一密钥下产生的一系列消息, 并对得到的消息序列进行攻击。对长 128 比特的杂凑值来说, 需要得到用同一密钥产生的 $2^{64}$ 个分组 $\left(2^{73}\right.$ 比特)。在 1 Gbps 的链路上, 需 250000 年, 因此 MD5 完全适合于 HMAC, 而且就速度而言, MD5 要快于以 $\mathrm{SHA}$ 作为内嵌杂凑函数的 HMAC。

## 6.2 政家兴者

数字签名由公钥密码发展而来, 它在网络安全, 包括身份认证、数据完整性、不可否认性以及匿名性等方面有着重要应用。

## 6.2 .1 数字签名的概念

数字签名 (Digital Signature) 可解决手写签名中的签名人否认签名或其他人伪造签名等问题。因此, 被广泛用于银行的信用卡系统、电子商务系统、电子邮件以及其他需要验证、核对信息真伪的系统中。

手工签名是模拟的, 因人而异,而数字签名是数字式的 ( $0 、 1$ 数字串), 因信息而异。

类似于手工签名,数字签名应具有以下性质:

(1)能够验证签名产生者的身份以及产生签名的日期和时间;

(2)能用于证实被签消息的内容;

(3)数字签名可由第三方验证, 从而能够解决通信双方的争议。

由此可见, 数字签名具有认证功能。为实现上述 3 条性质, 数字签名应满足以下要求:

(1)签名的产生必须使用发送方独有的一些信息以防伪造和否认;

（2）签名的产生应较为容易;

（3)签名的识别和验证应较为容易;

（4）对已知的数字签名构造一个新的消息或对已知的消息构造一个假冒的数字签名在计算上都是不可行的。

数字签名具有以下功能:

- 收方能够确认发方的签名,但不能伪造;

-发方发出签过名的信息后,不能再否认;

- 收方对收到的签名信息也不能否认;

-一旦收发方出现争执, 仲裁者可有充足的证据进行评判。

数字签名:对信息内容产生完整性的保护, 实现无法否认的能力。
签名的目的:使报文的接收方能够对公正的第三方证明其报文内容是真实的,而且是由指定的发送方发出的。双方都不能出于自己的利益否认或修改报文的内容。签名所保护的内容可能会被破坏,但不会被欺骗。

基本形式:基于特定的附加信息的信息摘录。

## 6.2 .2 基于公钥密码体制的数字签名

利用密钥的非对称性和加/解密操作的可交换性实现。签名方用私钥加密报文作为签名,验证方利用公钥解密密文并同明文比较以确定真伪。

## 基于 RSA 方法的数字签名

(1)体制参数

选两个保密的大素数 $\mathrm{p}$ 和 $\mathrm{q}$, 计算 $\mathrm{n}=\mathrm{p} \times \mathrm{q}, \varphi(\mathrm{n})=(\mathrm{p}-1)(\mathrm{q}-1)$; 选一整数 $\mathrm{e}$, 满足 $1<$ $\mathrm{e}<\varphi(\mathrm{n})$, 且 $\operatorname{gcd}(\varphi(n), e)=1$; 计算 $\mathrm{d}$, 满足 $\mathrm{d} \cdot \mathrm{e} \equiv 1 \bmod \varphi(\mathrm{n})$; 以 $\{\mathrm{e}, \mathrm{n}\}$ 为公钥, $\{\mathrm{d}, \mathrm{n}\}$ 为私钥。

(2)签名过程

设消息为 $\mathrm{M}$,对其签名为

$\mathrm{S} \equiv \mathrm{M}^{\mathrm{d}} \bmod \mathrm{n}$

(3)验证过程

接收方在收到消息 $M$ 和签名 $S$ 后, 验证 $M \equiv S^{e} \bmod n$ 是否成立,若成立,则发送方的签名有效。

签名方私钥的唯一性保证了签名的惟一性。

ElGamal 数字签名

基于离散对数原理, 属于比较经典的数字签名方法。

(1) 体制参数

$\mathrm{p}$ :大素数;

$\mathrm{g}: \mathrm{Z}_{\mathrm{p}}^{*}$ 的一个生成元;

$\mathrm{x}$ :用户 $\mathrm{A}$ 的私钥, $\mathrm{x} \in \mathrm{Z}_{\mathrm{p}}^{*}$;

$\mathrm{y}$ :用户 $\mathrm{A}$ 的公钥, $\mathrm{y} \equiv \mathrm{g}^{\mathrm{x}}(\bmod \mathrm{p})$ 。

(2) 签名的产生过程

对于待签名的消息 $m$,用户 $\mathrm{A}$ 执行以下步骤:

1)计算 $\mathrm{m}$ 的杂凑值 $\mathrm{H}(\mathrm{m})$;

2) 选择随机数 $\mathrm{k}: \mathrm{k} \in \mathrm{Z}_{\mathrm{p}}^{*}$, 计算 $\mathrm{r} \equiv \mathrm{g}^{\mathrm{k}}(\bmod \mathrm{p})$;

3)计算 $\mathrm{s} \equiv(\mathrm{H}(\mathrm{m})-\mathrm{xr}) \mathrm{k}^{-1}(\bmod \mathrm{p}-1)$ 。

以 $(\mathrm{r}, \mathrm{s})$ 作为产生的数字签名。

(3) 签名验证过程

接收方在收到消息 $m$ 和数字签名 $(r, s)$ 后, 先计算 $\mathrm{H}(\mathrm{m})$, 并按下式验证: $y^{r} r^{s}=g^{H(m)} \bmod p$ 。

Schnorr 签名体制

(1) 体制参数

$\mathrm{p}$ : 大素数, $\mathrm{p} \geqslant 2^{512}$;

$\mathrm{q}$ : 大素数, $\mathrm{q} \mid(\mathrm{p}-1), \mathrm{q} \geqslant 2^{160}$;

$\mathrm{g}: \mathrm{g} \in \mathrm{Z}_{\mathrm{p}}^{*}$, 且 $\mathrm{g}^{\mathrm{q}} \equiv 1(\bmod \mathrm{p})$;

$\mathrm{x}$ : 用户 $\mathrm{A}$ 的私钥, $1<_{\mathrm{x}}<_{\mathrm{q}}$;

$\mathrm{y}$ : 用户 $\mathrm{A}$ 的公钥, $\mathrm{y} \equiv \mathrm{g}^{\mathrm{x}}(\bmod \mathrm{p})$ 。

(2) 签名的产生过程

对于待签名的消息 $m$, 用户 $A$ 执行以下步骤:

1) 选择随机数 $\mathrm{k}: 1<_{\mathrm{k}}<_{\mathrm{q}}$, 计算 $\mathrm{r} \equiv \mathrm{g}^{\mathrm{k}}(\bmod \mathrm{p})$;
2) 计算 $\mathrm{e}=\mathrm{H}(\mathrm{r}, \mathrm{m})$;

3)计算 $\mathrm{s} \equiv \mathrm{xe}+\mathrm{k}(\bmod \mathrm{q})$ 。

以 $(e, s)$ 作为产生的数字签名。

(3) 签名验证过程

接收方在收到消息 $m$ 和数字签名 $(e, s)$ 后, 先计算 $r^{\prime} \equiv g^{s} y^{-c}(\bmod p)$, 然后计算 $\mathrm{H}\left(\mathrm{r}^{\prime}, \mathrm{m}\right)$, 并验证 $\mathrm{H}\left(\mathrm{r}^{\prime}, \mathrm{m}\right)=\mathrm{e}$ 。

### 6.2.3 基于私钥密码体制的数字签名

基于公钥算法数字签名的缺点是计算量很大, 强度不如对称密钥算法。

发送方 $\mathrm{A}$ 根据单钥加密算法用与接收方 $\mathrm{B}$ 共享的密钥 $\mathrm{K}$ 对消息 $\mathrm{M}$ 加密然后将密文作为对 $M$ 的数字签名发往 $B$ 。该系统能向 $B$ 保证所收到的消息的确来自 $A$, 因为只有 $A$ 知道密钥 $\mathrm{K}$ 。再者 $\mathrm{B}$ 恢复出 $\mathrm{M}$ 后, 可相信 $\mathrm{M}$ 未被篡改, 因为敌手不知道 $\mathrm{K}$ 就不知如何通过修改密文而修改明文。具体来说, 就是 $B$ 执行解密运算 $Y=D K(X)$, 如果 $X$ 是合法消息 $M$ 加密后的密文,则 $B$ 得到的 $Y$ 就是明文消息 $M$,否则 $Y$ 将是无意义的比特序列。

基于私钥密码体制的数字签名缺陷:

(1)签名比报文长得多。

(2)签名密钥若不采用一次一密方式,则每次签名都会把 $\mathrm{n}$ 个密钥泄漏出去, 重复使用相同的签名密钥是很不安全的; 而一次一密方式的密钥管理负担很重。

(3) 对称密钥算法则由于双方共享密钥, 接收方可以伪造签名,需要公证方支持才能实用化。

### 6.2.4 数字签名标准 DSS

(1)设计思想:签名者的计算能力较低且计算时间要短, 而验证者计算能力较强。DSA 是在 ElGamal 和 Schnorr 两个签名方案的基础上设计的, 其安全性基于求离散对数的困难性。

(2)算法步骤

首先将 DSS 与 RSA 的签名方式做一比较。RSA 算法既能用于加密和签名, 又能用于密钥交换。与此不同, DSS 使用的算法只能提供数字签名功能。

采用 RSA 签名时, 将消息输人到一个杂凑函数以产生一个固定长度的安全杂凑值, 再
用发方的私钥加密杂凑值就形成了对消息的签名。消息及其签名被一起发给收方, 收方得到消息后再产生出消息的杂凑值，且使用发方的公钥对收到的签名解密。这样收方就得到了两个杂凑值, 如果两个杂凑值是一样的, 则认为收到的签名是有效的。

DSS 签名也利用一杂凑函数产生消息的一个杂凑值, 杂凑值连同一随机数 $\mathrm{k}$ 一起作为签名函数的输人,签名函数还需使用发送方的私钥 SKA 和供所有用户使用的一组参数, 称这一组参数为全局公钥 $\mathrm{PKG}$ 。签名函数的两个输出 $\mathrm{s}$ 和 $\mathrm{r}$ 就构成了消息的签名 $(\mathrm{s}, \mathrm{r})$ 。接收方收到消息后再产生出消息的杂凑值,将杂凑值与收到的签名一起输人验证函数,验证函数还需输人全局公钥 PKG 和发送方的公钥 PKA。验证函数的输出如果与收到的签名成分 $\mathrm{r}$ 相等, 则验证了签名是有效的。

1) 全局公钥

$\mathrm{p}$ : 满足 $2^{\mathrm{L}-1}<\mathrm{p}<2^{\mathrm{L}}$ 的大素数, 其中 $512 \leqslant \mathrm{~L} \leqslant 1024$ 且 $\mathrm{L}$ 是 64 的倍数;

$\mathrm{q}: \mathrm{p}-1$ 的素因子, 满足 $2^{159}<_{\mathrm{q}}<2^{160}$, 即 $\mathrm{q}$ 长为 160 比特;

$g: g \equiv h^{(p-1) / q} \bmod p$, 其中 $h$ 是满足 $1<h<p-1$ 且使得 $h^{(p-1) / q} \bmod p>1$ 的任一整数。

2)用户私钥 $x$

$\mathrm{x}$ 是满足 $0<_{\mathrm{x}}<_{\mathrm{q}}$ 的随机数或伪随机数。

3)用户的公钥 $y$

$\mathrm{y} \equiv \mathrm{g}^{\mathrm{x}} \bmod \mathrm{p}$ 。

4)用户为待签消息选取的秘密数 $\mathrm{k}$

$\mathrm{k}$ 是满足 $0<\mathrm{k}<_{\mathrm{q}}$ 的随机数或伪随机数。

5)签名过程

用户对消息 $M$ 的签名为 $(r, s)$, 其中 $r \equiv\left(g^{k} \bmod p\right) \bmod q, s \equiv\left[k^{-1}(H(M)+x r)\right] \bmod$ $q, H(M)$ 是由 $S H A$ 求出的杂凑值。

6)验证过程

设接收方收到的消息为 $\mathrm{M}^{\prime}$, 签名为 $\left(\mathrm{r}^{\prime}, \mathrm{s}^{\prime}\right)$ 。计算

$\mathrm{w} \equiv\left(\mathrm{s}^{\prime}\right)^{-1} \bmod \mathrm{q}, \mathrm{u} 1 \equiv\left[\mathrm{H}\left(\mathrm{M}^{\prime}\right) \mathrm{w}\right] \bmod \mathrm{q}$

$\mathrm{u}_{2} \equiv \mathrm{r}^{\prime} \mathrm{w} \bmod \mathrm{q}, \mathrm{v} \equiv\left[\left(\mathrm{g}^{\mathrm{u}_{1}} \mathrm{y}^{\mathrm{u}_{2}}\right) \bmod \mathrm{p}\right] \bmod \mathrm{q}$

检查 $r$ 与 $r^{\prime}$ 是否相等, 若相等, 则认为签名有效。

算法的框图如图 6-3 所示, 其中的 4 个函数分别为


图 6-3 DSA 签名和验证过程

$\mathrm{s} \equiv \mathrm{f}_{1}[\mathrm{H}(\mathrm{M}), \mathrm{k}, \mathrm{x}, \mathrm{r}, \mathrm{q}] \equiv\left[\mathrm{k}^{-1}(\mathrm{H}(\mathrm{M})+\mathrm{xr})\right] \bmod \mathrm{q}$

$\mathrm{r}=\mathrm{f}_{2}(\mathrm{k}, \mathrm{p}, \mathrm{q}, \mathrm{g}) \equiv\left(\mathrm{g}^{\mathrm{k}} \bmod \mathrm{p}\right) \bmod \mathrm{q}$

$\mathrm{w}=\mathrm{f}_{3}\left(\mathrm{~s}^{\prime}, \mathrm{q}\right) \equiv\left(\mathrm{s}^{\prime}\right)^{-1} \bmod \mathrm{q}$
$\mathrm{v}=\mathrm{f}_{4}\left(\mathrm{y}, \mathrm{q}, \mathrm{g}, \mathrm{H}\left(\mathrm{M}^{\prime}\right), \mathrm{w}, \mathrm{r}^{\prime}\right)$



由于离散对数的困难性,敌手从 $\mathrm{r}$ 恢复 $\mathrm{k}$ 或从 $\mathrm{s}$ 恢复 $\mathrm{x}$ 都是不可行的。

还有一个问题值得注意, 即签名产生过程中的运算主要是求 $r$ 的模指数运算 $r=\left(g^{k}\right.$ $\bmod p ） \bmod q$, 而这一运算与待签的消息无关,因此能被预先计算。事实上,用户可以预先计算出很多 $\mathrm{r}$ 和 $\mathrm{k}^{-1}$ 以备以后的签名使用, 从而可大大加快产生签名的速度。

## 实验题

实验 6.1 使用 MD5SUM 创建 Hash 校验和

要求: 了解 Hash 算法的工作原理以及 MD5SUM 程序的使用

## 习习题

6.1 信息摘要技术的基本原理是什么?

6.2 简述 MD5 的工作过程。

$6.3 \mathrm{SHA}$ 与 MD5 的区别与联系是什么?

6.4 HMAC 的原理是什么?

6.5 什么是数字签名? 其功能是什么? 数字签名基于的密码体制有哪些?

6.6 简述 DSS 的算法步骤。

6.7 在 DSS 数字签名标准中, 取 $\mathrm{p}=83=2 \times 41+1, \mathrm{q}=41, \mathrm{~h}=2$, 于是 $\mathrm{g} \equiv 2^{2} \equiv 4 \bmod$ 83 , 若取 $\mathrm{x}=57$, 则 $\mathrm{y} \equiv \mathrm{g}^{\mathrm{x}} \equiv 4^{57}=77 \bmod 83$ 。在对消息 $\mathrm{M}=56$ 签名时, 选择 $\mathrm{k}=23$, 计算签名并进行验证。

## 实验题参考答案

实验 6.1

实验步骤:

1.以 root 身份登录到 Linux 系统

2. 在根目录下创建文件夹 md5test

$\mathrm{cd} /$

mkdir md5test

3.进人 md5test 目录: cd md5test

4. 创建名为 myfile 的文件: touch myfile

5 . 使用 vi 编辑 myfile 文件, 输人以下内容:

Has anyone altered the contents of this file?

6 . 使用 md5SUM 计算 Hash 校验和

[root@md5test]井md5SUM, myfile

7. 再次运行 md5SUM 命令, 并且将结果导出保存到 myfile. md5 文件中

$[$ root@md5test $]$ md5SU M myfile>myfile.md5

8. 打开 myfile 文件, 修改文件内容 (尽量作最小的改动) 然后保存
9. 再次运行 Md5SU M 命令, 应该得到不同的 Hash 值
10. 用 cat 命令查看 myfile. $\mathrm{md} 5$ 内容: cat myfile. md5

11.比较第 9 步和第 10 步的输出结果,应该看到两者的不同

12. 输人以下命令: $\mathrm{md} 5 \mathrm{SU} \mathrm{M} / \mathrm{etc} /$ passwd/>passwd. $\mathrm{md}$, 创建针对当前/etc/passwd 数据库的 hash 校验和

13.查看 passwd.md5 文件内容: cat passwd.md5

14.添加用户 Hashtest 并且修改密码

Linux \# useradd hashtest

Linux \# passwd hashtest

Changing password for user hashtest

Nes UNIX password:

Retype new UNIX password:

passwd:all authentication tokens updated successfully

15. 执行命令 md5SU M-c passwd. md5, 其中-c 参数用来比较数据库更改前后的 Hash 校验值,应该能够看到有关校验值已经改变的信息。

## 习题参考答案

6.1 在信息安全技术中,散列 (Hash) 函数提供了验证消息的完整性这一服务,它对不同长度的输人消息,产生固定长度的输出。这个固定长度的输出称为原输人消息的 “散列”或“信息摘要”( Message Digest)。

## 6.2 (1) 补位

MD5 算法是对输人的数据进行补位, 使得数据位长度 LEN 对 512 求余的结果是 448 。即数据扩展至 $K * 512+448$ 位。即 $K * 64+56$ 个字节, $K$ 为整数。补位操作始终要执行,即使数据长度 LEN 对 512 求余的结果已是 448 。具体补位操作: 补一个 1 , 然后补 0 至满足上述要求。总共最少要补一位,最多补 512 位。

(2) 补数据长度

用一个 64 位的数字表示数据的原始长度 $\mathrm{b}$,把 $\mathrm{b}$ 用两个 32 位数表示。那么只取 $\mathrm{b}$ 的低 64 位。当遇到 b 大于 264 这种极少遇到的情况时, 这时, 数据就被填补成长度为 512 位的倍数。也就是说, 此时的数据长度是 16 个字 (32 位) 的整数倍。用 $\mathrm{M}[0 \cdots \cdots(\mathrm{N}-1)]$ 表示此时的数据, 其中的 $\mathrm{N}$ 是 16 的倍数。

(3) 初始化 MD 缓冲器

用一个四个字的缓冲器 (A, B, C, D) 来计算报文摘要, A, B, C, D 分别是 32 位的寄存器, 初始化使用的是十六进制表示的数字:

$\mathrm{A}=0 \mathrm{X} 01234567$;

$\mathrm{B}=0 \mathrm{X} 89$ abcdef;

$\mathrm{C}=0$ Xfedcba 98 ;

$\mathrm{D}=0 \mathrm{X} 76543210$ 。

(4) 处理位操作函数

首先定义 4 个辅助函数, 每个函数的输人是三个 32 位的字, 输出是一个 32 位的字。

$X, Y, Z$ 为 32 位整数。
$\mathrm{F}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{X} Y \operatorname{vnot}(\mathrm{X}) \mathrm{Z}$

$\mathrm{G}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{XZv} \mathrm{Ynot}(\mathrm{Z})$

$\mathrm{H}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{XxorYx}$ xorZ

$\mathrm{I}(\mathrm{X}, \mathrm{Y}, \mathrm{Z})=\mathrm{Yx} \operatorname{xor}\left(\mathrm{X}_{\operatorname{vnot}}(\mathrm{Z})\right)$

这一步中使用一个有 64 个元素的常数组 $\mathrm{T}$, 它由 $\sin$ 函数构成, $\mathrm{T}[\mathrm{i}$ 表示数组中的第 $\mathrm{i}$个元素, 它的值等于经过 4294967296 次 $\operatorname{abs}(\sin (\mathrm{i})$ ) 后的值的整数部分(其中 $\mathrm{i}$ 是弧度)。 $\mathrm{T}$ $[i]$ 为 32 位整数*用十六进制表示。

(5)输出结果

报文摘要产生后的形式为: A, B, C, D。也就是低位字节从 A 开始, 高位字节从 D 结束。

6.3 由于 SHA 与 MD5 都是由 MD4 演化而来,所以两个算法极为相似。

(1)抗击穷搜索攻击的强度

由于 SHA 和 MD5 的消息摘要长度分别为 160 和 128 ,所以用穷搜索攻击寻找具有给定消息摘要的消息分别需做 $O\left(2^{160}\right)$ 和 $O\left(2^{128}\right)$ 次运算,而用穷搜索攻击找出具有相同消息摘要的两个不同消息分别需做 $O\left(2^{80}\right)$ 和 $O\left(2^{64}\right)$ 次运算。因此 SHA 抗击穷搜索攻击的强度高于 MD5。

## (2)抗击密码分析攻击的强度

由于 SHA 的设计准则未被公开,所以它抗击密码分析攻击的强度较难判断, 似乎高于 MD5。

## (3) 速度

由于两个算法的主要运算都是模 $2^{32}$ 加法, 因此都易于在 32 位结构上实现。但比较起来, SHA 的迭代步数 (80 步) 多于 MD5 的迭代步数 (64 步), 所用的缓冲区 (160 比特) 大于 MD5 使用的缓冲区 (128 比特), 因此在相同硬件上实现时, SH A 的速度要比 MD5 的速度慢。

(4)简洁与紧致性

两个算法描述起来都较为简单, 实现起来也较为简单, 都不需要大的程序和代换表。

(5)数据的存储方式

M D5 使用 little-endian 方式, SH A 使用 big-endian 方式。两种方式相比看不出哪个更具优势,之所以使用两种不同的存储方式是因为设计者最初实现各自的算法时, 使用的机器的存储方式不同。

6.4 算法的运行过程可描述如下:

(1) $\mathrm{K}$ 的左边填充 0 以产生一个 $\mathrm{b}$ 比特长的 $\mathrm{K}^{+}$(例如 $\mathrm{K}$ 的长为 160 比特, $\mathrm{b}=512$, 则需填充 44 个零字节 $0 \times 00)$;

(2) $\mathrm{K}^{+}$与 ipad 逐比特异或以产生 $\mathrm{b}$ 比特的分组 $\mathrm{S}_{\mathrm{i}}$;

(3) 将 $\mathrm{M}$ 链接到 $\mathrm{Si}_{\mathrm{i}}$ 后;

(4) 将 $\mathrm{H}$ 作用于步骤 (3) 产生的数据流;

(5) $\mathrm{K}^{+}$与 opad 逐比特异或, 以产生 $\mathrm{b}$ 比特长的分组 $\mathrm{S}_{0}$;

(6) 将步骤 (4) 得到的杂凑值链接在 $\mathrm{S}_{\mathrm{O}}$ 后;

(7) 将 $\mathrm{H}$ 作用于步骤 (6) 产生的数据流并输出最终结果。

6.5 数字签名 (Digital Signature) 可解决手写签名中的签名人否认签名或其他人伪造签名等问题。数字签名具有以下功能：

收方能够确认发方的签名,但不能伪造;

发方发出签过名的信息后,不能再否认;

收方对收到的签名信息也不能否认;

一旦收发方出现争执, 仲裁者可有充足的证据进行评判。

数字签名有基于公钥密码体制的数字签名、和基于私钥密码体制的数字签名。

6.6 (1) 全局公钥

$\mathrm{p}$ : 满足 $2^{\mathrm{L}-1}<_{\mathrm{p}}<2^{\mathrm{L}}$ 的大素数, 其中 $512 \leqslant \mathrm{~L} \leqslant 1024$ 且 $\mathrm{L}$ 是 64 的倍数;

$\mathrm{q}: \mathrm{p}-1$ 的素因子, 满足 $2^{159}<_{\mathrm{q}}<2^{160}$, 即 $\mathrm{q}$ 长为 160 比特;

$g: g \equiv h^{(p-1) / q} \bmod p$, 其中 $h$ 是满足 $1<h<p-1$ 且使得 $h^{(p-1) / q} \bmod p>1$ 的任一整数。

(2) 用户私钥 $\mathrm{x}$

$\mathrm{x}$ 是满足 $0<\mathrm{x}<_{\mathrm{q}}$ 的随机数或伪随机数。

(3) 用户公钥 $\mathrm{y}$

$\mathrm{y} \equiv \mathrm{g}^{\mathrm{x}} \bmod \mathrm{p}$ 。

(4)用户为待签消息选取的秘密数 $\mathrm{k}$

$\mathrm{k}$ 是满足 $0<_{\mathrm{k}}<_{\mathrm{q}}$ 的随机数或伪随机数。

(5)签名过程

用户对消息 M 的签名为 $(\mathrm{r}, \mathrm{s})$ ，

其中 $\mathrm{r} \equiv\left(\mathrm{g}^{\mathrm{k}} \bmod \mathrm{p}\right) \bmod \mathrm{q}, \mathrm{s} \equiv\left[\mathrm{k}^{-1}(\mathrm{H}(\mathrm{M})+\mathrm{xr})\right] \bmod \mathrm{q}, \mathrm{H}(\mathrm{M})$ 是由 $S H A$ 求出的杂凑值。

(6)验证过程

设接收方收到的消息为 $\mathrm{M}^{\prime}$, 签名为 $\left(\mathrm{r}^{\prime}, \mathrm{s}^{\prime}\right)$ 。计算

$\mathrm{w} \equiv\left(\mathrm{s}^{\prime}\right)^{-1} \bmod \mathrm{q}, \mathrm{ul} \equiv\left[\mathrm{H}\left(\mathrm{M}^{\prime}\right) \mathrm{w}\right] \bmod \mathrm{q}$

$\mathrm{u}_{2} \equiv \mathrm{r}^{\prime} \mathrm{w} \bmod \mathrm{q}, \mathrm{v} \equiv\left[\left(\mathrm{g}^{\mathrm{u}_{1}} \mathrm{y}^{\mathrm{u}_{2}}\right) \bmod \mathrm{p}\right] \bmod \mathrm{q}$

检查 $r$ 与 $r^{\prime}$ 是否相等, 若相等, 则认为签名有效。

6.7 请参照 6.6 进行计算与验证。

## 身份鉴别技术



## 教学要求

本章介绍数据鉴别技术的基本方法以及在 Internet 中常见的数据鉴别技术, 使学生能够理解和掌握各种数据鉴别技术。通过本章的学习, 了解数据鉴别的服务类型, 掌握数据鉴别的基本方法, 了解 Internet 中常见的数据鉴别技术,包括 KERBEROS 系统、GSSAPIv2。



## 7.0

## 鉴别概迷

网络安全系统一个很重要的要求是防止非法用户对系统的主动攻击, 如伪造信息、篡改信息等。这种安全要求对实际网络系统的应用如电子商务等是非常重要的。

鉴别 (Authentication) 也叫验证, 是防止主动攻击的一种重要技术。鉴别的目的是验明用户或信息的正身,就是验证用户身份的合法性和用户间传输信息的完整性与真实性。鉴别服务提供了关于某个实体身份的保证,所有其他的安全服务都依赖于该服务。鉴别是最重要的安全服务之一。

对实体声称的身份进行惟一识别,以便验证其访问请求,或保证信息来源以验证消息的完整性,有效地对抗冒充、非法访问和重放等威胁。按照鉴别对象的不同,鉴别技术可以分为消息鉴别和通信双方相互鉴别; 按照鉴别内容不同,鉴别技术可以分为用户身份鉴别和消息内容鉴别。鉴别的方法很多, 如利用鉴别码验证消息的完整性,利用通行字、密钥和访问控制机制等鉴别用户身份,防止冒充、非法访问;当今最佳的鉴别方法是数字签名。

## 7.1 . 1 实体鉴别和数据源发鉴别

鉴别用于一个特定的通信过程,即在此过程中需要提交实体的身份。基于不同的认证目的,鉴别还可分为实体鉴别和数据源发鉴别两种情形。

实体鉴别, 也称身份鉴别, 使某一实体确信与之打交道的实体正是所需要的实体。只是
简单地鉴别实体本身的身份, 不会和实体进行何种活动相联系。身份验证就是验证申请进人网络系统者是否是合法用户,以防非法用户访问系统。身份验证的方式一般有用户口令验证、摘要算法验证和基于 PKI (公钥基础设施)的验证等。验证、授权和访问控制都与网络实体安全有关。虽然用户身份只与验证有关,但很多情况下还要讨论授权和访问控制。授权和访问控制都是在验证成功之后进行的。

数据源发鉴别用于鉴定某个指定的数据是否来源于某个特定的实体。不是孤立地鉴别一个实体, 也不是为了允许实体执行下一步的操作而鉴别它的身份, 而是为了确定被鉴别的实体与一些特定数据项有着静态的不可分割的联系。报文鉴别是为了确保数据的完整性和真实性,对报文的来源、时间性及目的地进行验证。报文鉴别过程通常涉及到加密和密钥交换。加密可使用对称密钥加密、非对称密钥加密或两种加密方式的混合。

在实体鉴别中,身份由参与某次通信连接或会话的远程参与者提交。这种服务在连接建立或在数据传送阶段的某些时刻提供使用。使用这种服务可以确信一个实体在使用时间内没有试图冒充别的实体, 或没有试图将先前的连接作非授权地重演。

在数据源发鉴别中,身份和数据项一起被提交,并且声称数据项来源于身份所代表的主体。这种服务对数据单元的重复或篡改不提供保护。

数据源发鉴别为声称者的身份是特定数据项的来源提供了保障。它不同于实体鉴别: (1)声称者未必涉及当前的通信活动; (2) 数据项可能已经通过许多系统被重放, 这些系统可能或没有被鉴别; (3) 数据项可能在途中被存储相当的周期; (4) 与完整性有关的数据源发鉴别必须确保自从数据项离开它的信源没有被修改。然而, 数据源发鉴别未必能免遭数据项的复制、重排序或丢失。

## 数据原发鉴别的方法

(1)加密: 给数据项附加一个鉴别项,然后加密该结果;

(2)封装或数字签名;

(3) 实体鉴别扩展: 通过完整性机制将数据项和鉴别交换联系起来。

## 实体鉴别实现安全目标的方式

(1)作为访问控制服务的一种必要支持,访问控制服务的执行依赖于确定的身份, 即访问控制服务直接对达到机密性、完整性、可用性及合法使用的目标提供支持;

(2) 当它与数据完整性机制结合起来使用时, 作为提供数据起源认证的一种可能方法;

(3) 作为对责任原则的一种直接支持, 例如, 在审计追踪过程中记录时, 提供与某一活动相联系的确知身份。

## 实体鉴别分类

实体鉴别可以分为本地和远程两类。实体在本地环境的初始化鉴别是指作为实体个人和设备物理接触, 不和网络中的其他设备通信。远程鉴别是连接远程设备、实体和环境的实体鉴别。本地鉴别需要用户进行明确的操作, 而远程鉴别通常将本地鉴别结果传送到远程。

实体鉴别可以是单向的也可以是双向的。单向鉴别是指通信双方中只有一方对另一方进行鉴别。双向鉴别是指通信双方相互进行鉴别。

## 实体鉴别系统的组成

(1)一方是出示证件的人,称作示证者 P(Prover), 又称声称者 (Claimant)。

(2) 另一方为验证者 $\mathrm{V}$ ( V Verifier), 检验声称者提出的证件的正确性和合法性, 决定是否
满足要求。

(3)第三方是可信赖者 TP(Trusted third Party), 参与调解纠纷。

(4) 第四方是攻击者,可以窃听或伪装声称者骗取验证者的信任。

## 实体鉴别与消息鉴别的差别

(1) 实体鉴别一般都是实时的,消息鉴别一般不提供时间性。

(2) 实体鉴别只证实实体的身份,消息鉴别除了消息的合法和完整外,还需要知道消息的含义。

(3)数字签名是实现身份识别的有效途径。但在身份识别中消息的语义是基本固定的,一般不是“终生”的,签名是长期有效的。

## 对身份鉴别系统的要求

(1)不具有可传递性 (T ransferability);

(2)攻击者伪装成申请者欺骗验证者成功的概率要小到可以忽略的程度;

(3)计算有效性;

(4) 通信有效性;

(5) 秘密参数能安全存储;

(6) 交互识别;

(7)第三方的实时参与;

(8)第三方的可信赖性;

(9)可证明的安全性。

## 7.1 .2 单向散列函数

在现阶段,一般存在两个方向的加密方式:双向加密和单向加密。

双向加密是加密算法中最常用的, 它将我们可以理解的明文数据加密成不可理解的密文数据; 然后, 在需要的时候, 可以使用一定的算法和工具 (密钥) 将这些密文解密为原来的明文。双向加密适合于保密通信, 比如我们在网上购物的时候, 需要向网站提交信用卡密码。人们当然不希望自己的数据直接在网上明文传送, 因为这样很可能被别的用户“偷听”,而是希望自己的信用卡密码是通过加密以后再在网络传送。这样,网站接受到用户的数据以后,通过解密算法就可以得到准确的信用卡账号。

单向加密刚好相反, 只对数据进行加密而不进行解密, 即在加密后, 不能对加密后的数据进行解密, 或者也不用再加密。单向加密算法用于不需要对信息解密或读取的场合, 比如, 用来比较两个信息值是否一样而不需知道信息值是什么内容。这种单向加密算法在实际中的一个典型应用就是对数据库中的用户信息进行加密, 比如当用户创建一个新的账号及密码时, 先将这些信息经过单向加密后再保存到数据库中。再比如, 一台自动取款机 (ATM) 不需要解密一个消费者的个人标识数字 (PIN)。磁条卡将顾客的代码单向地加密成一段 Hash 值,一旦插人卡时, ATM 机将计算用户 PIN 的 Hash 值并产生一个结果, 然后再将这段结果与用户卡上的 Hash 值比较。使用这种方法, 即使对于那些管理和维护 A T M 机的人来说, PIN 也是安全的。

Hash 函数就是一类单向加密数据的函数,也叫单向散列函数。

目前已经提出许多不同的 Hash 函数,并且它们中的大部分被证明存在某种缺陷。在
开放式网络系统中使用的可靠的 Hash 函数有:

(1)基于分组密码算法的 Hash 函数;

(2)系列 Hash 函数 MD2、MD4 和 MD5 等。这些函数都产生 128 位的输出, MD5 (信息摘要算法) 就是一种优秀的单向加密的算法;

(3)美国政府的安全 Hash 标准(SHA-1)。SHA-1 是 MD4 的一个变形, 产生 160 位的输出,与 DSA (数字签名算法) 匹配使用。

Hash 函数除了可在数字签名中用来提高数字签名的有效性和分离保密与签名外, 还可用于认证、数据完整性测试和加密。

Hash 函数可用于产生信息摘要。信息摘要简要地描述了一份较长的信息或文件, 它可以被看作一份长文件的“数字指纹”。信息摘要用于创建数字签名, 对于特定的文件而言,信息摘要是惟一的。信息摘要可以被公开,它不会透露相应文件的任何内容。

Hash 函数提供了这样一种计算过程: 输人一个长度不固定的字符串, 返回一串固定长度的字符串, 又称 Hash 值。

Hash 函数主要可以解决以下两个问题: 在某一特定的时间内, 无法查找经 Hash 操作后生成特定 Hash 值的原报文; 也无法查找两个经 Hash 操作后生成相同 Hash 值的不同报文。这样,在数字签名中就可以解决签名验证、用户身份验证和不可抵赖性的问题。

2005 年 3 月 25 日文汇报发布了一条震惊世界的消息: 一直在国际上被广泛应用的两大密码算法 MD5 和 SHA-1, 最近被山东大学的王小云教授课题组破解。这一消息在国际社会尤其是国际密码学领域引起极大反响。



## 鉴别机制

鉴别机制主要有: 非密码的鉴别机制、基于密码算法的鉴别机制和零知识证明协议鉴别机制。基于密码算法的鉴别机制主要有:采用对称密码算法的机制、采用公开密码算法的机制和采用密码校验函数的机制。

## 7.2 .1 非密码的鉴别机制

非密码的鉴别机制主要包括:

(1)口令机制;

(2) 所有物机制;

(3)一次性口令机制;

(4)基于地址的机制;

(5)基于个人特征的机制;

(6) 个人鉴别令牌;

(7) 你做的事情 (如手写签名)。

## 口令机制

口令或通行字机制是最广泛研究和使用的身份鉴别法。

口令字的设置原理: 在信息系统中存放一张“用户信息表”, 它记录所有可以使用这个系
统的用户的有关信息,如用户名和口令字等。用户名是可以公开的,不同用户使用不同的用户名, 但口令字是秘密的。当一个用户要使用系统时, 必须键人自己的用户名和相应的口令字,系统通过查询用户信息表,验证用户输人的用户名和口令字与用户信息表中的是否一致,如果一致,该用户即是系统的合法用户,可进人系统,否则被挡在系统之外。

根据国家保密规定,处理秘密级信息的系统口令长度不得少于 8 位,且口令更换周期不得长于 30 天; 处理机密级信息的系统, 口令长度不得少于 10 位,且口令更换周期不得长于 7 天; 处理绝密级信息的系统,应当采用一次性口令。口令的组成应当是大小写英文字母、数字、特殊字符中两者以上的组合, 而且口令必须加密存储、加密传输, 并且保证口令存放载体的物理安全。口令的选取原则要求易记、难猜、抗分析能力强。

采用口令字进行身份鉴别, 成本低, 实现容易,但使用管理很不方便,不易记忆。

采用“智能卡十口令字”的方式进行身份鉴别, 其特点是, 口令字长度 4 位即可, 便于用户使用,增加了身份鉴别的安全性和可靠性,成本较高,一般涉密信息系统的身份鉴别多采用这种方式。

口令法最简单, 系统开销也小,但其安全性也最差。

口令系统有许多脆弱的对付外部泄露的措施: 教育、培训;严格限制非法登录的次数;口令验证中插人实时延迟; 限制点, 如外部泄露、口令猜测、线路窃听、危及验证者、重放等; 最小长度至少 6 8 字节以上; 防止用户特征相关口令; 定期改变; 及时更改预设口令; 使用机器产生的口令。

对付线路窃听的措施有:使用保护口令机制,如单向函数等。

声称者

声称者



图 7-1

口令机制主要缺陷及对策: (1)攻击者很容易构造一张 $p^{\prime}$ 与 $\mathrm{p}$ 对应的表, 表中的 $\mathrm{p}$ 尽最大可能包含所期望的值; (2) 随机串 (Salt) 是使这种攻击变得困难的一种办法; (3) 在口令后使用随机数; (4) 只能保护在多台计算机上使用相同口令或在同一计算机上使用同一口令的不同用户。

## 一次性口令机制

一次性口令机制确保在每次认证中所使用的口令不同,以对付重放攻击。

确定一次性口令的方法: (1)两端共同拥有一串随机口令, 在该串的某一位置保持同步; (2)两端共同使用一个随机序列生成器, 在该序列生成器的初态保持同步; (3) 使用时唯, 两端维持同步的时钟。

一次性口令机制的强度: (1) 没有器件而知道口令 $\mathrm{p}$, 不能导致一个简单的攻击; (2) 拥有器件而不知道口令 $\mathrm{p}$, 不能导致一个简单的攻击; (3) 除非攻击者也能进行时间同步, 否则重放不是一个简单的攻击; (4) 知道 $\mathrm{q}$ (例如通过浏览验证者系统文件) 而不知道设备安全值
$\mathrm{dsv}$, 不能导致一个简单的攻击。

## 所有 (Possesses) : 身份证、护照、信用卡和钥匙等

持证为个人持有物, 如钥匙、磁卡和智能卡等。它比口令法安全性好, 但验证系统比较复杂。磁卡常和 PIN 一起使用。

## 基于地址的机制

基于地址的机制假定声称者的可鉴别性是以呼叫的源地址为基础的。在大多数的数据网络中, 呼叫地址的辨别都是可行的。在不能可靠地辨别地址时, 可以用一个呼叫一回应设备来获得呼叫的源地址。一个验证者对每一个主体都保持一份合法呼叫地址的文件。这种机制最大的困难是在一个临时的环境里维持一个连续的主机和网络地址的联系。地址的转换频繁、呼叫一转发或重定向引起了一些主要问题。基于地址的机制自身不能被作为鉴别机制,但可作为其他机制的有用补充。

## 基于个人特征的机制

个人特征可以是指纹、笔迹、声纹、手形、血型、视网膜、DNA 以及个人动作方面的一些特征。

国家保密规定要求,绝密级信息系统的身份鉴别应采用这种强认证方式。

以个人特征进行验证时, 可有多种技术为验证机制提供支持, 如指纹识别、声音识别、血.型识别、手迹识别、手形、视网膜识别等。个人特征方法验证的成本高, 安全性最好, 但验证系统相应地也最复杂。这些技术的使用对网络安全协议不会有重要的影响。

## 个人鉴别令牌

物理特性用于支持认证 “某人拥有某东西”, 但通常要与一个口令或 PIN 结合使用。这种器件应具有存储功能, 通常有键盘、显示器等界面部件, 更复杂的能支持一次性口令, 甚至可嵌人处理器和自己的网络通信设备 (如智能卡)。这种器件通常还利用其他密码鉴别方法。

## 你做的事情(如手写签名)

设计依据可以是安全水平、系统通过率、用户可接受性和成本等。

## 7.2 .2 采用对称密码的鉴别机制

基于对称密码算法的鉴别依靠一定协议下的数据加密处理。通信双方共享一个密钥 (通常存储在硬件中) ,该密钥在询问——应答协议中处理或加密信息交换。

## 设计鉴别协议

鉴别和密钥交换协议的核心问题有两个: 保密和时效性。为了防止伪装和防止暴露会话密钥,基本鉴别与会话密码信息必须以保密形式通信。这就要求预先存在保密或公开密钥供实现加密使用。第二个问题也很重要,因为涉及防止消息重放攻击。

## (1)重放

常见的消息重放攻击形式有:1)简单重放: 攻击者简单复制一条消息,以后用重新发送它;2) 可被日志记录的复制品: 攻击者可以在一个合法有效的时间窗内重放一个带时间雀的消息;3)不能被检测到的复制品: 这种情况可能出现,原因是原始信息已经被拦截,无法到达目的地,而只有重放的信息到达目的地;4) 反向重放,不做修改: 向消息发送者重放。当采用传统对称加密方式时, 这种攻击是可能的。因为消息发送者不能简单地识别发送的消息和
收到的消息在内容上的区别。

对同一验证者的重放,可采用非重复值方法。针对不同验证者的重放,可采用验证者的标识符方法。

(2)非重复值的使用

非重复值的使用方法有:1)序列号, 即计数的策略: 对付重放攻击的一种方法是在认证交换中使用一个序数来给每一个消息报文编号。仅当收到的消息序数顺序合法时才接受。但这种方法的困难是要求双方必须保持上次消息的序号; 2) 时间唯：A 接受一个新消息仅当该消息包含一个时间截,该时间截在 A 看来,是足够接近 A 所知道的当前时间。这种方法要求不同参与者之间的时钟需要同步; 3)验证者发送随机值(如询问): 不可预测、不重复。

(3)时间翟

在网络环境中, 特别是在分布式网络环境中,时钟同步并不容易做到; 一旦时钟同步失败要么协议不能正常服务, 影响可用性 (Availability), 造成拒绝服务 (DoS); 要么放大时钟窗口,造成攻击的机会。时间窗大小的选择应根据消息的时效性来确定。

(4) 询问/应答方式 (Challenge/Response)

$A$ 期望从 $B$ 获得一个消息：

1) A 首先发给 B一个随机值( challenge);
2) B 收到这个值之后, 对它作某种变换,并送回去;
3) A 收到 B 的 response, 希望包含这个随机值。在有的协议中, 这个 challenge 也称为 nonce;
4) 可明文传输,也可能密文传输;
5) 这个条件可能是知道某个口令,也可能是其他的事情;
6) 变换的例子: 用密钥加密, 说明 B 知道这个密钥; 简单运算, 比如增一, 说明 B 知道这个随机值。

询问/应答方法不适应非连接性的应用, 因为它要求在传输开始之前先有握手的额外开销, 这就抵消了无连接通信的主要特点。

(5)相互鉴别协议

在理论上,相互鉴别可通过组合两个单向鉴别交换协议来实现。然而,这种组合需要被仔细地考察, 因为有可能这样的组合易受窃听重放攻击。另外, 设计协议消息数比相应的单向交换协议的消息数的两倍少得多的相互鉴别交换协议是可能的。因此,由于安全性和性能的原因,相互鉴别交换协议必须为此目的而特别地进行设计。

## 7.2 .3 采用公钥密码体制的鉴别机制

在该机制中, 声称者要通过证明他知道某秘密签名密钥来证实身份。由使用他的秘密签名密钥签署某一消息来完成。消息可包含一个非重复值以抵抗重放攻击。要求验证者有声称者的有效公钥,声称者有仅由自己知道和使用的秘密签名私钥。

### 7.3 Kerberos 系统

Kerberos 系统是美国麻省理工学院为 Athena 工程而设计的, 为分布式计算环境提供一种对用户双方进行身份验证的方法。它的安全机制在于首先对发出请求的用户进行身份验证, 确认其是否是合法的用户, 如果是合法的用户, 再审核该用户是否有权对他所请求的服务或主机进行访问。从加密算法上来讲, 其身份验证是建立在对称加密的基础上的。 Kerberos 是基于 KDC( Key Distribution Center) 概念和 Needham-schroeder 方法的分布式鉴别服务系统, 可在不安全网络环境中为用户远程访问提供自动鉴别、数据安全性、完整性及密钥管理服务。Kerberos 是一种适用于在公共网络上进行分布计算的工业标准的安全认证系统。

### 7.3.1 Kerberos 的认证方案

Kerberos 认证系统包括一系列的服务。除了客户工作站 Alice 以外, Kerberos 还包括三个服务器:

认证服务器 (AS), 用于在登录时验证用户的身份;

授予许可证服务器 (TGS), 发放“身份证明许可证”;

服务器 (Bob), Alice 请求工作的实际执行者。

其中, $\mathrm{AS}$ 与 KDC 类似,它与每个用户共享一个秘密口令。 $\mathrm{TGS}$ 的工作是发放许可证,用来使真正的服务器相信 TGS 许可证的持有人确实是它们所自称的本人。Kerberos 的工作模型如下:

(1) A $\rightarrow$ AS: A, TGS, $T_{\text {ExP }}, \mathrm{N}$

(2) $\mathrm{AS} \rightarrow \mathrm{A}_{\mathrm{A}}: \mathrm{K}_{A}\left[\mathrm{~K}_{\mathrm{s}}, \mathrm{TGS}, \mathrm{T}_{\mathrm{EXP}}, \mathrm{N}\right], \mathrm{K}_{\mathrm{Tgs}}\left[\mathrm{A}, \mathrm{K}_{\mathrm{s}}\right]$

(3) $\mathrm{A} \rightarrow \mathrm{TGS}_{\mathrm{F}}: \mathrm{K}_{s}[\mathrm{TS}], \mathrm{K}_{\mathrm{TGS}}\left[\mathrm{A}, \mathrm{K}_{s}\right], \mathrm{B}, \mathrm{T}_{\mathrm{EXP}}, \mathrm{N}$

(4) $\mathrm{TGS} \rightarrow \mathrm{A}: \mathrm{K}_{\mathrm{s}}\left[\mathrm{K}_{\mathrm{AB}}, \mathrm{B}, \mathrm{T}_{\mathrm{EXP}}, \mathrm{N}\right], \mathrm{K}_{B}\left[\mathrm{~A}, \mathrm{~K}_{\mathrm{AB}}\right]$

(5) $\mathrm{A} \rightarrow \mathrm{B}: \mathrm{K}_{A B}[\mathrm{TS}]$, Кв $_{B}\left[\mathrm{~A}, \mathrm{~K}_{\mathrm{AB}}\right]$

(6) $\mathrm{B} \rightarrow \mathrm{A}: \mathrm{K}_{\text {Ав }}[\mathrm{TS}+1]$

注: $T_{E X P}$ 是验证的最后时间期限; $N$ 是一个随机数; $K_{A}, K_{B}$ 分别为 $A, B$ 和 AS 所共享的密钥; $K_{T G S}$ 是 TGS 的密钥; $K_{A B}$ 是 $A$ 和 B 的会话密钥; $K_{s}$ 是 A 与 TGS 的共享密钥; TS 是 AS 盖的时间印隻。

其中, AS 签发的 TGS 许可证是 $K_{T G S}\left[A, K_{s}\right]$; 而 TGS 签发的服务许可证为 $K_{B}[A$, $\left.\mathrm{K}_{A B}\right]$ 。

为了开始一次对话, Alice 在任意一台工作站前坐下, 键人自己的名字。工作站把她的名字以明文形式传到 $\mathrm{AS}^{2}$ 。然后, 发回一个会话密钥和一个用于 TGS 的许可证 $\mathrm{K}_{\mathrm{TGS}}[\mathrm{A}$, $K_{s}$ ]。当第二条消息到达时, 工作站才向 Alice 要口令。该口令用来生成 $K_{A}$, 以便解密第二条消息, 得到会话密钥和 TGS 许可证。这时, 工作站覆盖 Alice 的密码, 以保证它在工作站内最多存在几毫秒。登录后, Alice 发送第三条消息给 TGS, 申请使用 Bob 的许可证。TGS 回送一个会话密钥 $K_{A B}$, 供 Alice 和 Bob 使用。现在, Alice 可以发送 $K_{A B}$ 给 Bob, 和他建立
一次对话。回答证明 Alice 确实在和 Bob 通话。

### 7.3.2 Kerberos 的局限性

Kerberos 的设计是与 MIT 校园环境结合的产物,把它推广到分布式系统存在一些局限性。

第一, 原有的认证很可能被存储或被替换, 虽然时间唯是专门用于防治重放攻击的, 但在许可证的有效时间内仍然可能奏效。假设在一个 Kerberos 服务域内的全部时钟保持同步,收到消息的时间在规定的范围内 (一般可以规定 $\mathrm{t}=5$ 分钟), 就认为该消息是新的。而事实上,攻击者可以事先把伪造的消息准备好,一旦得到许可证就马上发出,这在 5 分钟内是难以检查出来的。

第二,认证码的正确性是基于网络中所有的时钟保持同步,如果主机的事件发生错误,原来的认证码就是可以被替换的, 大多数网络的时间协议都是不安全的, 而在分布式系统中这将导致极为严重的问题。

第三,Kerberos 防止口令猜测攻击的能力很弱, 攻击者可以收集大量的许可证, 通过计算和密钥分析进行口令猜测。当用户选择的口令不够强时, 不能有效的防止口令猜测攻击。

第四, 实际上,最严重的攻击是恶意软件攻击。Kerberos 认证协议依赖于 Kerberos 软件的绝对可信, 而攻击者可以用执行 Kerberos 协议和记录用户口令的软件来代替所有用户的 Kerberos 软件, 达到攻击目的。一般而言, 装在不安全计算机内的密码软件都会面临这一问题。

另外, 在分布式系统中,认证中心星罗棋布, 域间会话密钥的数量惊人, 密钥的管理、分配和存储都是很严峻的问题。



## GSSAPIv 2

GSSAPI 是在分布式应用中提供安全服务的一种抽象界面, GSSAPI 的操作过程如下：调用者本身是一个通讯协议 (如SOCKS), 其接收由本地的 GSSAPI 实现所提供的 Token,并传送给远地的通讯方。对方将接收到的 Token 送给本地的 GSSAPI 处理, 在此过程中实现基于私有或公开密钥加密技术的安全服务。SOCKS 中 GSSAPI 鉴别过程主要有以下几个步骤:

(1) 建立 GSSAPI 安全上下文

1)用户安全上下文的建立: 用户调用 gss-init-sec-context( ) 获得送至服务器的 Context2level tokens 以建立和管理双方的安全上下文,并把本地 GSSAPI 产生的 output-token 发送给服务器。可请求双向鉴别、授权或保证通讯的有序性、防止重用等服务。

2) 服务器安全上下文的建立: 服务器接收用户发送的 Token, 作为 input2token 参数送给 gss-accept-sec-context（）处理,并与用户交互完成鉴别过程。

(2) 选择 GSSAPI 保护级别

用户 GSSAPI 实现发送其需要的安全上下文保护级别给服务器, 服务器通过安全性考虑将允许的级别返回用户。其中, 级别 1 为完整性服务; 级别 2 为完整性和可信任性服务;
级别 3 为根据用户和服务器的局部配置, 对每个信息分别选择完整性和可信任性服务。

(3) GSSAPI 封装用户数据

封装和解封装均由 gss- seal( )Pgss-wrap( )和 gss-unseal( )Pgss-unwrap( ) 完成。在 SOCKS 支持的 GSSAPI 鉴别方法中, 实现的是基于私有密钥的 Kerberos 鉴别, 双 TGT 和单 TGT 的 Kerberos 被视为 2 种不同的实现机制, 现分别简述如下:

### 7.4.1 单 TGT 的 Kerberos

用户登录时, 系统产生至本地 TGS 的 TGT, 该 TGT 即作为用户方 GSSAPI 实现的证书。用户调 gss-init-sec-context(), GSSAPI 的代码负责发出 KRB-TGS-REQ 请求及接收 KRBTGS-REP 应答。成功后, gss-init-sec-context ( )建立一个 Kerberos 格式的 KRB-APREQ 请求报文返回给用户, 用户再发送给服务器。若请求的服务不在同一域中, $g g_{s s-i n i t-}^{-}$ sec-context( ) 产生必要的 TGTPKey 对, 并将其从本地传到服务所在的远地域中。服务器把接收到的 Token 送给 gss- accept-sec-context( ), 经确认后正常返回。这样, 双方拥有与服务相关的会话密钥, 并用此密钥进行后续的 $\mathrm{gss}-\mathrm{sign}() 、 \mathrm{gss}-\mathrm{verify}() 、 \mathrm{gss}^{-} \mathrm{seal}\left(\right.$ ) 和 $\mathrm{gss}^{-}$ unseal( ) 操作。

### 7.4.2 双 TGT 的 Kerberos

TGT 的获得过程同上。gss-init-sec-context ( ) 返回 GSS-CON TINUE-NEEDED 状态码及 Token, 该 Token 中包含有至特定服务的 TGT 请求。服务器把接收到的 Token 传送给 gss-accept- context( ), 确认为一个 TGT 请求, 返回 GSSCON TIN UE-NEEDED 状态码, 并返回至特定服务的 TGT。用户接收到 Token 送给后继的 gss-init-sec-context ( ), 并将其存储在缓冲区中。然后, 用户方 GSSAPI 将此 Token 作为请求的一部分向 TGS 发出 KRB-TGS-REQ, 并在安全上下文中存储返回的至特定服务器的 Ticket 及会话密钥。gssinit-sec-context( ) 建立 Kerberos 的鉴别符连同 GSS-COMPLETE 状态码返回, 用户将产生的 Token 发给服务器。服务器接收 Token 送给 gss- accept-context ( ), 经鉴别后返回 GSS-COMPLETE。Gss-sign( ), gss-verify( ), gss-seal( ), gss-unseal( )的操作同上。

## 实验题

实验 7.1 Windows $2000 / \mathrm{XP}$ 中密码 (口令) 安全性的相关设置

要求: 掌握 Windows 2000/XP 中密码(口令)安全性的相关设置

## 习习题

7.1 鉴别分哪两种情形? 各有何用途?

7.2 鉴别机制主要有哪些?

7.3 何谓零知识证明技术?

7.4 鉴别与交换协议有哪些?

7.5 Kerberos 认证方案的工作原理是什么?

## 实验题参考答案

## 实验 7.1

Windows XP: 控制面板 $\rightarrow$ 性能和维护 $\rightarrow$ 管理工具 $\rightarrow$ 本地安全策略中的帐户策略的相关设置。



图 7-2

## 习题参考答案

7.1 鉴别用于一个特定的通信过程, 即在此过程中需要提交实体的身份。鉴别分为实体鉴别和数据源发鉴别两种情形。

实体鉴别 (身份鉴别) : 某一实体确信与之打交道的实体正是所需要的实体。只是简单地鉴别实体本身的身份, 不会和实体想要进行何种活动相联系。身份验证就是验证申请进人网络系统者是否是合法用户,以防非法用户访问系统。身份验证的方式一般有用户口令验证、摘要算法验证和基于 PKI(公钥基础设施)的验证等。验证、授权和访问控制都与网络实体安全有关。虽然用户身份只与验证有关,但很多情况下还要讨论授权和访问控制。授权和访问控制都是在成功的验证之后进行的。

数据源发鉴别: 鉴定某个指定的数据是否来源于某个特定的实体。不是孤立地鉴别一个实体, 也不是为了允许实体执行下一步的操作而鉴别它的身份, 而是为了确定被鉴别的实体与一些特定数据项有着静态的不可分割的联系。报文鉴别是为了确保数据的完整性和真实性,对报文的来源、时间性及目的地进行验证。报文鉴别过程通常涉及到加密和密钥交换。加密可使用对称密钥加密、非对称密钥加密或两种加密方式的混合。

7.2 鉴别机制主要有: 非密码的鉴别机制、基于密码算法的鉴别机制和零知识证明协议鉴别机制。基于密码算法的鉴别机制主要有:采用对称密码算法的机制、采用公开密码算法的机制和采用密码校验函数的机制。

7.3 零知识证明技术可使信息的拥有者无需泄露任何信息就能够向验证者或任何第三方证明他拥有该信息。在网络身份鉴别中,已经提出了零知识技术的一些变形, 例如 FFS 方案, FS 方案和 GQ 方案。一般情况下, 验证者颁布大量的询问给声称者, 声称者对每个询问计算一个回答, 而在计算中使用了秘密信息。大部分技术要求传输的数据量较大, 并且要求一个更复杂的协议,需要一些协议交换。

7.4 基于传统加密方法的双向鉴别与交换协议主要有: Needham/Schroeder Protocol [1978]、Denning Protocol[1982]和 KEHN92。

单向鉴别与交换协议:传统加密方法、公钥加密方法。

7.5 Kerberos 认证系统包括一系列的服务。除了客户工作站 Alice 以外, Kerberos 还包括三个服务器:

认证服务器 (AS), 用于在登录时验证用户的身份;

授予许可证服务器 (TGS),发放“身份证明许可证”;

服务器(Bob), Alice 请求工作的实际执行者。

其中, $\mathrm{AS}$ 与 $\mathrm{KDC}$ 类似,它与每个用户共享一个秘密口令。 $\mathrm{TGS}$ 的工作是发放许可证,用来使真正的服务器相信 TGS 许可证的持有人确实是他们所自称的本人。Kerberos 的工作模型如下:

(1) $\mathrm{A} \rightarrow \mathrm{AS}: \mathrm{A}, \mathrm{TGS}, \mathrm{T}_{\mathrm{EXP}}, \mathrm{N}$

(2) $\mathrm{AS} \rightarrow \mathrm{A}: \mathrm{K}_{A}\left[\mathrm{~K}_{s}, \mathrm{TGS}^{2}, \mathrm{~T}_{\text {EXp }}, \mathrm{N}\right], \mathrm{K}_{\mathrm{tgS}}\left[\mathrm{A}, \mathrm{K}_{s}\right]$

(3) $\mathrm{A}_{\rightarrow} \rightarrow \mathrm{TGS}_{\mathrm{C}} \mathrm{Ks}[\mathrm{TS}], \mathrm{K}_{\mathrm{tgs}}\left[\mathrm{A}, \mathrm{Ks}_{\mathrm{s}}\right], \mathrm{B}, \mathrm{T}_{\mathrm{Exp}}, \mathrm{N}$

(4) $\operatorname{TGS} \rightarrow \mathrm{A}: \mathrm{K}_{s}\left[\mathrm{~K}_{A B}, \mathrm{~B}, \mathrm{~T}_{\mathrm{Exp}}, \mathrm{N}\right], \mathrm{K}_{B}\left[\mathrm{~A}, \mathrm{~K}_{A B}\right]$

(5) $\mathrm{A} \rightarrow \mathrm{B}: \mathrm{K}_{A B}[\mathrm{TS}], \mathrm{K}_{B}\left[\mathrm{~A}, \mathrm{~K}_{A B}\right]$

(6) $\mathrm{B} \rightarrow \mathrm{A}: \mathrm{K}_{\mathrm{AB}}[\mathrm{TS}+1]$

## 第

## 访问控制及防火墙



教学要求

本章介绍单机和网络的访问控制问题, 使学生了解访问控制的基本原理和常用的防火墙技术。通过本章的学习, 理解主机的访问控制原理, 理解防火墙的工作原理与体系结构, 了解防火墙在不同网络层次的应用, 了解 SOCKS V5 协议的基本框架及常见的鉴别协议。

## 玢问控制的基本原理

访问控制服务的作用是保证只有被授权的用户才能访问网络和利用资源。访问控制的基本原理是检查用户标识及口令, 根据授予的权限限制其对资源利用的范围和程度。例如是否有权利用主机 CPU 运行程序, 是否有权对数据库进行查询和修改等等。访问控制服务通过访问控制机制实现。一般访问控制包括三种类型: 自主访问控制、强制访问控制和基于角色的访问控制。

## 1.自主访问控制

自主访问的含义是有访问许可的主体能够直接或间接地向其他主体转让访问权。自主访问控制是在确认主体身份以及(或)它们所属的组的基础上, 控制主体的活动, 实施用户权限管理、访问属性(读、写、执行)管理等,是一种最为普遍的访问控制手段。自主访问控制的主体可以按自己的意愿决定哪些用户可以访问他们的资源, 亦即主体有自主的决定权,一个主体可以有选择地与其他主体共享他的资源。

基于访问控制矩阵的访问控制表 (ACL)是自主访问控制中通常采用的一种安全机制。 ACL 是带有访问权限的矩阵, 这些访问权是授予主体访问某一客体的。安全管理员通过维护 ACL 控制用户访问企业数据。对每一个受保护的资源, ACL 对应一个个人用户列表或由个人用户构成的组列表, 表中规定了相应的访问模式。当用户数量多、管理数据量大时,由于访问控制的粒度是单个用户, ACL 会很庞大。当组织内的人员发生能变化(升迁、换
岗、招聘、离职) 和工作职能发生变化(新增业务)时, ACL 的修改变得异常困难。采用 ACL 机制管理授权处于一个较低级的层次,管理复杂、代价高以致于易出错。

自主访问控制的主要特征体现在主体可以自主地把自己所拥有的客体访问权限授予其他主体或者从其他主体收回所授予的权限, 访问通常基于访问控制表 (ACL)。访问控制的粒度是单个用户。没有存取权的用户只允许由授权用户指定对客体的访问权。自主访问控制的缺点是信息在移动过程中其访问权限关系会被改变。如用户 $\mathrm{A}$ 可将其对目标 0 的访问权限传递给用户 B, 从而使不具备对 O 有访问权限的 B 可访问 $\mathrm{O}$ 。

为了实现完备的自主访问控制系统, 由访问控制矩阵提供的信息必须以某种形式存放在系统中。访问矩阵中的每行表示一个主体, 每一列则表示一个受保护的客体, 而矩阵中的元素, 则表示主体可以对客体的访问模式。目前, 在系统中访问控制矩阵本身, 都不是完整地存储起来, 因为矩阵中的许多元素常常为空。空元素将会造成存储空间的浪费, 而且查找某个元素会耗费很多时间。实际上常常是用基于矩阵的行或列来表达访问控制信息。

(1)访问能力表

基于行的自主访问控制是在每个主体上都附加一个该主体可访问的客体的明细表, 也称为访问能力表。能力是一个提供给主体、对客体具有特定权限的不可伪造的标志。只有当一个主体对某个客体拥有准许访问的能力时, 它才能访问这个客体。

表 8-1

| $\mathrm{S}$ | $\mathrm{O}_{0} \mathrm{rwe}$ | $\mathrm{O}_{1} \mathrm{w}$ | $\mathrm{O}_{2} \mathrm{rw}$ | $\cdots$ |
| :---: | :---: | :---: | :---: | :---: |

表 8-1 举例说明了主体 S 的访问能力表。其中每一表项包括客体的标识和 S 对其的访问能力, 如表所示 $\mathrm{S}$ 是客体 $\mathrm{O}_{0}$ 的拥有者 (简写为 $\mathrm{o}$ ), 对它具有最大的访问能力 (读 $\mathrm{r}$, 写 $\mathrm{w}$,执行 e); $\mathrm{S}$ 对客体 $\mathrm{O}_{1}$ 只有写的能力, 对客体 $\mathrm{O}_{2}$ 有读和写的能力。

能力机制的最大特点是能力的拥有者可以在主体中转移能力, 具有转移或传播权限的主体 $\mathrm{A}$ 可以将其能力的副本传递给 $\mathrm{B}, \mathrm{B}$ 也可将能力传递给 $\mathrm{C}$, 但为了防止能力的进一步扩散, B 在传递能力副本给 $\mathrm{C}$ 时可移去其中的 “转移”权限, 于是 $\mathrm{C}$ 将不具有继续传递的能力。

能力的转移不受任何策略的限制, 因此对于一个特定的客体不能确定所有有权访问它的主体。所以访问能力表不能实现完备的自主访问控制, 利用访问能力表实现自主访问控制的系统不是很多, 其中只有少数系统试图增加其他的措施实现完备的自主访问控制。

(2)访问控制表

基于列的访问控制是指按客体附加一份可访问它的主体的明细表,也称作访问控制表,表中的每一项包括主体的身份以及对该客体的访问权。

访问控制表是目前采用最多的一种实现方式。访问控制表可以对某个特定资源指定任意一个用户的访问权限, 还可以将有相同权限的用户分组, 并授权组的访问权限。还可以用通配符“*”来代替任何组名或主体标识符。访问控制表的主体标识表示为 ID.GN, 其中 ID 是主体标识符, GN 是主体所在组的组名。

表 8-2

| 0 | Wang.CLASS rwe | *.CLASS rw | li. * r | $\cdots$ |
| :---: | :---: | :---: | :---: | :---: |

如表 8-2 的访问控制表中, 属于 CLASS 组的 Wang 用户对客体 O 有读、写、执行的权
限; 属于 CLASS 组的所有用户对客体 0 有读和写的权限, 无论哪一组的 li 用户对客体 0 都有读的权限。

访问控制表需对每个资源指定可以访问的用户或组以及相应的权限。当用户与资源数量很多时, ACL 将变的非常庞大。当用户调进/调出(如招聘、解聘)、用户工作岗位变化(如任免、升迁、定期换岗等)、用户工作职能变化 (如增加新业务) 时, 管理员需要修改用户对所有资源的访问权限, 所有这些, 使得访问控制的授权管理变得费力而烦琐, 且容易出错。

## 2.强制访问控制(MAC)

强制访问控制是“强加”给访问主体的,即系统强制主体服从访问控制策略。强制访问控制 (MAC) 的主要特征是对所有主体及其所控制的客体(例如: 进程、文件、段、设备)实施强制访问控制。

强制访问策略将每个用户及文件赋予一个访问级别, 如, 最高秘密级 (Top Secret), 秘密级 (Secret), 机密级 (Confidential) 及无密级 (U nclassified)。其级别为 $T>S>C>U$, 系统根据主体和客体的敏感标记来决定访问模式。例如 Bell-Lapadula 安全模型所制定的原则是利用不上读/不下写来保证数据的保密性。即不允许低信任级别的用户读高敏感度的信息,也不允许高敏感度的信息写人低敏感度区域,禁止信息从高级别流向低级别。而 Biba 安全模型所制定的原则是利用不下读/不上写来保证数据的完整性。在实际应用中, 完整性保护主要是为了避免应用程序修改某些重要的系统信息。

强制访问控制一般与自主访问控制结合使用,并且实施一些附加的、更强的访问限制。一个主体只有通过了自主与强制性访问限制检查后, 才能访问某个客体。用户可以利用自主访问控制来防范其他用户对自己客体的攻击, 由于用户不能直接改变强制访问控制属性,所以强制访问控制提供了一个不可逾越的、更强的安全保护层以防止其他用户偶然或故意地滥用自主访问控制。

## 3. 基于角色的访问控制

基于角色的访问控制模型 (RBAC Model, Role-based Access Model):RBAC 模型的基本思想是将访问权限分配给一定的角色,用户通过担任不同的角色获得角色所拥有的访问权限。这是因为在很多实际应用中,用户并不是可以访问 $\mathrm{Tt}$ 客体信息资源的所有者,例如客体信息资源属于企业或公司,访问控制应该基于员工的职务而不是基于员工是谁或在哪个组,即访问控制是由各个用户在部门中所担任的角色来确定的。例如,一个学校可以有教工、老师、学生和其他管理人员等角色。

RBAC 从控制主体的角度出发,根据管理中相对稳定的职权和责任来划分角色,将访问权限与角色相联系, 这点与传统的强制访问控制和将权限直接授予用户的自主访问控制方式不同。通过给用户分配合适的角色,让用户与访问权限相联系。角色成为访问控制中访问主体和受控对象之间的一座桥梁。一般模型如下:

(1)用户经过系统认证;

(2) 系统给通过认证的用户分派角色 (该角色被分配了一定的权限);

(3) 用户以该角色访问系统资源;

(4)访问控制机制检查角色的权限, 决定是否允许其访问。

角色可以看作是一组操作的集合, 不同的角色具有不同的操作集,这些操作集由系统管理员分配给角色。例如在学校的教务管理系统中,我们假设 $\mathrm{T} 1, \mathrm{~T} 2, \mathrm{~T} 3 \cdots \cdots \mathrm{Ti}$ 是对应的教
师, $\mathrm{S} 1, \mathrm{~S} 2, \mathrm{~S} 3 \cdots \mathrm{Sj}$ 是对应的学生, $\mathrm{M} 1, \mathrm{M} 2, \mathrm{M} 3 \cdots \mathrm{Mk}$ 是各系的教务管理人员, 那么老师的权限为 $T R=\{$ 查询班级课表、查询所教班级名单、查询其他相关信息、录人所教课程的成绩、打印所教课程的成绩清单 $\}$; 学生的权限为 $\mathrm{SR}=\{$ 查询自己的成绩、选课、反映意见 $\}$; 教务管理人员的权限为 $\mathrm{MR}=\{$ 查询、修改成绩、打印成绩清单、修改老师和学生的登录密码 $\}$ 。这样, 每个主体依据角色的不同, 只能执行自己特定的访问功能。用户在一定的部门中具有一定的角色,其所执行的操作与其所扮演的角色的职能相匹配。即: 依据 RBAC 策略,系统定义了各种角色, 每种角色可以完成一定的职能, 不同的用户根据其职能和责任被赋予相应的角色,一旦某个用户成为某角色的成员,则此用户可以完成该角色所具有的职能。

系统管理员负责授予用户各种角色的成员资格或撤消某用户具有的某个角色。同一个用户可以扮演多种角色, 比如一个用户可以是老师, 同时也可以作为进修的学生。同样,一个角色可以拥有多个用户成员, 这与现实是一致的,一个人可以在同一部门中担任多种职务, 而且担任相同职务的可能不止一人。RBAC 中引进了角色的概念, 用角色表示访问主体具有的职权和责任, 简化了权限设置的管理, 从这个角度看, RBAC 很好地解决了目前管理信息系统中用户数量多、变动频繁的问题。

相比较而言, RBAC 是实施面向企业安全策略的一种有效的访问控制方式, 具有灵活性、方便性和安全性的特点, 目前在大型数据库系统的权限管理中得到普遍应用。角色由系统管理员定义,角色成员的增减也只能由系统管理员来执行, 即只有系统管理员有权定义和分配角色。用户与客体无直接联系, 他只有通过角色才享有该角色所对应的权限, 从而访问相应的客体。因此用户不能自主地将访问权限授给别的用户，这是基于角色的访问控制与自主访问控制的根本区别所在。基于角色的访问控制与强制访问控制的区别在于: 强制访问控制是基于多级安全需求的,而基于角色的访问控制则不是。



### 8.2.1 Windows 2000 中的访河控制

## 1. Windows 2000 的安全模型

Windows 2000 的安全模型包括以下几个关键部分:

(1) Winlogon: Winlogon 主要负责管理用户登录和注销过程, 并加载 GINA DLL 监视安全认证的顺序。(2) 图形身份认证和验证动态链接库 (Graphical Identification And $\mathrm{Au}^{-}$ thentication DLL, GINA): GIN A DLL 为登录和登录请求提供接口。由 Winlogon 来监视安全认证的顺序并当一个登录请求发生时通知给 GINA。(3)本地安全授权 (Local Security Authority, LSA ): 本地安全授权是一个保护子系统, 主要负责加载所有的认证包,创建用户的访问令牌, 管理审计策略和设置等。(4) 安全引用监视器 (Security Reference Monitor SRM ): 检查存取合法性。(5) 安全帐户管理器 (Security Account Manager, SAM ): 在独立的 Windows 2000 计算机上负责保存用户账户名和口令的信息。它在文件\%systemroot\% $\%$ system $32 \backslash$ config \sam 中实现。(6) 安全支持供应商接口(Security Support Provider Interface, SSPI : 为应用程序和服务要求安全认证连接提供了解决方法。(7) 验证软件包 $\left(\mathrm{Au}^{-}\right.$
thentication Packages): 认证包的内容提供真正的用户验证。(8) 安全支持供应商(Security Support Providers): 支持额外的验证机制。(9) Netlogon 服务: 为认证建立安全通道。

以上各部分在访问控制的不同阶段发挥各自的作用。如图 8-1 为 Windows 2000 的安全模型。



图 8-1 Windows 2000 的安全模型

本地的 Windows 2000 安全子系统包括下列关键组件: 安全标识符、访问令牌、安全描述符、访问控制列表和访问控制条目。

(1)安全标识符 (SID): 分配给所有用户、组和计算机统计上的全局惟一的 48 位数字。为了保证 SID 的惟一性,在生成的时候结合计算机名、当前时间和当前用户态模式线程 CPU 耗费时间总量三个参数。SID 像这样：

S-1-5-21-1649288664-1549824960-1244863647-500

可以使用 whoami 这样的工具(包含在 Windows 2000 Resource Kit 中)来查看与登录会话相关的 SID。

(2)访问令牌:由用户的 SID、用户所属组的 SID 和用户名组成。

(3)安全描述符: 由对象所有者的 SID、POSIX 子系统使用的组 SID、访问控制列表和系统访问控制列表组成。

(4)访问控制条目 (Access Control Entry, ACE): 包含用户或组的 SID 和分配给对象的权限。

## 2. Windows 2000 登录认证过程

首先, Windows 2000 必须通过身份认证来确定自己是否在与合法的安全主体打交道。最简单的例子是通过控制台登录到 Windows 2000 的用户。用户按下标准的 CTRL+ALT + DEL 组合键以打开 Windows 2000 安全登录窗口, 然后输人账户名称和口令。安全登录窗口将输人的凭据传递给负责验证的用户模式组件。假设凭据是有效的, 本地安全授权 (LSA) 将创建一个访问令牌(包括用户 SID、用户所属组的 SID 和用户名), 并将之绑定到用户登录会话上,此后用户每新建一个进程, 都将访问令牌复制作为新进程的访问令牌。

当用户或用户生成的进程要访问资源时, 安全引用监视器 (SRM) 将利用访问令牌上的

SID 到安全描述符中查看系统访问控制表, 从而决定用户是否有权访问该资源。

### 8.2.2 Linux 中的访问控制

Linux 系统以文件方式访问设备和目录, 系统的访问控制方法非常简单, 它把用户分成四类: 根用户、文件的拥有者、组成员和其他用户。

(1) 根用户 (root): 在系统里具有最大的权力, 几乎可以控制整个系统, 单独享有很多重要的权限;

(2) 文件的拥有者 (owner): 一般可以读写执行文件, 比其他用户具有更高的权限, 多数情况下是文件的创建者,但并不完全如此;

(3)组(user group): 所有者所在组,一个用户可以同时在多个组中。组可以按不同的需求设定,便于设置访问权限;

(4)其他用户(other user): 不属于前三类的用户。

在 Linux 中, 主体对文件具有三种访问权限：

(1)读 (r):用户可以读文件;

(2) 写 (w):用户可以创建或修改文件;

(3)执行 (x): 用户可以运行可执行程序。

Linux 系统每个文件有 10 个标志位来表示访问权限 (Access Rights):

第 1 个标志: $\mathrm{d}$ (目录), $\mathrm{b}$ (块系统设备), $\mathrm{c}$ (字符设备), (普通文件)

第 $2 \sim 4$ 个标志:所有者的读、写、执行权限

第 5 7 个标志:所有者所在组的读、写、执行权限

第 8 10 个标志:其他用户的读、写、执行权限

用 $\mathrm{chmod}$ 命令修改权限: 可以用字符方式和数字方式来描述, 例如:

## $\$$ chmod 644 test

将目录 test 的权限修改为 644 , 即所有者具有读、写权限, 所有者所在组只有读的权限,其他用户只有读的权限。

Linux 系统权限管理不灵活, 只能对所有者、所有者所在组和其他用户分配权限, 无法做到进一步的细致化。POSIX ACLs for Linux 软件包, 可以做到用访问控制表来管理权限,但需要重新编译内核。

## 8.3

### 8.3.1 防火墙的概念

防火墙的本义是指古代构筑和使用木制结构房屋的时候,为防止火灾的发生和蔓延, 人们将坚固的石块堆砌在房屋周围作为屏障,这种防护构筑物就被称为“防火墙”。

我们通常所说的网络防火墙是借鉴了古代真正用于防火的防火墙的喻义, 它指的是隔离在本地网络与外界网络之间的一道防御系统。防火墙可以使企业内部局域网 (LAN)网络与 Internet 之间或者与其他外部网络互相隔离、限制网络互访, 用来保护内部网络。
典型的防火墙具有以下三个方面的基本特性:

(1) 内部网络和外部网络之间的所有网络数据流都必须经过防火墙;

(2) 只有符合安全策略的数据流才能通过防火墙;

(3) 防火墙自身应具有非常强的抗攻击免疫力。

### 8.3.2 防火墙的技术分类

## 1. 包过滤型防火墙

(1)静态包过滤

这种类型的防火墙其工作原理是根据定义好的过滤规则审查每个数据包, 以便确定其是否与某一条包过滤规则匹配。过滤规则基于数据包的报头信息进行制订。报头信息中包括 IP 源地址、IP 目标地址、传输协议( TCP、UDP 等)、TCP/UDP 源端口、目标端口等。一般说来,静态包过滤规则不保持前后连接信息, 过滤决定是根据当前数据包的内容。管理员可以设计一个可接受机器和服务的列表, 以及一个不可接受机器和服务的列表。在主机和网络一级,利用包过滤器很容易实现允许或禁止访问。

例如, 允许主机 A 和 B 之间的任何 IP 访问,或禁止除 A 以外的任何机器访问 B。

(2)动态包过滤

这种类型的防火墙采用动态设置包过滤规则的方法, 避免了静态包过滤所具有的问题。这种技术后来发展成为所谓包状态监测 (Stateful Inspection) 技术。采用这种技术的防火墙对通过其建立的每一个连接都进行跟踪, 提取相关的通信和状态信息, 并在动态连接表中进行状态及上下文信息的存储和更新。这些表被持续更新, 为下一个通信检查积累数据。这种类型的防火墙能够为基于无连接的协议的应用和基于端口动态分配的协议的应用提供安全支持, 减少了端口的开放时间。提供了几乎对所有服务的支持, 但它允许外部客户和内部主机的直接连接, 不提供用户的鉴别。

一般来说包过滤型防火墙有以下优点:

- 性能优于其他类型的防火墙, 因执行计算较少,容易硬件实现。
- 不需对客户端计算机进行专门配置。
- 通过 NAT，可以对外部屏蔽内部 IP。

包过滤型防火墙的缺点:

- 无法识别应用层协议。
- 处理包内信息的能力有限。
- 安全性较差, 存在安全隐患。


## 2. 应用层网关型防火墙

应用层网关 (Application Gateway) 防火墙是通过一种代理 (Proxy) 技术参与到一个 TCP 连接的全过程。应用层网关通常被配置为双宿主网关, 具有两个网络接口卡, 跨接内部网和外部网, 网关可以与两个网络通信, 因此是安装传递数据软件的理想位置。这种软件就称为代理,通常是为其所提供的服务制定的。

当代理服务器得到一个客户的连接意图时, 它们将核实客户请求, 并经过特定的安全化的 Proxy 应用程序处理连接请求, 将处理后的请求传递到真实的服务器上, 然后接受服务器应答, 并做进一步处理后, 将答复交给发出请求的最终客户。代理服务器在外部网络向内部
网络申请服务时发挥了中间转接的作用。代理服务器不允许直接连接, 而是强制检查和过滤所有的网络数据包, 用户的默认网关指向代理服务器, 用户并不直接与真正的服务器通信, 而是与代理服务器通信。

应用层网关防火墙最突出的优点就是安全。由于每一个内外网络之间的连接都要通过 Proxy 的介人和转换, 通过专门为特定的服务如 Http 编写的安全化的应用程序进行处理,然后由防火墙本身提交请求和应答,没有给内外网络的计算机以任何直接会话的机会, 从而避免了人侵者使用数据驱动类型的攻击方式入侵内部网。包过滤类型的防火墙是很难彻底避免这一漏洞的。应用层网关防火墙的最大缺点就是速度相对比较慢, 当用户对内外网络网关的吞吐量要求比较高时 (比如要求达到 $75 \sim 100 \mathrm{M}$ bp 时), 代理防火墙就会成为内外网络之间的瓶颈。所幸的是,目前用户接人 Internet 的速度一般都远低于这个数字。

## 3. 电路级网关防火墙

电路级网关防火墙是一个通用的代理服务器。

与应用层网关技术相比, 其优点是不需要对不同的应用设置不同的代理模块,但需要对客户端做适当修改。但具有资源占用大,速度慢的缺点。

电路级网关的实现典型是 SOCKS, 目前已发展到第 5 版, 支持多种认证协议。

SOCKS 的协议框架就是为了让使用 TCP 和 UDP 的客户/服务器应用程序更方便安全地使用网络防火墙所提供的服务所设计的。这个协议从概念上来讲是介于应用层和传输层之间的“中介层(shim-layer)”, 因而不提供如传递 ICMP 信息之类由网络层网关的所提供的服务。

SOCKS 4 为 TELNET、FTP、HTTP、WAIS 和 GOPHER 等基于 TCP 协议的客户/服务器程序提供了一个不安全的防火墙。而 SOCKS V5 协议扩展了 SOCKS V4, 以使其支持 UDP, 框架规定的安全认证方案、地址解析方案 (Addressing Scheme) 中所规定的域名和 IPV6。为了实现这个 SOCKS 协议, 通常需要重新编译或者重新链接基于 TCP 的客户端应用程序以使用 SOCKS 库中相应的加密函数。下文中, 除非特别注明, 所有出现在数据包格式图中的十进制数字均以字节表示相应域的长度。如果某域需要给定一个字节的值, 用 $\mathrm{X}$ ' $\mathrm{hh}$ '来表示这个字节中的值。如果某域中用到单词'Variable', 这表示该域的长度是可变的, 且该长度定义在一个和这个域相关联 ( $1 \sim 2$ 个字节) 的域中, 或一个数据类型域中。下面介绍 SOCKS V5 的结构。

## （1）基于 TCP 协议的客户

当一个基于 TCP 协议的客户端希望与一个只能通过防火墙可以到达的目标建立连接,它必须先建立一个与 SOCKS 服务器上 SOCKS 端口的 TCP 连接。通常这个 TCP 端口是 1080。当连接建立后, 客户端进人协议的 “协商 (negotiation)” 过程:认证方式的选择, 根据选中的方式进行认证, 然后发送转发的要求。SOCKS 服务器检查这个要求, 根据结果, 或建立合适的连接, 或拒绝。客户端连到服务器后, 然后就发送请求来协商版本和认证方法:

表 8-3

| VER | NMETHODS | METHODS |
| :---: | :---: | :---: |
| 1 | 1 | 1 to 255 |

在 SOCKS V5 协议中,VER 字段被设置成 X‘05’, 如表 8-3。NMETHODS 字段包含了在 METHODS 字段中出现的方法标识的数目 (以字节为单位)。服务器从这些给定的方法中选择一个并发送这个方法选中的消息回客户端,如表 8-4。

## 表 8-4

| VER | METHOD |
| :---: | :---: |
| 1 | 1 |

如果选中的消息是 X“FF，这表示客户端所列出的方法列表中没有一个方法被选中，客户端必须关闭连接。当前定义的方法有：

- $\mathrm{X}$ ‘ 00 ’ 不需要认证
- $\mathrm{X} \cdot 01$, GSSAPI
- X‘02，用户名/密码
- $\mathrm{X}^{`} 03^{\prime} \sim \mathrm{X}^{`} 7 \mathrm{~F}$, 由 IANA 分配
- $\mathrm{X}$ ‘ 80 , $~ X ' F E$ '为私人方法所保留的
- $\mathrm{X} ` F F$ ， 没有可以接受的方法

然后客户和服务器进人由选定认证方法所决定的子协商过程 (sub-negotiation)。各种不同的方法的子协商过程的描述请参考各自的备忘录。SOCKS V5 实现一般支持 GSSAPI,并且在将来支持用户名/密码认证方式。

请求

一旦子协商过程结束后, 客户端就发送详细的请求信息。如果协商的方法中有以完整性检查或安全性为目的的封装,这些请求必须按照该方法所定义的方式进行封装。

SOCKS 请求的格式如表 8-5:

表 8-5

| VER | CMD | RSV | ATYP | DST.ADDR | DST.PROT |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1 | 1 | $X^{\prime} 00^{`}$ | 1 | Variable | 2 |

其中

- VER 协议版本: X‘05,
- CMD

$\mathrm{X}^{\circ} 01$ ': CONNECT

$\mathrm{X}^{\circ} 02^{\prime}$ : BIND

- X‘03': UDP ASSOCIATE
- RSV 保留
- ATYP 后面的地址类型

○'01’:IPV 4

○ X“03”: 域名

- X‘04':IPV6
- DST.ADDR 目的地址
- DST.PORT 以网络字节顺序出现的端口号

SOCKS 服务器会根据源地址和目的地址来分析请求, 然后根据请求类型返回一个或多个应答。

## 地址

ATYP 字段中描述了地址字段 (DST. ADDR, BND. ADDR) 所包含的地址类型:



- $\mathrm{X}^{\circ} 03^{\prime}$ : 基于域名的地址, 地址字段中的第一字节是以字节为单位的该域名的长度,没有结尾的 NULL字节。
- $\mathrm{X}^{`} 04^{\prime}$ : 基于 IPV 6 的 IP 地址, 16 个字节长


## 应答

一旦建立了一个到 SOCKS 服务器的连接, 并且完成了认证方式的协商过程, 客户机将会发送一个 SOCKS 请求信息给服务器。服务器将会根据请求, 以表 8-6 格式返回:

表 8-6

| VER | REP | RSV | A TYP | BND . ADDR | BND .PORT |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 1 | 1 | $\mathrm{X} \cdot 00$, | 1 | Variable | 2 |

其中:

- VER 协议版本: X‘05，
- REP 应答字段:

$\circ \mathrm{X}^{\prime} 00^{\prime}$ 成功

○ $\mathrm{X}^{\circ} 01^{\prime}$ 普通的 SOCKS 服务器请求失败

$\circ \mathrm{X}^{\circ} 02$, 现有的规则不允许的连接

' X‘03, 网络不可达

- X‘04， 主机不可达
- $\mathrm{X}^{\circ} 05$, 连接被拒

○ X‘06， TTL 超时

$\circ \mathrm{X} \cdot 07$, 不支持的命令

- X`08，不支持的地址类型

○ $X^{\circ} 09^{\prime} \sim X^{\prime} F^{\prime}$ ’ 未定义

- RSV 保留
- ATYP 后面的地址类型
- X‘01’ IPV 4

○ $\mathrm{X}^{\circ} 03$, 域名

○ X‘04’ IPV 6

- BND. ADDR 服务器绑定的地址
- BND.PORT 以网络字节顺序表示的服务器绑定的端口

标识为 RSV 的字段必须设为 X‘00。

如果选中的方法中有以完整性检查或安全性为目的的封装, 这些应答必须按照该方法所定义的方式进行封装。

## CONNECT

在对一个 CONNECT 命令的应答中, BND. PORT 包含了服务器分配的用来连到目标机的端口号, BND. ADDR 则是相应的 IP 地址。由于 SOCKS 服务器通常有多个 IP, 应答中的 BND. ADDR 常和客户端连到 SOCKS 服务器的那个 IP 不同。SOCKS 服务器可以利用 DST. ADDR 和 DST.PORT, 以及客户端源地址和端口来对一个 CONNECT 请求进行分析。

BIND

BIND 请求通常被用在那些要求客户端接受来自服务器的连接的协议上。FTP 是一个典型的例子。它建立一个从客户端到服务器端的连接来执行命令以及接收状态的报告, 使用另一个从服务器到客户端的连接来接收传输数据的要求 (如 LS, GET, PUT)。建议只有在一个应用协议的客户端在使用 CONNECT 命令建立主连接后才可以使用 BIND 命令建立第二个连接。在一个 BIND 请求的操作过程中, SOCKS 服务器要发送两个应答给客户端。当服务器建立并绑定一个新的套接口时发送第一个应答。BND. PORT 字段包含 SOCKS 服务器用来监听进人的连接的端口号, BAND. ADDR 字段包含了对应的 IP 地址。客户端通常使用这些信息来告诉应用服务器连接的汇接点。第二个应答仅发生在所期望到来的连接成功或失败之后。在第二个应答中, BND.PORT 和 BND.ADDR 字段包含了连上来的主机的 IP 地址和端口号。

## UDP ASSOCIATE

UDP ASSOCIATE 请求通常是要求建立一个 UDP 转发进程来控制到来的 UDP 数据报。DST . ADDR 和 DST.PORT 字段包含客户端所希望的用来发送 UDP 数据报的 IP 地址和端口号。服务器可以使用这个信息来限制进人的连接。如果客户端在发送这个请求时没有地址和端口信息,客户端必须用全 0 来填充。当与 UDP 相应的 TCP 连接中断时, 该 UDP 连接也必须中断。应答 UDP ASSOCIATE 请求时, BND.PORT 和 BND. ADDR 字段指明了客户发送 UDP 消息至服务器的端口和地址。

## 应答处理

当一个应答 (REP 值不等于 00 ) 指明出错时, SOCKS 服务器必须在发送完应答消息后一小段时间内终止 TCP 连接。这段时间应该在发现错误后的 10 秒之内。如果一个应答 (REP 值等于 00 ) 指明成功, 并且请求是一个 BIND 或 CONNECT 时, 客户端就可以开始发送数据了。如果协商的认证方法中有以完整性、认证或安全性为目的的封装, 这些请求必须按照该方法所定义的方式进行封装。类似的, 当以客户机为目的地的数据到达 SOCKS 服务器时,SOCKS 服务器必须用正在使用的方法对这些数据进行封装。

（2）基于 UDP 协议的客户

在 UDP ASSOCIATE 应答中由 BND.PORT 指明了服务器所使用的 UDP 端口,一个基于 UDP 协议的客户必须发送数据报至 UDP 转发服务器的该端口上。如果协商的认证方法中有以完整性、认证或安全性为目的的封装, 这些数据报必须按照该方法所定义的方式进行封装。每个 UDP 数据报都有一个 UDP 请求头在其首部如表 8-7 所示:

表 8-7

| RSV | FRAG | ATYP | DST. ADDR | DST.PORT | DAT A |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 2 | 1 | 1 | Variable | 2 | Variable |

在 UDP 请求头中的字段是:

- RSV 保留 X‘0000，
- FRAG 当前的分段号
- ATYP 后面的地址类型

X'01':IPV4

${ }^{\circ} \mathrm{X}^{\circ} 03$ ’”: 域名

' X‘04':IPV6

- DST.ADDR 目的地址
- DST.PORT 以网络字节顺序出现的端口号
- DATA 用户数据

当一个 UDP 转发服务器转发一个 UDP 数据报时, 不会发送任何通知给客户端; 同样,它也将丢弃任何它不能发至远端主机的数据报。当UDP 转发服务器从远端服务器收到一个应答的数据报时, 必须加上上述 UDP 请求头, 并对数据报进行封装。UDP 转发服务器必须从 SOCKS 服务器得到期望的客户端 IP 地址, 并将数据报发送到 UDP ASSOCIATE 应答中给定的端口号。如果数据报从未知 IP 地址到来, 而该 IP 地址与该特定连接中指定的 IP 地址不同,那么该数据报会被丢弃。FRAG 字段指明数据报是否是一些分片中的一片。如果 SOCKS 服务器要实现这个功能, $\mathrm{X}^{\text {“ }} 00$, 指明数据报是独立的; 其他值越大则越是数据报的尾端。介于 1 到 127 之间的值说明了该分片在分片序列里的位置。每个接收者都为这些分片提供一个重组队列和一个重组的计时器。这个重组队列必须在重组计时器超时后重新初始化, 并丢弃相应的数据报。或者当一个新到达的数据报有一个比当前在处理的数据报序列中最大的 FRAG 值要小时, 也必须重新初始化从组队列。重组计时器必须小于 5 秒。只要有可能,应用程序最好不要使用分片。分片的实现是可选的; 如果某实现不支持分片, 所有 FRAG 字段不为 0 的数据报都必须被丢弃。一个 SOCKS 的 UDP 编程界面 (The programming interface for a SOCKS-aware UDP)必须报告当前可用 UDP 数据报缓存空间小于操作系统提供的实际空间。

- 如果 ATYP 是 X‘01’ - 10+ method_dependent octets smaller
- 如果 ATYP 是 X‘03, - 262+ method_dependent octets smaller
- 如果 ATYP 是 X“04' - 20+ method_dependent octets smaller

SOCKS 是一个用来透过 IP 网络防火墙的应用层协议。这种传输的安全性在很大程度上依赖于特定实现所拥有的以及在 SOCKS 客户与 SOCKS 服务器之间经协商所选定的特殊的认证和封装方式。系统管理员需要对用户认证方式的选择进行仔细考虑。

### 8.3.3防火墙的主要技术参数

## 1. 功能指标

网络接口: 防火墙所能保护的网络类型, 如以太网,快速以太网,千兆以太网等。

协议支持:一般支持 IP,IPX, Appletalk 等协议。

加密算法:DES,3DES, AES,IDEA 等

认证支持:RADIUS 认证,证书,口令方式认证。
访问控制:包过滤,时间等。

安全功能:病毒扫描, 内容过滤等。

管理功能:远程管理,本地管理等。

审计和报表: 审计分析的能力。

## 2. 性能指标

(1) 最大吞吐量: 在只有一条默认允许规则和不丢包的情况下能达到的最大吞吐率。

(2) 转送速率: 检查防火墙在通常安全规则发生作用的情况下, 能以多快的速度转送正常的网络通信量。

(3) 最大规则数: 检查在添加大量规则的情况下, 防火墙性能变化情况。

(4) 并发连接数: 单位时间内能建立起的最大 TCP 连接数,即每秒的连接数。

## 3. 安全指标

防火墙的安全指标包括人侵实时警告、实时人侵防范、抗攻击性要求和防火墙所采用操作系统的安全性。

### 8.3.4 防火墙基本体系结构

## 1 . 双宿/多宿主机模式

用一台装有两个或多个网络适配器的主机做防火墙。双宿主机用两个网络适配器分别连接两个网络, 又称堡垒主机。堡垒主机上运行着防火墙软件 (通常是代理服务器), 可以转发应用程序, 提供服务等。双宿主机网关有一个致命弱点, 一旦人侵者侵人堡垒主机并使该主机只具有路由器功能, 则防火墙失去作用, 任何网上用户均可以随便访问有保护的内部网络。如图 8-2 所示为双宿主机做防火墙的例子。



图 8-2 双宿主机防火墙

## 2.屏蔽子网模式

这种方法是在外网和内网之间建立一个被隔离的子网, 用两个包过滤路由器将这一子网分别与外网和内网分开。两个包过滤路由器放在子网的两端, 外网和内网均可访问屏蔽子网, 但禁止它们穿过屏蔽子网通信。可根据需要在屏蔽子网中安装堡垒主机, 为外网和内网的互相访问提供代理服务,但是来自两网络的访问都必须通过两个包过滤路由器的检查。对于向外网公开的服务器, 像 WWW、FTP、电子邮件等 Internet 服务器也可安装在屏蔽子网内。这样无论是外部用户, 还是内部用户都可访问。这种结构的防火墙安全性能高, 具有很强的抗攻击能力, 但需要的设备多, 造价高。如图 8-3 为屏蔽子网模式防火墙配置实例。

## 3. 屏蔽主机模式

屏蔽主机模式由包过滤路由器和堡垒主机组成。它又分为单宿堡垒主机和双宿堡垒主



图 8-3 屏蔽子网模式防火墙配置

机两种类型。单宿堡垒主机类型由一个包过滤路由器连接外部网络, 同时一个堡垒主机安装在内部网络上。堡垒主机只有一个网卡, 与内部网络连接。通常在路由器上设立过滤规则, 并使这个单宿堡垒主机成为外网惟一可以访问的主机, 确保了内部网络不受未被授权的外部攻击。而内网的客户机, 可以受控制地通过屏蔽主机和路由器访问 Internet。如图 8-4 为屏蔽主机模式防火墙配置。

双宿堡垒主机型与单宿堡垒主机型的区别是,堡垒主机有两块网卡,一块连接内部网络, 一块连接包过滤路由器。双宿堡垒主机在应用层提供代理服务, 与单宿型相比更加安全。



图 8-4 屏蔽主机模式防火墙配置

### 8.3.5 防火墙的部署

1.根据公司的安全性要求,将网络划分为若干安全区域;

2. 在安全区域之间设置针对网络通信的访问控制点;
3. 根据控制点制定边界安全策略, 采用合适的防火墙技术;
4. 配置对应的安全策略;

5 .测试;

6 . 运行和维护。

### 8.3.6 防火墙设置案例

## 1.天网防火墙个人版简介

天网防火墙个人版 SKYNET Personal Fire Wall(以下简称天网防火墙)是由天网安全实验室研发制作给个人计算机用户使用的。天网安全实验室自 1999 年推出天网防火墙个人版 $\mathrm{V} 1.0$ 后, 连续推出了 $\mathrm{V} 1.01 、 \mathrm{~V} 2.0 、 \mathrm{~V} 2.45 、 \mathrm{~V} 2.50 、 \mathrm{~V} 2.60$ 等更新版本。

天网防火墙是国内外针对个人用户最好的中文软件防火墙之一,可以拦截来历不明、有害、敌意访问或攻击行为。

## 2. 天网防火墙包过滤规则的设置

在防火墙的控制面板如图 8-5 所示,单击“IP 规则管理”按钮，即可打开防火墙 IP 规则管理面板。天网个人版防火墙 IP 规则设置界面如图 8-6。



图 8-5 天网防火墙控制面板



图8-6 IP 规则设置界面

实际上“天网防火墙个人版” 本身已经默认设置了相当好的缺省规则, 一般用户不需要做任何 IP 规则修改, 就可以直接使用。例如以下几项规则:
防御 ICMP 攻击: 防御 ICMP Flood 攻击程序的攻击, 该攻击会使被攻击机器崩溃。由于很难区分网上正常的 ICMP 数据包, 建议不要对该规则进行记录和警告。该规则不会影响对网络的使用。

防御 IGMP 攻击: IGM P 的用于组播的一种协议, 对于 MS Windows 的用户是没有什么用途的, 但现在也被用来作为 “蓝屏攻击” 的一种方法, 建议选择此设置, 不会对用户造成影响。

禁止互联网上的机器使用我的共享资源: 禁止互联网上的机器使用我的共享资源, 开启该规则后, 别人就不能访问你的共享资源, 包括获取你的机器名称。

允许已经授权程序打开的端口: 某些程序, 如 ICQ、视频电话等软件, 都会开放一些端口,这样,同伴才可以连接到机器上。本规则可以保证这些软件可以正常工作。

禁止所有人连接: 防止所有的机器和自己连接。这是一条非常严厉的规则, 有可能会影响使用某些软件。如果需要向外面公开特定端口, 请在本规则之前添加使该特定端口数据包可通行的规则。该规则通常放在最后。

允许 DNS (域名解释): 允许域名解释。注意, 如果要拒绝接受 UDP 包, 就一定要开启该规则 , 否则会无法访问互联网上的资源。

IP 规则是针对整个系统的网络层数据包监控而设置的。利用自定义 IP 规则, 用户可以针对个人不同的网络状态, 设置自己的 IP 安全规则, 使用防御手段更周到、更实用。用户可以单击“自定义 IP 规则”进人 IP 规则设置界面。

建立规则时, 要注意以下几点:

(1) 防火墙的规则检查顺序与列表顺序是一致的。

(2)当有局域网时,又只想对局域网开放某些端口或协议 (但对 Internet 关闭)时,可对局域网的规则采用允许“局域网网络地址”的某端口、协议的数据包“通行”的规则, 然后用 “任何地址”的某端口、协议的规则“拦截”,就可达到目的。

(3) 如果录人 IP 协议的规则, 一定要保证 IP 协议规则的最后一条的内容是: “对方地址 : 任何地址, 动作: 继续下一规则”, 否则其他协议的规则将会执行不到。

(4) 不要滥用 “记录” 功能, 一个定义不好的规则加上记录功能, 会产生大量没有任何意义的日志,并耗费大量的内存。

例如我们在计算机上建立了 WEB 服务器, 则必须在天网防火墙上设置一条自定义 IP 规则, 这样 Web 服务器才能正常运作。增加 IP 规则具体操作如下:

首先进人 IP 规则设置的操作界面, 然后单击按钮进人增加 IP 规则界面进行如下操作:

(1) 设定该 IP 规则的名称: 在 “名称” 中输人一个将要显示在 IP 规则列表中的名字, 建议在下方的“说明”中填写对该条规则的描述,这样可以防止以后忘记该规则的用途。

(2)设置数据包方向: 它包括有三个选项: “接受”、“发送”、“接受或发送”,选择“接受”就只允许接受数据包, 选择 “发送” 就只允许发送数据包, 这里的 IP 规则如果是关于 Web 服务器的我们就要选择“接受或发送”,因为它既可以接受数据包又可以发送数据包。

(3)设定对方 IP 地址: 这里可以选择“任何地址”这一项。

(4)定义协议类型: 在“数据包协议类型” 中选择 TCP 协议的, 在“本地端口”中输人“ “”和 “ 80 ”开放该端口。由于不限制对方使用何种端口进行连接, 所以可在“对方端口”中输人“ 0 ”。

(5)设置“当满足上面条件时”的操作:下拉菜单中选择“通行”。

这样我们就完成了新增加的 IP 规则,点击“保存规则”保存设置, 然后重启防火墙新的 IP 规则即可生效。不过我们还需要注意一定要把这条规则移动到

V 9 禁止所有人连接 $\mathrm{TCP}$ 任何之前, 这样规则就能正常使用, 如果没有移动到这条规则前, 该规则就会禁止所有人连接, Web 服务器的功能就起不到作用了。增加规则的过程如图 8-7 所示。

## 增加IP规则



数据包协议类型：TCP



图 8-7 增加 IP 规则

利用自定义 IP 规则也可以防止常见的木马,例如冰河木马使用的是 UDP 协议,默认的端口为 7626 。具体操作与上面的增加规则相同, 只是设置的内容不同。

天网防火墙也有防止木马的规则, 我们只要在导人规则中选择就能使用天网所设定好的规则, 具体操作如下:

首先进人 IP 规则设置的操作界面,然后单击导人规则按钮“窗, 就会弹出“选择规则”界面。选中文件 AdvIpRule 即可如图 8-8 所示。



图 8-8 选择规则

在图 8-9 中选择要导人的 IP 规则, 一般全选, 确定然后保存规则, 这些规则就会生效。



图 8-9 导人 IP 规则

### 8.3.7 Linux 内核防火墙

Linux 中实现包过滤功能的应用程序是 netfilter/iptables。netfilter/iptables 包含在 Linux 2.4 以后的内核中, 它可以实现防火墙、NAT (网络地址翻译) 和数据包的分割等功能。

netfilter 工作在内核内部, 而 iptables 则是让用户定义规则集的表结构。netfilter/iptables 从 ipchains 和 ipwadfm (IP 防火墙管理) 演化而来, 功能更加强大。netfilter 是通过 IPTables 工具来控制的。

下面介绍如何使用 IPTables 工具来实现防火墙的功能。

## 1. 启动和停止 iptables

在 Red Hat 9.0 中, 安装的版本是 iptables V 1.2.7a。如果系统没有安装 iptables, 则可以从 http://www.netfilter.org 下载。使用 IPTables 的第一步是启动 IPTables 服务。这可以使用以下命令进行：

\# service iptables start

## 2. 查看规则集

运行“man iptables”来查看所有命令和选项。运行“iptables--help”来查看快速帮助。要查看系统中现有的 iptables 规则集,可以运行以下命令:

\#iptables -L

下面是没有定义规则时的 iptables:

Chain INPUT (policy ACCEPT)

target prot opt source destination

Chain FORWARD (policy ACCEPT)

target prot opt source destination

Chain OUTPUT (policy ACCEPT)

target prot opt source destination

IPTables 的语法被分成几个层次。主要层次为“表”和“链”( chain)。

“表”有以下几个:

Filter:用来过滤数据包;

Nat: 用于 NAT, 即转换包的源或目标地址。实际的操作分为以下几类: DNAT, SNAT, MASQUERADE。

Mangle:使用 Mangle 匹配来改变包的 TOS 等特性, Mangle 表中仅有的几种操作: TOS,TTL,MARK。

其中 Filter 是最常用的表, 在 Filter 表中最常用的三个目标是 ACCEPT、DROP 和 REJECT。DROP 会丢弃数据包, 不再对其进行任何处理。REJECT 会把出错信息传送至发送数据包的主机。

“链”指定处理分组的状态。其用法为：

iptables $-t$ table - A chain $-\mathrm{j}$ target/jump

每一个数据包都要通过三条规则链: Input 链、Output 链和 Forward 链, 这些链是永久性的, 不能被删除。

Red Hat 9.0 提供一个 GUI 程序来让用户对系统的安装级别进行简单的配置。该工具的启动方法是：

“主菜单” $\rightarrow$ “系统设置” $\rightarrow$ “安全级别设置”。在此选择启用防火墙。点击“确定”后, 再用 iptables - L 显示,会发现 iptables 与没有定义规则前已经有很大不同。

## 3.增加规则

本例中的规则将会阻止来自某一特定 IP 范围内的数据包, 因为该 IP 地址范围被管理员怀疑有大量恶意攻击者在活动：

\# iptables -A INPUT -s 219.222.89.0/24-j DROP

也可以很轻易地阻止所有流向攻击者 IP 地址的数据包,该命令稍有不同:

\# iptables -A OUTPUT -d 219.222.89.0/24 -j DROP

注意这里的 $-\mathrm{A}$ 选项,使用它说明是给现有的链添加规则。

在创建 IPTables 规则集合时,记住规则的顺序是至关重要的。例如: 如果某个链指定了来自本地子网 192.168.1.0/24 的任何分组都应放弃, 然后一个允许来自 192.168.1.3

(在前面要放弃分组的子网范围内)的分组的链被补在这个规则后面 (-A), 那么这个后补的规则就会被忽略。你必须首先设置允许 192.168.1.3 的规则, 然后再设置放弃规则。

要在现存规则链的任意处插人一条规则, 使用 “- $\mathrm{I}$ ”, 后面是将要插人规则的链的名称,然后是要放置规则的位置号码 $(1,2,3, \ldots, n)$ 。例如:

iptables -I INPU T 1 -i lo -p all -j ACCEPT 这条规则被插人为 “INPU T” 链的第一条规则。

## 4 . 删除规则

网络上的恶意攻击者总是在变化的, 因此需要不断改变 IP。假设一个网上攻击者转移到新的 IP 地址, 而原来的 IP 地址被分配给一些清白的用户, 那么这时这些用户的数据包将无法通过你的网络。这种情况下,可以使用带“-D”选项的命令来删除现有的规则:

\# iptables-D OUTPUT -d 219.222.89.0/24 -j DROP

## 5. 缺省的策略

创建一个具有很好灵活性、可以抵御各种意外事件的规则需要大量的时间。对于那些没有时间这样做的人, 最基本的原则是 “先拒绝所有的数据包, 然后再允许需要的”。为每一个链设置缺省的规则:

\# iptables-P INPUT DROP

\# iptables-P FORWARD DROP

\# iptables-P OUTPUT ACCEPT

这里选项“-P”用于设置链的策略, 只有三个内建的链才有策略。上面这些策略可以让信息毫无限制地流出,但不允许信息流人。

## 6. 有状态的数据包的检测

iptables 会检查数据包的源和目的 IP 地址、源和目的端口、流人数据包的顺序号、TCP 先后顺序的信息及头标记 (SYN、ACK、FIN、RST 等)的状态, 即它会跟踪整个连接会话, 从而使整个过滤过程是相互关联的。

\# iptables-A INPUT -p tcp--tcp-flags ALL SYN, ACK

表示 ALL(SYN, ACK, FIN, RST, USG, PSH) 的标志都要检查, 但是只有设置了 SYN 和 ACK 的才匹配。

## 7 . 规则的保存

防火墙规则只在计算机处于开启状态时才有效。如果系统被重新引导, 这些规则就会自动被清除并重设。要保存规则以便今后载人, 请使用以下命令:

“service iptables save”。保存在 “/etc/sysconfig/iptables” 文件中的规则会在服务启动或重新启动时(包括机器被重新引导时)被应用。或用“iptables-save > /etc/sysconfig/ iptables”生成保存规则的文件 “/etc/sysconfig/iptables”。

例如使用 iptables 设置 WWW 包过滤, 禁止访问防火墙上的 80 端口:

iptables -I INPUT -p tcp --dport 80 -j DROP

在网卡 eth0 上阻塞 ICMP:

iptables -I INPUT 1 -i eth0 - p icmp -s $0 / 0$-d $0 / 0$-j DROP

## 实验题

实验 8.1 天网个人版防火墙的设置

一、实验目的

完成对天网个人版防火墙的设置, 加深对访问控制规则的理解。

二、实验环境

1. WIN 2000 系统, Internet 网络

2.天网个人版防火墙安装软件

三、实验内容

1.安装软件;

2. 进行系统设置;
3. 进行应用程序规则设置;
4. 进行 IP 规则设置, 自定义 IP 规则;

5 . 进行安全级别设置;

6 . 进行在线升级。

## 实验 8.2 Linux 防火墙软件 IPTables 的安装和使用

一、实验目的

学习在 Linux 下使用 iptables 命令添加规则, 配置个人防火墙。

二、实验环境

装有 WIN 2000 SERVER 的系统, 能够使用 vmware 运行 Linux 系统。或者安装了 Linux 系统的计算机, 网络连通。

三、实验内容

1.检查是否安装了 IPTables;

2. 启动 IPTables 服务。要使 IPTables 在系统引导时默认启动, 你必须使用 “chkconfig”来改变服务的运行级别状态;

3 .练习 iptables 的常用命令;

4. 在 Linux 系统配置 iptables 规则:

(1)阻塞 ICMP;

(2)阻塞 FTP;

(3)阻塞 HTTP 禁止访问防火墙上的 80 端口。

## 习 题

8.1 访问控制机制有哪几类?

8.2 基于角色的访问控制机制有什么优点?

8.3 防火墙的技术参数有哪些?

8.4 Linux 系统每个文件的访问权限是如何表示的?

## 实验题参考答案

## 实验 8.1

1 .安装软件;

可下载最新版本天网个人版防火墙软件进行安装。

2.进行系统设置;

在图 8-5 所示的控制面板上点击 “系统设置” 按钮, 即可进行基本设置、管理权限设置、在线升级设置、日志管理和人侵检测设置。

3 . 进行应用程序规则设置;

在图 8-5 所示的控制面板上点击 “应用程序规则设置”按钮,可以进行应用程序访问网络权限设置, 可以进行增加规则、删除规则、导人导出规则等操作。

4. 进行 IP 规则设置, 自定义 IP 规则;

在图 8-5 所示的控制面板上点击 “IP 规则设置”按钮, 可进行增加规则、删除规则、导人导出规则等操作。

5 . 进行安全级别设置;

在图 8-5 所示的控制面板上安全级别处点击相应的级别按钮即可。

6 . 在图 8-5 控制面板上点击“在线升级”按钮。

## 实验 8.2

1 .检查是否安装了 IPTables。

命令: rpm -qa $\mid$ grep iptab

2. 启动 IPTables 服务。这可以使用以下命令进行:

service iptables start

要使 IPTables 在系统引导时默认启动, 你必须使用 “chkconfig” 来改变服务的运行级别状态:

chkconfig--level 235 iptables on

3 .iptables - $\mathrm{L}$

(1) 清除预设表 filter 中所有规则链中的规则 \# iptables - F

（2）清除预设表 filter 中使用者自定链中的规则 \# iptables - X

(3) 将指定链中所有规则的包字节计数器清零 \# iptables - Z

4. 在 Linux 系统下配置 iptables 规则:

(1)阻塞 ICMP :

iptables -I INPUT 1 -i eth0 -p icmp -s 0/0 -d 0/0 -j DROP

验证: 通过“ping”命令验证, 将收到“request time out”的数据。

(注意如果验证没有成功则首先使用命令

“iptables -F” 清除预设表 Filter 中所有规则链中的规则)

验证通过后使用下面的命令删除该规则：

iptables-D INPUT 1

iptables - $\mathrm{L}$ (再显示查看)

将命令改为:
iptables -I INPU T 1 -i eth0 -p icmp -s 0/0 -d 0/0 -j REJECT

验证结果有何不同。

(2)阻塞 FTP:

使用命令：

iptables -I INPUT -i eth0 -p tcp -s 0/0 -d 0/0 --dport 21 -j DROP

验证:

启动 vsftpd, 登录 FTP 服务器, 返回连接超时。

(3) 阻塞 HTTP 禁止访问防火墙上的 80 端口:

iptables -I INPUT -p tcp --dport 80 -j DROP

启动 httpd 服务, 验证是否能登录。

## 习题参考答案

8.1 一般访问控制包括三种类型: 自主访问控制、强制访问控制和基于角色的访问控制。

$8.2 \mathrm{RBAC}$ 是面向企业安全策略实施的一种有效的访问控制方式, 具有灵活性、方便性和安全性的特点。目前在大型数据库系统的权限管理中得到普遍应用。角色由系统管理员定义, 角色成员的增减也只能由系统管理员来执行, 即只有系统管理员有权定义和分配角色。

## 8.3

1. 功能指标:

网络接口、协议支持、加密算法、认证支持、访问控制、安全功能、管理功能、审计和报表

2 . 性能指标:

最大吞吐量、最大规则数和并发连接数。

3. 安全指标: 人侵实时警告、实时人侵防范、抗攻击性要求、防火墙所采用操作系统的安全性。

8.4 Linux 系统每个文件有 10 个标志位来表示访问权限 (Access Rights):

第 1 个标志: $\mathrm{d}$ (目录), $\mathrm{b}$ (块系统设备), $\mathrm{c}$ (字符设备), .(普通文件)

第 $2 \sim 4$ 个标志:所有者的读、写、执行权限

第 5 7 个标志: 所有者所在组的读、写、执行权限

第 8 10 个标志: 其他用户的读、写、执行权限

## 第

## 计算机病毒与防御



计算机病毒的主要特性、种类、查杀与防范方法等。

## 本章重点与难点

掌握计算机病毒的概念, 了解计算机病毒的发展史与危害, 熟悉计算机病毒的主要特性,掌握计算机病毒的分类、查杀与防范方法。

## 教学要求



据中国互联网络信息中心 (CNNIC)发布的《第 20 次中国互联网络发展状况统计报告》显示, 截止 2007 年 6 月 30 日, 我国网民人数达到了 1.62 亿, 位居世界第二。网民们对互联网上最反感的方面是网络病毒 $(29 \%)$ 和网络人侵/攻击 $(17.2 \%)$ 。在这一章, 我们将学习计算机病毒的基本原理和如何预防与杀除计算机病毒。



### 9.1.1 计算机病毒的定义

什么是计算机病毒?

《中华人民共和国计算机信息系统安全保护条例》明确定义:“计算机病毒是指编制或者在计算机程序中插人的破坏计算机功能或者破坏数据, 影响计算机使用并且能够自我复制的一组计算机指令或者程序代码。”

在计算机病毒定义中,我们应重点理解和掌握计算机病毒是能够复制的、具有破坏性的程序代码。

计算机病毒是一段程序代码, 这个代码一定是人为编写的。

这里请同学们思考和讨论一下, 不按正常步骤操作计算机、玩游戏、上网和收发邮件, 这些行为会产生计算机病毒吗?
正确的回答是不会产生病毒的。

不按正常步骤操作计算机有可能损坏计算机系统,但这不是病毒所为。

玩游戏、上网和收发邮件这些操作有可能感染病毒, 但不会产生病毒。

所以同学们一定要分清产生病毒和感染病毒是完全不同的概念, 不要混淆。

计算机病毒程序能够自动的实现复制。这个复制可以是在本机中复制, 也可以通过网络系统在不同的主机间自动复制。

传统病毒往往是在本地计算机上不同的磁盘等存储设备间进行复制, 如从硬盘或内存复制到软盘;而网络病毒则利用网络系统在整个网络环境中实现自我复制。

从广义上讲,一些恶意程序虽然不能自我复制, 但会对计算机系统产生破坏或严重损害计算机使用者的利益, 这些程序往往也被归类为计算机病毒, 如木马程序等。

所有计算机病毒都有破坏性。

有些计算机病毒直接对计算机系统或数据进行破坏, 如破坏磁盘文件、使计算机系统异常死机等,这些病毒被称为恶性病毒。

有些病毒不直接对计算机系统产生破坏, 仅仅是偶尔表现一下自己,甚至会给计算机使用者带来愉悦的心情, 如送上一句问候语、播放一段动听的音乐等, 这些不直接产生破坏的计算机病毒被称为良性病毒。良性病毒有破坏性吗? 有! 良性病毒虽然不直接破坏计算机系统和数据, 但是它在未经允许的情况下侵占了用户的磁盘空间、内存资源和 CPU 资源,这些都是对用户合法权益的侵害。所以说,一切计算机病毒都具有破坏性。

## 9.1 . 2 计算机病毒的发展史

最早提出电脑病毒概念的是冯 - 诺伊曼。在他的一篇论文《复杂自动装置的理论及组识的进行》里, 勾勒出病毒程序自我繁殖的基本原理。不过在当时, 绝大部分的电脑专家都无法想像会有这种能自我繁殖的程序。

其后很多年,以计算机程序为武器的科幻小说多次描写了类似病毒的程序在战争中给人类带来巨大的灾难。但这些程序仅出现在文学作品中, 并没有真正实现。

第一次验证了计算机病毒存在的可能性是在 1983 年 11 月, 美国电脑专家弗雷德・科恩博士研制出一种在运行过程中可以复制自身的破坏性程序, 将它命名为计算机病毒,并在每周一次的计算机安全讨论会上正式提出。之后专家们在 VAX11/750 计算机系统上运行, 第一个病毒实验成功。但这个病毒程序仅存在于实验室, 证明计算机病毒是可以被制造出来的,但其并没有对外扩散。

第一个真正的电脑病毒诞生于 1987 年。

这个病毒程序是由一对巴基斯坦兄弟巴斯特和阿姆捷特所写。此兄弟二人在当地经营一家个人电脑的商店, 由于当地盗拷软件的风气盛行, 他们为了防止他们的软件被任意盗拷, 编写出一个特殊的程序: 只要有人盗拷他们的软件, 这个程序就会发作, 将盗拷者的硬盘剩余空间吃掉。这个程序命名为 Pakistani Brain(巴基斯坦大脑),被公认为是世界上第一个计算机病毒,这个病毒在其后的一年时间里扩散到世界各地。

计算机病毒的发展阶段:

## 1.第一代病毒

第一代病毒的产生年代通常认为在 1986 1989 年之间,这一期间出现的病毒称之为传
统病毒, 是计算机病毒的萌芽和滋生时期。

此时计算机的应用软件少, 而且大多是单机运行环境, 因此病毒没有大量流行, 流行病毒的种类也很有限, 病毒的清除工作相对来说较容易。这一阶段的计算机病毒具有如下的一些特点:

(1)病毒攻击的目标比较单一, 有些感染磁盘引导扇区, 有些感染可执行文件。

(2) 病毒程序主要采取截获系统中断向量的方式监视系统的运行状态, 并在一定的条件下对目标进行感染。

(3)病毒感染目标以后的特征比较明显, 如磁盘上出现坏扇区, 可执行文件的长度增加、文件建立的日期和时间发生变化等等。这些特征容易被人工或查毒软件所发现。

(4) 病毒程序不具有自我保护的措施, 容易被人们分析和解剖, 从而使得人们容易编制相应的杀毒软件。

然而随着计算机反病毒技术的提高和反病毒产品的不断涌现, 病毒编制者也在不断地总结自己的编程技巧和经验, 千方百计地逃避反病毒产品的分析、检测和杀毒, 从而出现了第二代计算机病毒。

## 2. 第二代病毒

第二代病毒又称为混合型病毒, 其产生的年代在 1989 1991 年之间, 它是计算机病毒由简单发展到复杂, 由单纯走向成熟的阶段。

(1) 病毒攻击的目标趋于混合型, 即一种病毒既可感染磁盘引导扇区, 又可感染可执行文件。

(2) 病毒程序不采用明显地截获中断向量的方法监视系统的运行, 而采取更为隐蔽的方法驻留内存和感染目标。

(3) 病毒传染目标后没有明显的特征, 如磁盘上不出现坏扇区, 可执行文件的长度增加不明显,不改变被感染文件原来的建立日期和时间等等。

(4) 病毒程序往往采取了自我保护措施, 如加密技术、反跟踪技术, 制造各种障碍, 增加人们剖析病毒的难度,也增加了病毒的发现与杀除难度。

(5)出现许多病毒的变种,这些变种病毒较原病毒的传染性更隐蔽,破坏性更大。

总之, 这一时期出现的病毒不仅在数量上急剧地增加, 更重要的是病毒从编制的方式、方法到驻留内存以及对宿主程序的传染方式、方法等方面都有了较大的变化。

## 3. 第三代病毒

第三代病毒的产生是从 1992 年开始至 1995 年,此类病毒称为“多态性”病毒或“自我变形”病毒。所谓“多态性”或“自我变形”的含义是指此类病毒在每次传染目标时, 侵人宿主程序中的病毒程序大部分都是可变的, 即在收集到同一种病毒的多个样本中, 病毒程序的代码绝大多数是不同的, 这是此类病毒的重要特点。正是由于这一特点, 传统的利用特征码法检测病毒的产品很难检测出此类病毒。

## 4. 第四代病毒

20 世纪 90 年代中后期, 随着因特网、远程访问服务的开通, 病毒流行面更加广泛, 病毒的流行迅速突破地域的限制, 首先通过广域网传播至局域网内,再在局域网内传播扩散。

随着因特网的普及, 电子邮件的使用, 以及 Office 系列办公软件被广泛应用, 夹杂于电子邮件内的 Office 宏病毒成为当时病毒的主流。由于宏病毒编写简单、破坏性强和清除繁
杂, 加上微软对文档结构没有公开, 给直接基于文档结构的宏病毒清除带来了诸多不便。

这一时期的病毒的最大特点是利用 Internet 作为其主要传播途径, 传播对象从传统的引导型和依附于可执行程序文件而转向流通性更强的文档文件中。因而, 病毒传播快, 隐蔽性强、破坏性大。这些都给病毒防治带来新的挑战。

## 5. 新一代病毒

人类历史进人 21 世纪以来,互联网渗人每一户人家,网络成为人们日常生活和工作的不可缺少的一部分。一个曾经未被人们重视的病毒种类遇到适合的滋生环境而迅速蔓延,这就是蠕虫病毒。

蠕虫病毒是一种利用网络服务漏洞而主动攻击的计算机病毒类型。与传统病毒不同,蠕虫不依附在其他文件或媒介上, 而是独立存在的病毒程序, 利用系统的漏洞通过网络主动传播, 可在瞬间传遍全世界。

蠕虫已成为目前病毒的主流。

### 9.1.3 计算机病毒的危害

美国 Techweb 网站评出了 20 年来,破坏力最大的 10 种计算机病毒,可以看到这些病毒给人类社会的发展带来了巨大的经济损失。

## 1. CIH (1998 年)

该计算机病毒存在于 Windows 95/98 以 EXE 为后缀的可执行文件中。它不但会破坏计算机硬盘中的信息, 而且还会破坏 BIOS, 使系统无法启动, 从而很难杀除。由于染毒的 BIOS 无法启动系统, 故障现象与主板硬件损坏一样, 所以 CIH 病毒被认为是第一个破坏计算机硬件系统的病毒。

CIH 可利用所有可能的途径进行传播: 软盘、CD-ROM、Internet、FTP 下载和电子邮件等。被公认为是有史以来最危险、破坏力最强的计算机病毒之一。1998 年 6 月爆发于中国台湾, 在全球范围内造成了 2000 万 8000 万美元的损失。

## 2.梅利莎(Melissa, 1999 年)

这个病毒专门针对微软的电子邮件服务器和电子邮件收发软件, 它隐藏在一个Word 97 格式的文件里, 以附件的方式通过电子邮件传播, 善于侵袭装有 Word 97 或 Word 2000 的计算机。它可以攻击 Word 97 的注册器并修改其预防宏病毒的安全设置, 使它对感染的文件所具有的宏病毒预警功能丧失作用。

在发现 Melissa 病毒后短短的数小时内, 该病毒即通过因特网在全球感染数百万台计算机和数万台服务器, 因特网在许多地方痽疹。1999 年 3 月 26 日爆发,感染了 $15 \% \sim 20 \%$的商业 $\mathrm{PC}$,给全球带来了 3 亿 6 亿美元的损失。

## 3 . 爱虫(I love you, 2000 年)

2000 年 5 月 3 日爆发于中国香港,是一个用 VBScript 编写,可通过 E-Mail 散布的病毒, 而受感染的电脑平台以 Windows 95/98/2000 为主。给全球带来 100 亿 150 亿美元的损失。

## 4. 红色代码 (Code Red, 2001 年)

该病毒能够迅速传播,并造成大范围的访问速度下降甚至阻断。这种病毒一般首先攻击计算机网络的服务器, 遭到攻击的服务器会按照病毒的指令向政府网站发送大量数据, 最
终导致网站痽梹。其造成的破坏主要是涂改网页。有迹象表明, 这种蠕虫有修改文件的能力。2001年 7 月 13 日爆发,给全球带来了 26 亿美元损失。

## 5.SQL Slammer (2003 年)

该病毒利用 SQL Server 2000 的解析端口 1434 的缓冲区溢出漏洞对其服务进行攻击。 2003 年 1 月 25 日爆发, 全球共有 50 万台服务器被攻击, 但造成的经济损失较小。

## 6. 冲击波 (Blaster, 2003 年)

该病毒运行时会不停地利用 IP 扫描技术寻找网络上系统为 Windows 2000 或 XP 的计算机, 找到后就利用 DCOM RPC 缓冲区漏洞攻击该系统, 一旦攻击成功, 病毒体将会被传送到对方计算机中进行感染, 使系统操作异常、不停重启甚至导致系统崩溃。另外, 该病毒还会对微软的一个升级网站进行拒绝服务攻击, 导致该网站堵塞, 使用户无法通过该网站升级系统。2003 年夏爆发,数十万台计算机被感染, 给全球造成 20 亿 100 亿美元损失。

## 7 . 大无极. F(Sobig.f, 2003 年)

Sobig.f 是一个利用互联网进行传播的病毒, 当其程序被执行时, 它会将自己以电子邮件的形式发给它从被感染电脑中找到的所有邮件地址, 它使用自身的 SM TP 引擎来设置所发出的信息。此蠕虫病毒在 2003 年 8 月 19 日爆发, 为此前 Sobig 的变种, 更具欺骗性, 给全球带来 50 亿 100 亿美元损失。

## 8. 贝革热 (Bagle, 2004 年)

该病毒通过电子邮件进行传播。运行后, 在系统目录下生成自身的拷贝, 修改注册表键值。病毒同时具有后门能力。2004 年 1 月 18 日爆发, 给全球带来数千万美元损失。

## 9.MyDoom (2004 年)

MyDoom 是一种通过电子邮件附件和 P2P 网络 Kazaa 传播的病毒, 当用户打开并运行附件内的病毒程序后, 病毒就会以用户信箱内的电子邮件地址为目标, 伪造邮件的源地址,向外发送大量带有病毒附件的电子邮件, 同时在用户主机上留下可以上载并执行任意代码的后门。2004 年 1 月 26 日爆发, 在高峰时期, 导致网络加载时间慢 50\%以上。

## 10 . 震荡波 (Sasser, 2004 年)

该病毒是一个利用微软操作系统的 Lsass 缓冲区溢出漏洞(MS04-011 漏洞信息) 进行传播的蠕虫。由于该蠕虫在传播过程中会发起大量的扫描, 因此对个人用户使用和网络运行都会造成很大的冲击。2004 年 4 月 30 日爆发, 给全球带来数千万美元的损失。

### 9.1.4 计算机病毒的主要特性

## 1. 可执行性

计算机病毒是一段可执行的程序,这一点非常重要。

不含有程序代码的数据文档不能构成病毒; 病毒代码未被执行就无法传播与破坏。

基于以上的认识, 我们知道,一个纯文本文档、一个正常的图片内部无法包含程序代码,是不会感染与携带病毒的。一个病毒程序通过列目录、拷贝等方法不会被执行, 也不会进行感染和破坏的。

一个病毒程序代码怎样被执行的呢?

一些病毒代码藏匿于可执行文件的正常代码前面, 当执行这个程序时病毒代码就搭车被执行。
一些病毒代码藏匿于系统磁盘的引导区, 当系统启动时在 BIOS 作用下, 首先执行引导区内的程序代码, 这些隐藏在系统引导区的病毒代码被执行。

一些病毒代码藏匿于 Office 文档的自动宏命令中, 自动宏是一段在打开文档时自动执行的程序, 当打开含有宏病毒的文档时,这些病毒代码被执行。

一些病毒代码藏匿于网页脚本程序中, 当用浏览器浏览网页时这些脚本代码被执行。

一些病毒程序不依附于任何载体而独立存在, 它们通过系统漏洞通过网络传给人网的计算机, 并通过系统漏洞修改注册表文件, 使这些病毒程序在计算机启动时自动启动。

一些病毒程序独立存在移动存储设备中(如 $U$ 盘), 并建立移动盘自动启动文件, 当使用者打开移动存储设备时,自动启动文件引导病毒程序的启动。

## 2. 隐蔽性

计算机病毒是一段程序代码或者是一个独立存在的程序。为了防止被发现, 总是千方百计将自己隐藏起来。

位于系统引导区的病毒通常不需要隐藏, 因为引导区内的代码通常是不可见的。

依附在文件上的病毒由于有文件做掩护,通常也不需要特殊的隐藏措施。但是文件被病毒附身后尺寸往往会增大,一些隐蔽性好的病毒会将自身藏匿于这些文件内部中未被使用的空隙中,使感染后的文件尺寸并未增大,隐蔽性得到加强。

独立存在的病毒没有宿主程序做掩护, 隐蔽性很差, 通常仅采取将病毒程序加上隐藏和系统属性,在 Windows 系统中进行合理的配置就可以使这些病毒现身。

## 3. 传染性

计算机病毒依靠其传染性不断将自己复制和扩散,这是计算机病毒和特洛伊木马程序的显著区别。

计算机病毒的传染方式有多种。通常采取通过接管系统中断的方法进行传染。所有的传染都是在病毒程序被启动后才能够进行。未被启动的病毒程序是不会传染的。

病毒程序被启动后抢先接管系统中断,当有磁盘或文件读写等操作时首先被病毒程序发现, 病毒程序判断是否需要对这个磁盘或文件进行感染, 如果需要则病毒程序自动将病毒代码写人此磁盘或文件中, 完成病毒的传染过程,传染病毒完成后病毒程序再对磁盘或文件进行正常的读写操作,使用户无法发现病毒的传染。

有些病毒接管网络通信中断, 当进行网络通信时这些病毒将病毒代码通过网络通信传输到远方目标计算机, 完成病毒的传染过程。

## 4. 潜伏性

计算机病毒为了更广泛地传播和扩散, 通常完成传染过程后不会立即发作进行破坏活动,而是将自己深深地隐藏起来,伺机进行传染。

一个计算机病毒的潜伏性越好, 其在系统中的存在时间就会越长, 病毒的传染范围就会越广,其危险性和破坏性就越大。

有些计算机病毒被感染后频频造成死机的现象,这往往是由于计算机病毒制造者技术水平不高造成的。计算机病毒程序接管系统中断时设计不够周密, 和正常程序的运行造成冲突、破坏程序的正常执行而产生死机。

## 5. 破坏性

按计算机病毒的破坏性可将其分为主动进行破坏的恶性病毒和不主动进行破坏的良性
病毒。

恶性病毒的破坏性很明显,如: 删除磁盘文件、破坏磁盘分区、破坏 CMOS 内容甚至破坏 BIOS 内引导程序。这些破坏会给用户造成巨大的损失,会使用户多年的心血毁于一旦，这一类病毒令广大计算机用户深恶痛绝。

还有一类计算机病毒并不主动进行破坏, 不破坏用户的文件资料, 也不会造成系统死机和崩溃, 甚至有时会给用户播放一段优美的乐曲或不定时弹出一个问候语。这些计算机病毒虽然不直接对系统进行破坏, 但是其运行时必定要占用用户的系统资源, 降低用户计算机系统的工作效率, 而这种占用是未经用户允许的。所有未经用户允许就擅自侵占用户资源的行为都是对用户系统资源的侵占和破坏。因此说所有的计算机病毒都具有破坏性。

## 6. 可触发性

病毒因某个事件的出现,诱使病毒实施破坏攻击或表现的特性称为可触发性。

计算机病毒为了隐蔽自己, 病毒必须潜伏, 少做动作。但如果完全不动,一直潜伏的话,病毒既不能感染也不能进行破坏,便失去了杀伤力和表现力。

病毒既要隐蔽又要维持杀伤力, 它必须具有可触发性。病毒的触发机制就是用来控制感染和破坏动作的频率的。病毒具有预定的触发条件, 这些条件可能是时间、日期、文件类型或某些特定数据等。病毒运行时, 触发机制检查预定条件是否满足, 如果满足, 启动感染或破坏动作,使病毒进行感染或攻击;如果不满足,使病毒继续潜伏。



不同种类的病毒其结构与特点各不相同,我们应重点分析各种病毒的结构特点、传播机理和启动方法。

## 9.2 .1 文件型病毒

文件型病毒是一种古老的病毒类型,病毒程序代码依附在一个可执行文件里面,通过修改程序文件人口地址, 在启动程序文件时首先执行病毒程序代码, 病毒代码通过修改系统中断的方法控制计算机系统后, 再继续执行正常的程序代码,使用户察觉不到计算机病毒的存在。

此类病毒感染后的文件长度和日期往往发生变化。通常可以使用检查文件长度和日期的方法发现此类病毒。

但有些病毒经过精心设计, 可以藏匿于程序文件的一些空隙中,并不修改文件的日期与时间, 用检查文件长度和日期的方法就无法发现病毒的感染了。

此类病毒的杀除比较麻烦, 需要找到正常代码与病毒代码的分界线, 将病毒代码从程序中剥离, 如果分界线划分错误,可能会破坏正常的程序,使杀除病毒后的文件无法正常运行。

病毒程序代码位置: 嵌人正常可执行文件中。

病毒代码执行方式: 执行程序时“搭车”启动。

杀毒方法:将病毒代码从程序中剥离。

### 9.2.2引导型病毒

引导型病毒也是一种古老的病毒类型。

引导区(硬盘中的主引导区) 是磁盘的一个特殊区间, 位于磁盘的 0 号面、 0 号磁道、第一扇区, 容量大小仅为 512 字节。在主引导区内, 含有主引导程序和磁盘分区表。计算机启动时 BIOS 会自动执行主引导区内的程序,由主引导程序引导启动磁盘操作系统。

引导型病毒侵占主引导区后, 将原主引导程序移动到其他空闲扇区中。计算机系统启动时, BIOS 自动执行主引导区内的病毒程序, 病毒程序控制了计算机系统之后再执行移到空闲扇区内的正常引导程序, 使系统在病毒程序控制下启动。

因为硬盘主引导区不属于任何磁盘分区, 因此使用 Format 命令无法对其进行格式化,所以无法使用删除文件或格式化的方法将其杀除。

如此看来引导型病毒好像很难杀除,其实不然。

引导型病毒有其自身的弱点和局限。它必需存放于硬盘的主引导区,而硬盘主引导区内的程序相对简单和固定, 因此,只要检查硬盘的主引导区就可发现是否被引导型病毒所感染, 杀除方法也很简单, 只要用正常的引导区数据覆盖被感染的引导区就可以使引导区恢复正常。所以很多杀毒软件在安装时首先备份主引导区的数据, 以备病毒感染引导区后恢复引导区使用。

病毒程序代码: 替换正常的引导区程序,将正常引导程序移动到空闲扇区。

病毒代码执行方法: 系统启动时自动被启动。

杀毒方法:用正常引导区程序覆盖被感染的引导区。

## 9.2 .3 宏病毒

宏是微软公司为其 Office 软件包设计的一个特殊功能, 软件设计者为了让人们在使用软件进行工作时, 避免一再地重复相同的动作而设计出来的一种工具, 它利用简单的语法,把常用的动作写成宏, 当在工作时, 就可以直接利用事先编好的宏自动运行, 去完成某项特定的任务,而不必再重复相同的动作, 目的是让用户文档中的一些任务自动化, 方便了用户的操作。

如果病毒程序利用宏的功能隐藏到 Office 文档中, 就称为宏病毒。

建立宏的方法有两种,自动录制和使用 VB 脚本编写宏代码。

自动录制宏的方法比较简单, 启动录制宏功能之后, Office 系统会自动记录用户所做的一切操作, 并将操作自动生成 VB 脚本的宏代码。这种自动录制宏的方法操作简单, 易于实现,为广大 Office 用户广泛使用。

另一种建立宏的方法是直接使用 V B 脚本编写宏代码。这种方法需要一定的计算机编程知识, 不易被普通用户所掌握。但使用这种方法可以编制出各种功能强大的脚本程序, 甚至可以编制出病毒程序。

在 Office 的宏中有一类宏叫做自动宏。当文档被打开后自动宏就会自动被启动, 如果文档中含有自动宏病毒, 打开文档的同时自动宏中的病毒程序就会被执行。

由于宏代码结构简单, 容易学习和掌握, 不需要很高深的计算机知识, 只要略懂 VB 脚本语言的人都可以编写出宏病毒程序, 因此在一段时期内宏病毒广泛传播, 成为一个时期的主要病毒类型。
宏病毒也有本身的弱点。首先, 宏代码结构比较简单且规范, 因此宏病毒不易隐藏, 使用杀毒软件很容易发现宏病毒的存在。其次, 宏病毒往往依靠自动宏启动, 新版本的 Office 系统针对这种现象会弹出警告对话框, 提醒用户此文档含有自动宏, 由用户选择是否允许自动宏的执行,如果用户禁止自动宏的执行,宏病毒将无法被启动。

病毒程序代码: 使用 VB 脚本编制,藏匿于宏命令中。

病毒代码执行方法:文档被打开时由 Office 执行。

避免感染方法:禁用自动宏。

### 9.2.4 网页脚本程序病毒

脚本, 是使用一种特定的描述性语言, 依据一定的格式编写的可执行文本, 又称作宏或批处理文件。脚本通常可以由应用程序临时调用并执行。各类脚本目前被广泛地应用于网页设计中,因为脚本不仅可以减小网页的规模和提高网页浏览速度,而且可以丰富网页的表现,如动画、声音等。

正因为脚本的这些特点, 往往被一些别有用心的人所利用。例如在脚本中加人一些破坏计算机系统的命令,这样当用户浏览网页时,一旦调用这类脚本,便会使用户的系统受到攻击。

网页脚本程序病毒以脚本代码的形式藏匿于网页中, 用户浏览网页时由浏览器对脚本代码进行解释及执行, 一旦用户浏览含有脚本病毒的网页, 病毒程序将被执行并控制计算机系统,并将病毒脚本传染到本机其他网页文件中。

因为脚本病毒隐藏在服务器上,所以客户机只能利用杀毒软件在浏览网页时对下载的网页内容进行检查, 防止脚本病毒感染本客户机, 而无法根除服务器上的病毒程序。

用户也可以在客户机对浏览器进行合理配置, 禁止脚本程序的运行, 可以阻止脚本病毒的感染。方法是如图 9-1:“IE 浏览器” $\rightarrow$ “工具菜单” $\rightarrow$ “Internet 选项” $\rightarrow$ “安全选项卡” $\rightarrow$ “自定义级别” $\rightarrow$ “安全设置”, 选中“脚本选项”, 将“脚本程序”禁用, 即可阻止脚本病毒的感染。但也会阻拦正常的脚本程序,使网站功能受到影响。



图 9-1
病毒程序代码: 以脚本程序的形式存在于服务器网页文件中。病毒代码执行方法: 浏览器浏览网页时将代码下载并在客户机上执行。预防方法:禁止或限制浏览器执行脚本程序。

## 9.2 .5 蠕虫

蠕虫病毒是一种特殊的病毒,近年来成为网络环境下主要病毒种类。

蠕虫病毒和一般传统的病毒有着很大的区别。蠕虫是一种通过网络传播的恶性病毒,它具有病毒的一些共性, 如传播性、隐蔽性和破坏性等等, 同时具有自己的一些特征,如不利用文件寄生,对网络造成拒绝服务以及和黑客技术相结合等等。

蠕虫病毒的特点:

(1)不依附于文件或磁盘扇区

蠕虫病毒不将病毒代码依附于磁盘文件或磁盘扇区，而是以独立的病毒程序方式出现。一个病毒往往就是一个独立的程序。这个病毒程序通常使用常用系统文件名或采用隐藏属性来隐蔽自己,防止被用户发现。

(2)利用系统漏洞进行传播

蠕虫病毒的传播与网络环境密切相关, 没有互联网就没有蠕虫的生存空间。

蠕虫病毒利用网络环境下操作系统的或应用软件的设计漏洞, 非法获得远程计算机系统的写人权限,利用非法权限将自身复制到对方的计算机中。

(3)通过修改注册表启动或直接诱使用户点击启动

蠕虫病毒传人对方计算机后, 往往更改病毒程序文件名为常用软件文件名,诱使用户点击启动,如改成:IE.exe、WinRAR.exe、ReadMe.exe 等。

蠕虫病毒更多的启动方法是修改注册表文件, 将病毒程序加人系统启动项中, 当系统启动时自动执行启动文件组中的程序文件,病毒程序得以启动。

蠕虫病毒虽然传播速度快,破坏性大,但是发现它并不困难。

首先,蠕虫病毒程序是以独立的文件形式出现,为了防止被用户发现,往往被设置成隐藏属性, 因此, 只要将在资源管理器或我的电脑中设置显示隐藏文件, 病毒程序就无法藏身。

设置方法如图 9-2 所示。“我的电脑”或“资源管理器” $\rightarrow$ “工具菜单” $\rightarrow$ “文件夹选项” $\rightarrow$ “查看选项卡” $\rightarrow$ 选中“显示系统文件夹的内容” 和“显示所有文件和文件夹”, 取消“隐藏受保护的操作系统文件 (推荐) ”, 即可显示出全部隐藏和系统属性文件。如果在系统文件夹中发现异常文件则很可能系统已被蠕虫病毒所感染。

还有, 蠕虫病毒通常通过修改注册表启动文件内容来启动蠕虫病毒, 如果发现注册表中启动项出现异常程序, 也可以怀疑是被蠕虫病毒所感染。

蠕虫病毒的杀除方法更简单, 直接删除蠕虫病毒文件即可。病毒程序代码: 以独立文件的形式存在,利用系统漏洞以文件复制的方式传播。

病毒代码执行方法:诱惑用户点击执行或修改注册表而自动启动。

杀毒方法:直接删除病毒程序文件。



图 9-2

## 9.2 .6 特洛伊木马

特洛伊木马, 简称木马, 其本质上不能算作病毒程序, 它往往不具备病毒所特有的传染性, 但是它对计算机系统和网络的破坏作用巨大,而且现在很多木马与病毒程序相结合, 同时具有木马和病毒的特征,所以,通常也把它归类为病毒。

特洛伊木马起源于历史典故。《荷马史诗》中讲述了这样一个故事, 希腊人围攻特洛伊城, 十年不能得手, 后来想出了木马的计策, 他们把士兵藏匿于巨大的木马腹中。在敌人将其作为战利品拖人城内后, 藏于木马内的士兵趁夜晚爬出来, 打开城门, 与城外的部队里应外合而攻下了特洛伊城。

计算机世界中的特洛伊木马程序就如同真实的特洛伊木马,将一段恶意代码隐藏在正常程序中, 用户使用程序时木马代码悄悄控制住计算机系统, 窃取计算机中的秘密, 如记录计算机的键盘操作和屏幕显示信息, 此法很容易获得用户得到登录账户和密码。木马程序在获得对方秘密后常采用电子邮件或其他方式将窃得的机密信息传输给远方的木马操控者。

木马程序通常分为服务器和客户端两个部分。客户端由病毒的操控者掌握, 而服务器端被埋藏于被攻击的计算机中, 并诱使被攻击者执行木马程序, 这一点与蠕虫病毒很像。但木马程序的主要目的是窃取计算机中的秘密并安全地发送给木马的操控者, 而传染性不是木马的主要目的。

怎样发现计算机是否感染木马程序? 最有效的方法是在计算机中安装个人防火墙软件, 监视所有的进出数据, 如果发现有程序毫无道理的对外发送数据或自动发送电子邮件,可以怀疑可能是木马程序。

木马程序代码: 以独立文件的形式存在或依附于一个宿主文件。

木马代码执行方法:诱惑用户点击执行或修改注册表而自动启动。
杀除方法:直接删除木马程序文件。

## 9.3计算机病毒的查杀与防范方法

### 9.3.1 杀毒软件工作原理

自从计算机病毒诞生之日起,制造与杀除病毒的斗争就一刻也没有停止过,随着病毒制造技术的不断变化, 病毒检查与杀除技术也在不断地进步。

目前常用的检测病毒方法有: 特征代码法、校验和法及行为监测法等。

## 1.特征代码法

每一个病毒都是一段程序,每一个新病毒一定有一段与众不同的程序代码。这个与众不同的代码就构成这段程序的特征。通过分析病毒程序,找出该病毒与众不同的特征代码,将其提取出来加人查毒软件病毒特征库, 查毒软件在查毒过程中将每一个被检查的程序和病毒特征代码库中的病毒特征代码相比较, 如果产生吻合就可以断定被检测的程序已被具有此种特征的病毒所感染。

特征代码法的特点:

需要不断更新病毒代码特征库。因为查毒的过程实际上是将程序代码与病毒特征代码比对的过程, 对病毒代码库中没有包含特征代码的病毒是无法查出的。由于每天都有新的病毒产生, 病毒特征代码库亦需不断补充升级。现在著名查毒系统病毒特征代码库往往数小时即升级一次,以保证用户能够及时得到最新的病毒代码特征库。

检测准确快速。特征代码法依据每一个病毒的特征代码进行查毒, 只要特征代码选取合理准确,查毒的准确性就高, 不容易发生误判。

可识别病毒名称、可做杀毒处理。根据每一种病毒特征代码查毒,一旦发现程序中某段程序与某个病毒特征码相吻合, 即可知道该程序已被病毒感染, 且知道是被哪一个病毒所感染,并可根据此病毒的感染方法进行删除病毒代码、恢复文件的操作。

不能检测未知的病毒。由于无法掌握还未出现的病毒特征代码, 因此特征代码法无法发现与杀除所有的未知病毒。

随着病毒数量的增多, 查毒开销很大。在计算机病毒出现的早期, 世界上流行的病毒不过几十种, 查毒软件包含的病毒特征库仅有几十种特征代码即可查杀全部病毒, 查杀病毒效率很高。但现在已知病毒数已达上万种, 杀毒过程需要将每一个被查对象与上万个病毒特征代码相比对, 耗费大量的计算机资源。随着计算机病毒的不断增多,特征代码法查毒日显困难。

## 2. 校验和法

软件作者在制作出软件后, 计算出软件的校验和, 并将校验和与软件一起发布。如果软件被病毒所感染,校验和就会发生变化,软件使用者或杀毒软件根据软件的校验和是否发生变化判断软件是否被病毒所感染。

校验和法的特点:

可以发现未知病毒。任何病毒感染文件都会造成校验和的改变,未知病毒感染文件后
校验和也会发生改变,因此校验和法可以查出任何已知或未知病毒的感染。

不能判断病毒的类型和名称, 不能杀除病毒。校验和法仅根据被病毒感染后的文件校验和的变化发现病毒的感染, 无法得知是什么病毒进行的感染, 也就无法采取措施杀除病毒。

误报率较高。一些程序会根据不同的用户需求或工作状态对自身进行修改, 修改后的程序校验和也会发生改变,这时检验和法查毒软件就会发生误判。

## 3. 行为监测法

利用病毒的特有行为特征性来监测病毒的方法, 称为行为监测法。

病毒程序要进行传染与破坏, 传染与破坏行为是正常软件所不应有的, 当程序运行时,监视其行为,如果发现了病毒行为,即可判定此程序已被病毒所感染, 立即报警。

行为监测法的特点:

可以发现未知病毒。任何病毒的传染与破坏行为都会被查毒软件所发现。因此行为监测法可以查出已知或未知病毒的感染。

不能判断病毒的类型和名称, 不能杀除病毒。行为监测法仅根据被病毒感染后的文件的异常行为发现病毒的感染, 无法得知是什么病毒进行的感染, 也就无法采取措施杀除病毒。

误报率较高。有些正常程序也会根据不同的用户需求或工作状态产生类似病毒的操作行为, 这时行为监测法查毒软件就会发生误判。

### 9.3.2 如何使用杀毒软件

现在, 杀毒软件已成为计算机中必装软件之一。各个厂家纷纷推出各种杀毒软件产品,国际著名杀毒软件公司或产品有: 卡巴斯基、诺顿和 McAfee 等, 国内著名杀毒软件公司或产品有: 瑞星、江民和金山毒霸等。

现代杀毒软件所采用的查毒、杀毒技术大同小异, 工作原理与使用方法基本相同。这里以国际著名品牌卡巴斯基为例介绍杀毒软件的安装、配置与使用方法。

卡巴斯基 (Kaspersky) 杀毒软件来源于俄罗斯, 是世界上最优秀、最顶级的网络杀毒软件之一, 查杀病毒性能高。它提供了所有类型的抗病毒防护: 抗病毒扫描仪、监控器、行为阻断和完全检验。它支持几乎是所有的普通操作系统、E-mail 通路和防火墙。卡巴斯基反病毒软件有许多国际研究机构、中立测试实验室和 IT 出版机构的证书, 确认了卡巴斯基具有汇集行业最高水准的突出品质。

卡巴斯基目前与安全卫士 360 合作, 安装安全卫士 360 后可以获得卡巴斯基半年的使用权。也可以到卡巴斯基官方网站下载 30 天试用期的试用版,如图 9-3 所示。

卡巴斯基可供免费试用的查毒产品主要有两种, 即卡巴斯基反病毒软件 6.0 个人版和卡巴斯基互联网安全套装 6.0 个人版。前者仅提供查杀病毒, 后者还提供了网络安全功能。



图 9-3

## 1.卡巴斯基的安装

这里以卡巴斯基反病毒软件 6.0 个人版为例,介绍软件安装方法。

启动卡巴斯基安装程序,出现欢迎画面,如图 9-4 所示。

点击“下一步”开始安装。

认真阅读“终端用户基本许可协议”后, 选择“我接受许可协仪条款”, 点击“下一步”按钮,如图 9-5 所示。



图 9-4



图 9-5

选择安装路径 (通常按默认安装路径即可), 如图 9-6 所示, 点击“下一步”。选择安装方式,如图 9-7 所示。通常选“完整”安装。点击“完整”按钮,进入“下一步”。



图 9-6



图 9-7

如图 9-8 所示,点击“安装”。开始安装过程,如图 9-9 所示。



图 9-8



图 9-9

点击“下一步”, 完成安装过程,如图 9-10 所示。

选择激活方法, 如图 9-11 所示。正式版用户在购买卡巴斯基时会获得一个激活码, 此时选中“使用激活码激活”单选钮进行激活, 试用版用户可点击“激活试用版”, 免费试用 30 天。点击“下一步”。



图 9-10



图 9-11
试用版激活成功, 如图 9-12 所示, 点击“下一步”按钮。

选择保护方式，如图 9-13 所示。一般选“基本保护”即可。



图 9-12



图 9-13

点击“下一步”按钮。选择病毒特征代码库更新方法,如图 9-14 所示,通常选“自动”即可。点击“下一步”。选择扫描方式, 如图 9-15 所示。通常按默认值即可完成安装过程。



图 9-14



图 9-15

点击“完成”按钮,如图 9-16 所示, 重新启动计算机, 杀毒软件卡巴斯基开始工作, 如图 9-17 所示。



图 9-16



图 9-17

## 2. 卡巴斯基的设置与使用

卡巴斯基装好后, 还需精心设置才能达到最好的效果。合理的设置可以在保证安全的情况下尽量减少对系统资源的占用。

点击卡巴斯基主窗口右上角的“设置”按钮,打开设置窗口, 如图 9-18 所示。



图 9-18
在左面“设置”栏依次选中不同的对象，在右面窗格进行配置。

这里以“文件保护”为例介绍配置原则与方法。

左面窗格选中“文件保护”。右面窗格点击“自定义”按钿,如图 9-19 所示。



图 9-19

文件类型: “扫描所有文件”可靠性最高,但扫描速度最慢; “扫描程序和文档 (根据内容)”依据文件的内容进行有选择性的扫描, 对不会被病毒感染的文件不扫描, 节省了查毒时间,推荐选用此方案; “扫描程序和文档(根据扩展名)”根据文件扩展名进行扫描, 速度最快,但有可能会有漏测。

增量扫描技术被选中后,卡巴斯基会记住此次扫描过的文件,下次再扫描时对于没有改变过的文件不再进行扫描,大大提高了查毒速度。

复合文件中, 对过大的压缩包可以不扫描。因为扫描压缩包时系统会在一个虚拟的计算机中把压缩包打开逐一扫描,耗费了大量的系统资源。而通常压缩包内的程序和文档需要解压缩后才能使用,此时再用杀毒软件检查数据包的内容也不晚。

扫描过程中如果发现病毒,如何采取措施?

可采取的操作有: 提示操作,即发现病毒后并不马上处理,而是出现病毒提示,由用户自行判断采取哪种方式进行处理。阻止访问, 发现病毒后计算机自动阻止病毒程序对系统的访问, 对感染病毒的程序自动进行剥离病毒代码的“清除”操作, 对于蠕虫和木马类本身就是独立的病毒程序, 不需也无法剥离,可采用删除的方法杀除。

### 9.3.3 计算机病毒的预防

防范计算机病毒应以预防为主, 树立安全意识, 杜绝病毒传播途径, 建立安全备份与灾难恢复是预防工作的关键。

根据前面对各种类型病毒的分析了解到,不同类型的病毒程序传播原理与方法大不相同,需要采取不同的方法进行防范。

## 1.文件型病毒

文件型病毒代码寄生在可执行程序文件上,程序启动后病毒控制计算机系统并感染其
他程序文件。

防范方法: 不要启动来历不明的程序, 安装杀毒软件, 对所有新建的文件进行扫描。

## 2.引导型病毒

引导型病毒隐藏在系统磁盘主引导区内,启动系统时控制计算机系统。

防范方法: 使用未感染病毒的磁盘启动系统, 在系统健康时备份系统盘主引导区, 被引导型病毒感染后使用健康的系统引导区备份数据恢复系统盘主引导区。使用杀毒软件扫描系统盘的引导区。

## 3. 宏病毒

宏病毒寄生在 Office 文档的自动宏代码中, 启动 Office 文档时宏被启动。

防范方法:禁止 Office 文档自动宏,使用杀毒软件检查 Office 文档。

禁用自动宏的方法: 打开 Office 文档时按住 Shift 键,即可阻止自动宏的运行。

也可在 Office 2003 中,打开“工具”菜单,选择“选项”命令,打开“选项”对话框,选择“安全性” 选项卡, 点击“宏安全性” 按钮来设置, 如图 9-20 所示。



图 9-20

如图 9-21,选择第 2 个单选项。

## 安全性

安全级 $(\mathrm{S})$ 可靠发行商 (T)

○非常高品只仙许运行安装在受信任位置的宏。所有其他签署的和未经签署的宏都将被禁用( $($ )。

() 高。只纪许运行可靠来源签署的䆖, 未经签署的宏会自动取消 (H).

中: 您可以选择是否运行可能不安全的宏 (





## 4. 网页脚本病毒

网页脚本病毒隐藏在网站服务器中的网页文件中,浏览网页时被下载到本地执行。

防范方法:一般服务器上的病毒无法在本地处理,所以防范网页病毒只能在本地计算机中采取措施, 阻止病毒代码的下载和执行。可在本地计算机中设置 IE 安全选项, 在 IE 菜单栏里“Internet 选项”安全选项卡里,点击“自定义级别”按钮。把“ActiveX 控件及插件”的一切选项设为禁用, 如图 9-22 所示。



图 9-22

安装杀毒软件,对下载网页中的脚本进行扫描也是防范脚本病毒的有效方法。

## 5 . 蠕虫病毒

蠕虫病毒利用操作系统或网络软件的设计漏洞进行攻击, 常将病毒代码通过系统漏洞传人被攻击的计算机系统,并通过修改注册表的方法自动启动。

防范方法: 及时下载并安装系统补丁,修补系统设计漏洞。检查注册表中有关自动启动的键, 如果发现异常键值即可怀疑系统被蠕虫病毒所感染, 通过人工判断, 若判为病毒可删除该键值即可阻止蠕虫病毒的启动。

也可通过杀毒软件对整个系统磁盘进行扫描,检查蠕虫病毒的人侵。

安装个人防火墙软件可阻拦部分蠕虫病毒的人侵。

## 6.特洛伊木马

特洛伊木马的特性与蠕虫病毒有很多相似之处, 可以采用防范蠕虫病毒的方法防范特洛伊木马。也可安装个人防火墙监视计算机对网络的访问行为, 及时发现并阻拦木马对计算机系统信息的窃取。

许多杀毒软件已把特洛伊木马列人病毒类程序, 安装杀毒软件也可查出并删除特洛伊木马程序。

## 实验题

实验 9.1 宏病毒工作原理

一、实验目的

通过建立自动宏, 了解宏病毒的工作原理。

二、实验环境

Windows 操作系统, Office 软件,计算器(或其他)程序。

三、实验内容

宏是微软公司为其 Office 软件包设计的一个特殊功能, 软件设计者为了让人们在使用软件进行工作时, 避免一再地重复相同的动作而设计出来的一种工具, 它利用简单的语法,把常用的动作写成宏, 当在工作时, 就可以直接利用事先编好的宏自动运行, 去完成某项特定的任务,而不必再重复相同的动作,目的是让用户文档中的一些任务自动化,方便了用户的操作。

如果病毒程序利用宏的功能隐藏到 Office 文档中, 就称为宏病毒。

在本实验中我们建立一个自动宏, 并利用自动宏启动 Windows 自带的计算器程序, 以此来模拟病毒所具有的程序代码和自动执行功能,证明利用宏是可以制造病毒的。

为了防止病毒程序的泛滥, 我们的实验程序不带有传染和破坏功能, 仅以自动启动程序的方法说明病毒程序的启动过程。

四、实验步骤

- 启动 Word,创建一个新文档。
- 在新文档中打开工具菜单、选择宏、查看宏。
- 为宏起一个名字, 自动宏的名字规定必须为 autoexec。



图 9-23

- 点击“创建”按钮, 如图 9-23 所示。
- 在宏代码编辑窗口, 输人 VB 代码, 调用 Windows 自带的计算器程序, 如图 9-24 所示。

Shell("c:\windows \system32\calc.exe")

## Hornal - Heulacros (代巧)

## (Gi面用)



- 关闭宏代码编辑窗口, 将文档存盘并关闭。
- 再次启动刚保存的文档, 可以看到计算器程序被自动启动。

思考:

(1)能否利用自动宏启动其他程序?

(2) 能否利用 VB 编写出具有其他功能的程序?

(3) 自动宏能禁止吗?

## 实验 $9.2 \mathrm{U}$ 盘病毒工作原理

一、实验目的

通过建立 $\mathrm{U}$ 盘自动运行文件, 了解 $\mathrm{U}$ 盘病毒的工作原理。

二、实验环境

Windows 操作系统, $\mathrm{U}$ 盘, 计算器 (或其他)程序。

三、实验内容

一些病毒程序独立存在移动存储设备中(如 U 盘), 并建立移动盘自动启动文件, 当使用者打开移动存储设备时,自动启动文件引导病毒程序启动。

自动启动文件是微软公司为了方便用户启动程序而设置的一种名为 autorun.inf 的文本文件,位于移动盘的根目录,以纯文本的方式存放各种控制命令, 用户双击盘符打开移动盘时就会自动打开并执行里面的命令。

如果自动启动文件被病毒所利用,当用户双击打开移动盘时就会自动启动病毒程序。

在本实验中我们以自动启动计算器程序为例, 理解病毒启动原理, 证明利用自动启动文件可以启动病毒程序的现象,并分析移动盘病毒常用手法。

四、实验步骤

- 使用记事本或其他文本文件编辑软件在 U 盘中建立文名为 autorun.inf 的本文件。

-文件内容:

[autorun] 这是自动启动文件固定格式

shellexecute ${ }^{c}$ : \windows $\backslash$ system $32 \backslash$ calc.exe; 也可以是其他可执行程序或文档;下面内容不是必须的, 是病毒采取的隐藏或迷惑用户的常用手法

icon=calc.exe 更改移动盘图标为计算器

Label=计算器 更改移动盘盘符为计算器

shell 计算器 $\$ Command $=\mathrm{c}: \backslash$ windows $\backslash$ system $32 \backslash$ calc. exe; 在快捷菜单中添加计算器命令

- 将上述文本文件以 autorun.inf 为文件名保存到 U 盘根目录后, 如图 9-25 所示, 重新
插人 $\mathrm{U}$ 盘。



图 9-25

- 通过我的电脑双击 U 盘盘符,计算器程序被启动。

思考

- 能否利用自动启动文件启动其他程序?
- 怎样打开打算盘而不执行里面的自动启动程序?
- 能在 U 盘中实现免疫功能吗? (提示: 建立名为 autorun.inf 的文件夹)

实验 9.3 查杀病毒

一、实验目的

掌握杀毒软件的安装、配置及使用方法

二、实验环境

Windows 操作系统,卡巴斯基杀毒软件。

三、实验内容

1.建立病毒特征检测码文件, 以备查毒实验用。

下面是一段国际公开病毒特征检测码,不具有破坏性,用于检验杀毒软件。以下面这段代码为内容建立一个任意文件名,扩展名为.txt 的文本文件。

## X50! P\%@AP4PZX54 (P^) 7CC) 7$\}$ \$EICAR-STANDARD-ANTIVIRUS-TEST-

FILE ! \$ $\mathrm{H}+\mathrm{H} *$

2.安装卡巴斯基杀毒软件

访问卡巴斯基官方中文网,下载试用期 30 天的试用版,如图 9-26 所示。

http://www.kaspersky.com.cn/KL-Downloads/KL-ProductDownload.htm





卡巴斯基(8反病毒软件 6.0 个人此下载:

欢迎安装卡巴斯基回反病毒软件6.0个人版 (新): 工程序下载

3. 安装与配置卡巴斯基杀毒软件

下载后将压缩包解压, 运行安装程序 kav6.sch. msi, 按照系统建议的默认项安装即可。

4. 扫描本地计算机, 扫描中发现病毒文件或我们自制的病毒特征检测码文件时, 卡巴斯基报警、杀除并显示处理结果,如图 9-27,图 9-28 所示。

## 卡巴斯基后病毒

文件 E:'downloadikav6.schitest.txt: 检测到病毒

'EICAR-Test-File', 用户: BITC-W] 仼进, 计算机: localhost.

羊组信息...

图 9-27



图 9-28

## 习 题

9.1 什么是计算机病毒? 计算机病毒有哪些特性?

9.2 计算机病毒有哪些种类? 各类病毒代码是以何种形式出现,如何被启动的?

9.3 杀毒软件主要查毒方法有哪些? 是如何发现病毒的? 各种查毒方法有什么特点?

9.4 为什么计算机感染病毒后再安装杀毒软件会出现无法发现或杀除病毒的现象?这时如何才能彻底杀除病毒?

## 习题参考答案

9.1 计算机病毒是 “指编制或者在计算机程序中插人的破坏计算机功能或者破坏数据, 影响计算机使用并且能够自我复制的一组计算机指令或者程序代码”。

主要特性有: 可执行性、隐蔽性、传染性、潜伏性、破坏性和可触发性。

9.2 常见病毒的种类:

文件型病毒。代码隐藏在可执行程序文件中,随程序的启动而启动。

引导型病毒。代码隐藏在系统盘主引导区, 系统启动时由 BIOS 引导而启动。

宏病毒。代码隐藏在 Office 文档的自动宏命令中, 打开文档时启动。
网页脚本病毒。代码隐藏在网页中,浏览网页时病毒代码被下载并启动。

蠕虫病毒。病毒以独立程序形式出现, 利用系统安全漏洞传染, 修改注册表启动项启动或诱骗用户点击启动。

木马程序。严格说木马不属于病毒。

9.3 常用查毒方法有:

特征代码法。通过收集已知病毒特征代码建立病毒代码库, 将被查对象与病毒库中的特征码比对发现病毒。查出病毒通常即可杀除,不能发现未知病毒。

校验和法。检查程序文件字节校验和,如果校验和变化证明文件被改动从而发现病毒。可以发现未知病毒, 误报率较高。

行为检测法。根据病毒特有的行为进行判断发现病毒。可以发现未知病毒, 误报率较高。

9.4 若病毒软件启动, 计算机系统有可能被病毒程序所控制。病毒程序可禁止后安装的杀毒软件正常工作,使杀毒软件无法发现病毒。

解决方法: 用其他系统盘启动系统 (如光盘或 U 盘), 在 “干净” 的计算机系统中启动杀毒软件查杀病毒。

## 网络攻防技术



教学要求

本章以 Internet 的安全为背景, 介绍了网络攻防技术的基本原理, 使学生能够了解各种网络入侵和网络攻击技术, 掌握安全防范和安全监测的基本原则和一般方法。通过本章的学习, 了解网络攻击带来的问题, 理解常见的网络入侵手段和网络攻击手段,掌握安全防范的基本原则和安全监测技术。掌握安全审计和安全扫描技术。



### 10.1.1 网络攻击概念

随着 Internet 的日益普及, 进入网络的计算机数量迅速增加, 网络的人侵问题也随之突出。所谓网络的人侵是指对接人网络的计算机系统的非法进人, 即攻击者未经合法的手段和程序而取得了使用该系统资源的权限。网络人侵的目的有多种: 或者是取得使用系统的存储能力、处理能力以及访问其存储内容的权限; 或者是作为进人其他系统的跳板; 或者是想破坏这个系统(使其毁坏或丧失服务能力)。网络人侵是目前最受关注、也是影响最大的网络攻击行为, 但是网络攻击并不仅有网络人侵一种, 网络攻击是指对网络系统的机密性、完整性、可用性、可控性和抗抵赖性产生危害的行为。这些行为可抽象地分为四个基本情形:信息泄漏攻击、完整性破坏攻击、拒绝服务攻击和非法使用攻击。

网络攻击的全过程是: 攻击者发起并应用一定的攻击工具 (包括攻击策略与方法), 对目标网络系统进行攻击操作,达到一定的攻击效果, 实现攻击者预定义的攻击效果。

### 10.1.2 网络攻击分类

在最高层次,网络攻击可分为被动攻击和主动攻击两类。

## 1 . 被动攻击

被动攻击主要是收集信息而不是进行访问,通过网络窃听截取数据包并进行分析, 从中
窃取重要的敏感信息。数据的合法用户对这种活动一点也不会觉察。被动攻击包括嗅探以及信息收集等攻击方法。

## 2.主动攻击

主动攻击包含窃取、篡改、假冒和破坏等, 是攻击者访问他所需信息的故意行为。比如远程登录到指定机器的 25 号端口找出公司的邮件服务器的信息; 伪造无效 IP 地址去连接服务器, 使接收到错误 IP 地址的系统浪费时间去连接那个非法地址。攻击者是在主动地做不利于他人系统的事情。正因为如此, 找到他们是较容易的。主动攻击包括字典式口令猜测、IP 地址欺骗、信息篡改、资源使用和服务拒绝攻击等。

这样分类不是说主动攻击不能收集信息或被动攻击不能用来访问系统。多数情况下这两种类型被联合用于人侵一个站点。但是, 大多数被动攻击不一定包括可被跟踪的行为, 因此更难被发现。从另一个角度看, 主动攻击容易被发现, 但多数公司都没有发现, 所以发现被动攻击的机会几乎是零。

当前网络攻击的方法没有规范的分类模式,方法的运用非常灵活。从攻击的目的来看,可以有拒绝服务攻击、获取系统权限的攻击和获取敏感信息的攻击; 从攻击的切人点来看,有缓冲区溢出攻击、系统设置漏洞的攻击; 从攻击的纵向实施过程来看, 有获取初级权限攻击、提升最高权限的攻击、后门攻击和跳板攻击; 从攻击的类型来看, 有对各种操作系统的攻击、对网络设备的攻击和对特定应用系统的攻击。所以说, 很难用一个统一的模式对各种攻击手段进行分类。

实际上黑客实施一次入侵行为, 为达到他的攻击目的会结合采用多种攻击手段, 在不同的人侵阶段使用不同的方法。

### 10.1.3 网络攻击的一般过程

进行网络攻击主要工作流程: 收集信息, 远程攻击, 远程登录, 取得普通用户名及权限,取得超级用户名及权限, 留下后门, 清除日志。主要内容包括目标分析, 文档获取, 破解密码,日志清除等技术。

一次成功的攻击,一般都经过下面这些步骤,但是根据实际情况可以随时调整。

## 1 . 隐藏 IP

这一步必须做, 因为如果自己的人侵痕迹被发现了, 当找上门的时候就一切都晚了。通常有两种方法实现自己 IP 的隐藏:

第一种方法是首先人侵互联网上的一台电脑 (通常称 “肉鸡”), 利用这台电脑进行攻击,这样即使被发现了,也是“肉鸡”的 IP 地址。

第二种方式是做多极跳板 “Sock 代理”, 这样在人侵的电脑上留下的是代理计算机的 IP 地址。

比如攻击 A 国的站点,一般选择离 A 国很远的 B 国计算机作为“肉鸡”或者“代理”, 这样跨国度的攻击,一般很难被侦破。

## 2. 踩点扫描

踩点就是通过各种途径对所要攻击的目标进行多方面的了解 (包括任何可得到的蛛丝马迹, 但要确保信息的准确), 确定攻击的时间和地点。

扫描的目的是利用各种工具在攻击目标的 IP 地址或地址段的主机上寻找漏洞。

## 3. 获得系统或管理员权限

得到管理员权限的目的是连接到远程计算机,对其进行控制,达到自己攻击目的。获得系统及管理员权限的方法有: 通过系统漏洞获得系统权限; 通过管理漏洞获得管理员权限;通过软件漏洞得到系统权限; 通过监听获得敏感信息进一步获得相应权限; 通过弱口令获得远程管理员的用户密码; 通过穷举法获得远程管理员的用户密码; 通过攻破与目标机有信任关系的另一台机器进而得到目标机的控制权; 通过欺骗获得权限以及其他有效的方法。

## 4. 种植后门

为了保持长期对自己胜利果实的访问权,在已经攻破的计算机上种植一些供自己访问的后门。

## 5. 在网络中隐身

一次成功人侵之后, 一般在对方的计算机上已经存储了相关的登录日志, 这样就容易被管理员发现。在人侵完毕后需要清除登录日志以及其他相关的日志。



### 10.2.1 端口扫描

一个端口就是一个潜在的通信通道, 也就是一个人侵通道。端口扫描技术通过对目标系统的所有端口进行扫描, 查看哪些端口处于打开状态, 正在提供什么服务, 再凭经验得知这种服务可能存在什么缺陷,为黑客的人侵收集可利用的信息。进行扫描的方法很多,可以是手工进行扫描,也可以用端口扫描软件。

在手工进行扫描时, 需要熟悉各种命令。对命令执行后的输出进行分析。用扫描软件进行扫描时, 许多扫描软件都有分析数据的功能。通过端口扫描, 可以得到许多有用的信息,从而发现系统的安全漏洞。

扫描器是一种自动检测远程或本地主机系统安全性缺陷或漏洞的专用程序。扫描器不是直接攻击网络漏洞的程序, 而是用来帮助用户 (包括合法和非法的用户)发现目标的某些内在的弱点。一个较好的扫描器侦测功能比较强, 一般具有发现目标主机、目标主机提供有哪些服务以及这些服务存在哪些漏洞的能力。并对所获取的信息进行分析, 可帮助查找目标主机服务所能发现的漏洞, 可直接或间接地了解远程主机存在的安全问题。扫描器扫描 TCP 和 UDP 端口, 并记录反馈, 可以不留痕迹地发现远程服务器中各种 TCP 或 UDP 端口的分配、提供的服务和它们的软件版本。这就能间接地或直观地了解到远程主机所存在的安全问题。对于黑客来说,端口扫描是一种获得主机信息的好方法; 对于系统管理员来说能够及时发现网络的弱点, 对加强系统的安全性有很大的帮助。常用的端口扫描工具有 $\mathrm{Su}^{-}$ perScan、X-Scan 和 Fluxay (流光)等。

根据端口扫描利用的技术,可将扫描分成以下类型：

## 1. TCP connect ( ) 扫描

这是最基本的 TCP 扫描。操作系统提供的 connect()系统调用,用来与每一个感兴趣
的目标计算机的端口进行连接。如果端口处于侦听状态, 那么 connect () 就能成功。否则,这个端口是不能用的, 即没有提供服务。这个技术的一个最大的优点是, 你不需要任何权限。系统中的任何用户都有权利使用这个调用。另一个好处就是速度。如果对每个目标端口以线性的方式, 使用单独的 connect () 调用, 那么将会花费相当长的时间, 你可以通过同时打开多个套接字, 从而加速扫描。使用非阻塞 I/O 允许设置一个低的时间用尽周期, 同时观察多个套接字。但这种方法的缺点是很容易被发觉, 并且被过滤掉。目标计算机的 $\log \mathrm{s}$文件会显示一连串的连接和连接出错的服务消息, 并且能很快地将其关闭。

## 2.TCP SYN 扫描

这种技术通常认为是“半开放”扫描, 因为扫描程序不必要打开一个完全的 TCP 连接。扫描程序发送的是一个 SYN 数据包, 好像准备打开一个实际的连接并等待反应一样。一个 SYN/ACK 的返回信息表示端口处于侦听状态。一个 RST 返回, 表示端口没有处于侦听状态。如果收到一个 SYN/ACK, 则扫描程序必须再发送一个 RST 信号, 来关闭这个连接过程。这种扫描技术的优点在于一般不会在目标计算机上留下记录。但这种方法的一个缺点是,必须要有管理员权限才能建立自己的 SYN 数据包。

## 3.TCP FIN 扫描

一些防火墙和包过滤器会对一些指定的端口进行监视, 有可能 SYN 扫描也不能做到隐秘, 有的程序能检测到这些扫描。然而, FIN 数据包可能会顺利地通过。这种扫描方法的思想是关闭的端口会用适当的 RST 来回复 FIN 数据包。另一方面, 打开的端口会忽略对 FIN 数据包的回复。这种方法和系统的实现有一定的关系。有的系统不管端口是否打开,都回复 RST, 这样, 这种扫描方法就不适用了。

## 4.IP 段扫描

不是直接发送 TCP 探测数据包, 而是将数据包分成两个较小的 IP 段。这样就将一个 $\mathrm{TCP}$ 头分成好几个数据包, 从而过滤器就很难探测到。

## 5.UDP ICMP 端口不能到达扫描

这种方法使用的是 UDP 协议。由于这个协议很简单,所以扫描变得相对比较困难。这是由于打开的端口对扫描探测并不发送一个确认, 关闭的端口也并不需要发送一个错误数据包。幸运的是, 许多主机在你向一个未打开的 UDP 端口发送数据包时, 会返回一个 ICMP_PORT_UNREACH 错误。这样就能发现哪个端口是关闭的。UDP 和 ICMP 错误都不保证能到达, 因此这种扫描器还必须实现在数据包疑似丢失情况下的重传功能。这种扫描方法是很慢的并且需要具有管理员权限。

## 6.ICMP echo 扫描

这并不是真正意义上的扫描, 因为 ICMP 没有得到端口的信息。但有时通过 ping 命令,可以判断在一个网络上目标主机是否在运行。

### 10.2.2 漏洞扫描

漏洞是指硬件、软件或策略上的缺陷, 从而可使攻击者能够在未经授权的情况下访问系统。漏洞涉及的范围很广, 涉及到网络的各个环节、各个方面, 包括: 路由器、防火墙、操作系统、客户和服务器软件。比如一台提供网上产品搜索的 Web 服务器, 就需要注意操作系统、数据库系统、 $\mathrm{Web}$ 服务软件及防火墙。
漏洞扫描器是一种自动检测远程或本地安全漏洞的软件,通过漏洞扫描器, 可以自动发现系统的安全漏洞。网络攻击者利用漏洞扫描来搜集目标系统的漏洞信息,为下一步攻击做准备。常见的漏洞扫描技术有 CGI 漏洞扫描、弱口令扫描、操作系统漏洞扫描和数据库漏洞扫描等。一些黑客或安全人员为了更快地查找网络系统中的漏洞, 会针对某个漏洞开发专用的漏洞扫描工具,例如 X-Scan。

下面以 X-Scan 为例,来介绍漏洞扫描。

$\mathrm{X}-\mathrm{S} c$ an 是一个完全免费漏洞扫描软件, 由 “安全焦点”开发。对于黑客们来讲, X-Scan 是一款非常优秀的扫描器了。现在的版本为 X-Scan v3.3。

该软件系统要求:Windows NT/2000/XP/2003, 理论上可运行于 Windows NT 系列操作系统,推荐运行于 Windows 2000 以上的 Server 版 Windows 系统。

该软件采用多线程方式对指定 IP 地址段 (或单机)进行安全漏洞检测, 支持插件功能,提供了图形界面和命令行两种操作方式。扫描内容包括: 远程服务类型、操作系统类型及版本, 各种弱口令漏洞、后门、应用服务漏洞、网络设备漏洞和拒绝服务漏洞等二十几个大类。对于多数已知漏洞, 给出了相应的漏洞描述、解决方案及详细描述链接。X-Scan v3. 3 的主界面如图 10-1 所示。



图 10-1 X-Scan v3. 3 工具软件的主界面

可以利用该软件对系统存在的一些漏洞进行扫描,选择菜单栏设置下的菜单项“扫描参数”, 扫描参数中检测范围设置如图 10-2 所示, 扫描模块设置窗口如图 10-3 所示, 设置完毕
后, 进行漏洞扫描, 点击工具栏上的“开始”图标, 开始对目标主机进行扫描, 如图 10-4 所示,最终扫描结果如图 10-5 所示。



图 10-2 检查范围设置窗口



图 10-3 扫描模块设置窗口



图 10-4 开始扫描



图 10-5 漏洞扫描结果
根据 X-Scan 扫描发现的漏洞就可以实施系统人侵。

### 10.2.3 网络监听

网络监听的目的是截获通信的内容, 监听的手段是对协议进行分析。网络监听, 通常也称为网络唣探,即监视探听。黑客利用它, 就有可能在信息以明文方式传输时, 利用网络监听来进行攻击。因为在网络上, 监听的设置可以在任何一个位置, 但比较理想的地方是在网关、路由器和防火墙之类的设备处。所以, 当黑客将网络接口设置为监听模式时, 就很容易截获网上的信息。如果黑客截获了用户的口令, 他就有可能登录某主机系统, 并窃取直级用户的权限,获得重要信息。

嗅探器的英文名称是 Sniff, 可以理解为一个安装在计算机上的窃听设备, 它可以用来窃听计算机在网络上所传送的信息。计算机网络嗅探器则可以窃听计算机程序在网络上发送和接收到的数据, 不过这些数据是大量无意义的二进制数据。必须使用特定的网络协议来分析嗅探到的数据, 只有这样才能够进行正确的解码。Sniffer pro 就是一个完善的网络监听工具。

监听器 Sniffer 的原理: 在局域网中与其他计算机进行数据交换的时候, 发送的数据包发往所有连在一起的主机, 也就是广播, 在报头中包含目标机的正确地址。因此只有与数据包中目标地址一致的那台主机才会接收数据包, 其他的机器都会将包丢弃。但是, 当主机工作在监听模式下时, 无论接收到的数据包中目标地址是什么, 主机都将其接收下来。然后对数据包进行分析, 就得到了局域网中通信的数据。一台计算机可以监听同一网段所有的数据包,但不能监听不同网段的计算机传输的信息。

防止监听的手段是: 建设交换网络、使用加密技术和使用一次性口令技术。

除了非常著名的监听软件 Sniffer Pro 以外,还有一些常用的监听软件: 嗅探经典 Iris; 密码监听工具—Win Sniffer; 密码监听工具—psw monitor 和非交换环境局域网的 fssniffer 等等。Sniffer Pro 是一款非常著名的监听工具, 但是 Sniffer Pro 不能提取有效的信息。

### 10.2.4 口令破译

口令认证是计算机网络中安全管理的重要组成部分, 目前很多网络环境都利用口令认证机制来管理用户人网。口令是用来确认用户身份的一种最常用方法, 由于它的输人和管理方式简单,一直广泛应用于网络安全。但是它有脆弱性,一旦人侵者或黑客获得了一个用户尤其是管理员的账号及口令, 就可以非法闯人网络系统, 进行肆意地破坏, 给整个网络系统带来不可估量的损失。因此口令破译成了黑客常用的一种入侵手段。

常见的口令破译形式:

(1)猜解简单口令: 很多人使用自己或家人的生日、电话号码、房间号码、简单数字或者身份证号码中的几位; 也有的人使用自己、孩子、配偶或宠物的名字; 还有的系统管理员使用 “password”,甚至不设密码,这样黑客可以很容易通过猜想得到密码。

(2)字典攻击: 如果猜解简单口令攻击失败后, 黑客开始试图字典攻击, 即利用程序尝试字典中的单词的每种可能。字典攻击可以利用重复的登录或者收集加密的口令,并且试图同加密后的字典中的单词匹配。黑客通常利用一个英语词典或其他语言的词典。他们也使
用附加的各类字典数据库, 比如名字和常用的口令。

(3) 暴力猜解: 同字典攻击类似, 黑客尝试所有可能的字符组合方式。一个由 4 个小写字母组成的口令可以在几分钟内被破解, 而一个较长的由大小写字母组成的口令, 包括数字和标点, 其可能的组合达 10 万亿种。如果每秒钟可以试 100 万种组合, 可以在一个月内破解。

常用的口令破译工具有:

(1) LophtCrack: 它是目前破译 Windows NT 系列操作系统用户口令最好的黑客软件。

(2) Net Cat: 对系统管理人员及网络调试人员而言,它是一个非常有用的工具。因为功能强大,黑客们称之为“黑客的瑞士军刀”。

(3) Fluxay (流光): 是一个功能强大的渗透测试工具, 具有应用上的综合性和灵活性。同时, 它还是一款免费软件。

以 Fluxay 5.0 为例,介绍暴力破解的实现方法。在图 10-6 所示的主操作窗口中, 选择 “探测”菜单下的“扫描 POP3/FTP/NT/SQL 主机”, 打开如图 10-7 所示的 “主机扫描设置”对话框。在“扫描范围”中分别填写“开始地址”与 “结束地址”, 同时在“扫描主机类型”选择下拉列表中选择 “NT/98”选项, 并选择 “常用密码扫描” 和 “将扫描成功的结果加人当前设置”,按“确定”按钮后, 系统进行扫描。扫描结果如图 10-8 所示。



图 10-6 Fluxay 5.0 的操作界面



图 10-7 设置扫描主机



图 10-8 显示扫描结果

同时, 在 Fluxay 5.0 窗口左上角列表框中的“辅助主机”下的“IPC \$ 主机”中会显示已发现的主机 IP 地址。在已发现主机的 IP 地址中选中一个 IP 地址, 单击鼠标右键在出现的快捷菜单中选择“探测” $\rightarrow$ “探测 IPC $\$$ 用户列表” 命令, 如图 10-9 所示。在弹出的窗口中选择 “仅探测 Administrators 组的用户”, 然后等几十秒(若待扫描主机比较多可能需要几分钟), 探测结果如图 10-10 所示。根据已探测出的用户名和口令便可以进行远程人侵。



图 10-9 进行探测 IPC \$ 用户列表



图 10-10 探测结果



### 10.3.1 拒绝服务攻击

拒绝服务攻击 (Denial of Service, 即 DoS ) 即攻击者想办法让目标机器停止提供服务或资源访问。这些资源包括磁盘空间、内存、进程甚至网络带宽, 从而阻止正常用户的访问。它是一种简单的破坏性攻击, 它的技术含量低, 攻击效果明显。通常黑客利用 TCP/IP 中的某种漏洞, 或者系统存在的某些漏洞, 对目标系统发起大规模的攻击, 且攻击目标失去工作能力, 使得系统不可访问因而合法用户不能及时得到应得的服务或系统资源, 如 CPU 处理时间与网络带宽等。它最本质的特征是延长正常的应用服务的等待时间。拒绝服务攻击问题也一直得不到合理的解决, 这是由于网络协议本身的安全缺陷造成的, 因而拒绝服务攻击也成为攻击者的终极手法。

攻击者进行拒绝服务攻击, 实际上是让服务器实现两种效果: 一是迫使服务器的缓冲区满, 不接收新的请求; 二是使用 IP 欺骗, 迫使服务器把合法用户的连接复位, 影响合法用户的连接。

常见的拒绝服务攻击方式有以下几种:

## 1.SYN Flood

SYN Flood 是当前最流行的 $\operatorname{DoS}$ (拒绝服务攻击)与 $\mathrm{DDoS}$ (Distributed Denial of Service, 分布式拒绝服务攻击) 的方式之一, 这是一种利用 TCP 协议缺陷, 发送大量伪造的 TCP 连接请求, 使被攻击方资源耗尽 (CPU 满负荷或内存不足)的攻击方式。

SYN Flood 攻击的过程在 TCP 协议中被称为三次握手 (Three-way Handshake), 而 SYN Flood 拒绝服务攻击就是通过三次握手实现的。

操作步骤:

(1) 攻击者向被攻击服务器发送一个包含 SYN 标志的 TCP 报文, SYN (Synchronize)即同步报文。同步报文会指明客户端使用的端口以及 TCP 连接的初始序号。这时同被攻击服务器建立了第一次握手。

(2)受害服务器在收到攻击者的 SYN 报文后, 将返回一个 SYN +1 的 ACK 报文, 表示攻击者的请求被接受, 同时 TCP 序号被加 1, ACK (Acknowledgemem) 即确认, 这样就同被攻击服务器建立了第二次握手。

(3) 攻击者也返回一个确认报文 ACK 给受害服务器, 同样 TCP 序列号被加 1 , 到此一个 TCP 连接完成, 三次握手完成。

其中的具体原理是: TCP 连接的三次握手中, 假设一个用户向服务器发送了 SYN 报文后突然死机或掉线, 那么服务器在发出 SYN +1 的 ACK 应答报文后是无法收到客户端的 ACK 报文的(第三次握手无法完成), 这种情况下服务器端一般会重试(再次发送 SYN +1 的 ACK 给客户端) 并等待一段时间后丢弃这个未完成的连接。这段时间的长度我们称为 SYN Timeout, 一般来说这个时间是分钟的数量级 (大约为 30 秒 2 分钟); 一个用户出现异常导致服务器的一个线程等待一分钟并不是什么很大的问题。但如果有一个恶意的攻击
者大量模拟这种情况 (伪造 IP 地址), 服务器端将会为了维护一个非常大的半连接列表而消耗非常多的资源。即使是简单的保存并遍历也会消耗非常多的 CPU 时间和内存,何况还要不断对这个列表中的 IP 进行 SYN +1 的 ACK 的重试。实际上如果服务器的 TCP/IP 栈不够强大, 最后的结果往往是堆栈溢出崩溃一一即使服务器端的系统足够强大, 服务器也将忙于处理攻击者伪造的 TCP 连接请求而无暇理睬客户的正常请求(毕竟客户端的正常请求比率非常之小), 此时从正常客户的角度看来, 服务器失去响应, 这种情况就称作: 服务器端受到了SYN Flood 攻击(SYN 洪水攻击)。

## 2.IP 欺骗 DoS 攻击

这种攻击利用 RST 位来实现。假设现在有一个合法用户(61.61.61.61)已经同服务器建立了正常的连接, 攻击者构造攻击的 TCP 数据, 伪装自己的 IP 为 61.61 .61 .61 , 并向服务器发送一个带有 RST 位的 TCP 数据段; 服务器接收到这样的数据后, 认为从 61.61.61. 61 发送的连接有错误, 就会清空缓外区中建立好的连接。这时, 如果合法用户 61.61 .61 .61 再发送合法数据, 服务器就已经没有这样的连接了, 该用户就必须重新开始建立连接。攻击时, 攻击者会伪造大量的 IP 地址, 向目标发送 RST 数据, 使服务器不对合法用户服务从而实现受害服务器的拒绝服务攻击。

## 3.UDP 洪水攻击

攻击者利用简单的 TCP/IP 服务, 如 Chargen 和 Echo 来传送毫无用处的占满带宽的数据。通过伪造与某一主机的 Chargen 服务之间的一次 UDP 连接, 回复地址指向开着 Echo 服务的一台主机, 这样就生成在两台主机之间存在很多的无用数据流。这些无用数据流就会导致带宽的服务攻击。

## 4.Ping 洪流攻击

由于在早期阶段, 路由器对包的最大尺寸都是有限制的。许多操作系统对 TCP/IP 栈的实现在 ICMP 包上都是规定 $64 \mathrm{~KB}$, 并且在对包的标题头进行读取之后, 要根据该标题头的信息来为有效载荷生成缓冲区。当产生畸形时, 声称自己的尺寸超过 ICM P 上限的包也就是加载的尺寸超过 $64 \mathrm{~KB}$ 上限时, 就会出现内存分配错误, 导致 $\mathrm{TCP} / \mathrm{IP}$ 堆栈崩溃, 致使接受方死机。

## 5. 泪滴 (teardrop) 攻击

泪滴攻击是利用在 $\mathrm{TCP} / \mathrm{IP}$ 堆栈中实现信任 IP 碎片中数据包的标题头所包含的信息来实现的攻击。IP 分段含有指明该分段所包含的是原包的哪一段的信息。某些 TCP/IP (包括 Service Pack 4 以前的 NT) 在收到含有重叠偏移的伪造分段时将崩溃。

## 6.Land 攻击

Land 攻击原理是: 用一个特别打造的 SYN 包, 它的源地址和目标地址都被设置成某一个服务器地址。此举将导致接受服务器向它自己的地址发送 SYN - ACK 消息。结果这个地址又发回 ACK 消息并创建一个空连接。被攻击的服务器每接收一个这样的连接都将保留,直到溢出。

## 7.Smurf 攻击

一个简单的 Smurf 攻击原理就是使用将回复地址设置成受害网络的广播地址的 IC M P 应答请求 (Ping) 数据包来淹没受害主机, 最终导致该网络的所有主机都对此 ICM P 应答请求作出答复, 导致网络阻塞。它比 Ping of death 洪水的流量高出 1 或 2 个数量级。更加复
杂的 Smurf 将源地址改为第三方的受害者, 最终导致第三方崩溃。

## 8.Fraggle 攻击

原理: Fraggle 攻击实际上就是对 Smurf 攻击作了简单的修改,使用的是 UDP 应答消息而非 ICMP。

## 9. 垃圾邮件

攻击者利用邮件系统制造垃圾信息, 甚至通过专门的邮件炸弹 (Mail Bomb) 程序给受害用户的信箱发送垃圾信息,耗尽用户信箱的磁盘空间,使用户无法应用这个信箱。

## 10. 分布式拒绝服务攻击 (Distributed Denial of Service,DDoS)。

分布式拒绝服务攻击是指植人后门程序从远处遥控攻击, 攻击者从多个已人侵的跳板主机控制数个代理攻击主机, 是 $\operatorname{DoS}$ 的特殊形式的拒绝服务攻击, 是一种分布、协作的大规模攻击方式, 主要针对比较大的站点, 如商业公司、搜索引擎和政府部门的站点。DoS 攻击只要一台连接网络的单机就可实现, 而 DDoS 攻击是利用一批受控制的机器向同一台机器发起攻击,因此这样的攻击难以防备,具有较大的破坏性。

### 10.3.2 后门和特洛伊木马攻击

后门程序攻击是指攻击者躲过日志,使自己重返被人侵系统的技术。后门程序的种类很多, 常见的有: 调试后门程序、管理后门程序、恶意后门程序、服务后门程序、文件系统后门程序、内核后门程序等。

木马一词来自于“特洛伊木马” (trojan horse), 据说希腊人围攻特洛伊城, 久久无法攻下。后来军师想出了一个特洛伊木马计, 让士兵藏匿于巨大的特洛伊木马中, 大部队假装撤退而将木马丢弃在特洛伊城下。城中得知解围的消息后, 遂将 “木马”作为奇异的战利品拖人城内, 全城饮酒狂欢。到午夜时分, 全城军民进人梦乡, 匿于木马中的将士从木马里悄悄出来, 并与城外部队里应外合攻下特洛伊城。由于特洛伊木马程序的功能和此类似, 故而得名。

特洛伊木马就是一种后门程序, 通过伪造合法的程序, 偷偷侵人用户系统从而获得系统的控制权。它提供某些功能作为诱饵, 当目标计算机启动时木马程序随之启动, 然后在某一特定的端口监听, 通过监听端口收到命令后, 木马程序会根据命令在目标计算机上执行一些操作, 如传送或删除文件, 窃取口令, 重新启动计算机等。随着互联网的迅速发展, 特洛伊木马的攻击、危害性越来越大。特洛伊木马实质上是一个程序, 必须运行后才能工作, 所以会在进程表、注册表中留下一定的痕迹。

特洛伊木马程序采用 $\mathrm{C} / \mathrm{S}$ 模式工作, 它包括服务端和客户端两个程序, 缺掉其中任何一个都很难发生攻击, 因为木马不具有传染性, 所以服务器端程序是以其他方式进人被人侵的计算机, 当服务器端置人被攻击机后, 会在一定情况下开始运行 (如用户主动运行或重新启动电脑, 因为很多木马程序会自动加人到启动信息中), 这时它就在被攻击机上打开一个 1024 以上端口(大多数的端口号都在 5000 以上), 并一直监听这个端口, 等待客户机端连接。木马的客户端一般运行在攻击机上, 当攻击机上的客户端向被攻击机上的这一端口提出连接请求时, 被攻击机上的服务端就会自动运行, 来应答攻击机的请求。如果服务端在该端口收到数据, 就对这些数据进行分析, 然后按识别后的命令在被攻击机上执行相应的操作, 如窃取用户名和口令、复制或删除文件、重新启动或关闭计算机等。木马隐藏着可以控
制被攻击的系统危害系统安全的功能,可能造成对方资料和信息的泄漏、破坏,甚至使整个系统崩溃。

### 10.3.3 缓冲区溢出攻击

溢出攻击可以说是攻击者的最爱, 是被攻击者使用最多的攻击漏洞。因为它是一个非常具有危险性的漏洞,造成溢出后一般可以或取一个 shell, 从而计算机就被人侵者完全控制。接下来认识一下缓冲区溢出攻击。

缓冲区是内存中存放数据的地方。在程序试图将数据放到计算机内存中的某一个地方时, 因为没有足够的空间就会发生缓冲区溢出, 而人为溢出则是攻击者编写一个超出缓冲区长度的字符串, 然后植人缓冲区, 这样就可能导致两种结果。一是过长的字符串覆盖了相邻的存储单元引起程序运行错误, 有时可能导致系统崩溃; 另一方面是, 通过字符串植人缓冲区,从而获得系统权限, 可以执行任意指令。

在程序试图将数据放到机器内存中的某一个位置的时候, 没有足够的空间就会发生缓冲区溢出。而人为的溢出则是有一定企图的, 黑客写一个超过缓冲区长度的字符串, 然后植人到缓冲区, 而再向一个有限空间的缓冲区中植人超长的字符串可能会出现两个结果, 一是过长的字符串覆盖了相邻的存储单元, 引起程序运行失败, 严重的可导致系统崩溃; 另有一个结果就是利用这种漏洞可以执行任意指令, 甚至可以取得系统高级用户权限。缓冲区溢出成为远程攻击的主要手段其原因在于缓冲区溢出漏洞给予了黑客他所想要的一切: 植人并且执行攻击代码。被植人的攻击代码以一定的权限运行有缓冲区溢出漏洞的程序, 从而得到被攻击主机的控制权。大多造成缓冲区溢出的原因是程序中没有仔细检查用户输人参数。

## 10.

### 10.4.1 安全防范

互联网存在有意或无意的攻击,使得网络安全尤其重要,如何进行安全防范,需要考虑以下几个方面。

## 1. 安全管理

网络管理人员的疏忽大意,网络管理的不规范都会造成不安全的漏洞, 因此必须加强内部的网络安全管理, 需要统一的安全管理策略和专门的网络安全管理人员。管理员常常需要关注和解决的就是整个系统中最弱的环节, 必须强化系统管理员的口令管理, 为每一个使用系统计算机的人员建立不同的用户帐户, 不建立多个用户共享的帐户。明确各个用户访问的权限, 包括可以登录的机器, 登录的时间, 口令失效时间, 用户超时处理等等。对网络上的共享文件目录, 重要的系统文件设置对不同用户有着不同的可访问权限。利用系统的网络安全审查功能, 随时监控网络的登录情况, 进行详细的网络日志记录, 及时发现网络安全隐患并加以及时的纠正。设定的安全制度必须要得到彻底的贯彻, 只有通过安全政策的确定和实施, 明确在全局环境中网络安全的防御边界, 明确不同的 “人”的责任和权限, 才能保
证预定的安全技术手段能够起到应尽的作用。

## 2. 谨慎开放缺乏安全保障的应用和端口

很多黑客攻击程序是针对特定服务和特定服务端口的, 开放的服务越多,系统被攻破的风险越大, 应以尽量少的服务来提供最大的功能, 所以关闭不必要的服务和服务端口, 能大大降低遭受网络攻击的风险。

## 3. 确保数据的安全

通过加密算法对数据处理过程进行加密, 并采用数字签名及认证来确保数据的安全。

## 4. 利用防火墙设置安全边界的防护能力

设置防火墙是目前在互联网络中防范非法进人的最有效方法之一。事实上, 在 Internet 上的 Web 网站, 超过三分之一的 Web 网站都是由某种形式的防火墙加以保护, 这是对网络防范最严, 安全性较强的一种方式。任何关键性的服务器, 都建议放在防火墙之后。任何对关键服务器的访问都必须通过代理服务器, 这虽然降低了服务器的交互能力, 但为了安全, 这点牺牲是值得的。

## 5. 通过安全监测系统进行经常性的系统检查、记录系统运行状况

为系统中的各项服务设置日志, 并经常检查日志的内容以发现异常, 是防范网络人侵的基本手段。定期分析系统日志, 能够让我们尽早地警惕可疑行为, 及时杜绝安全漏洞; 当安全策略中的漏洞引起系统出现安全故障时, 可根据日志信息进行系统分析和事件追踪, 找出安全漏洞。对系统日志的检查方式取决于网络的规模和安全的需要。可以使用操作系统提供的系统日志功能, 也可以使用网络安全监测系统产品。在网络安全监测系统产品中通常都带有日志分析工具。另外对于大型网络或服务器, 日志的信息量可能相当大, 因此要有数据的维护办法。网络传输的信息也可记人日志, 以便发生安全事件时检查。安全监测除了能够记录日志信息外还能够发现正在进行的攻击行动, 及时发现网络遭受攻击情况并加以追踪和防范,避免对网络造成更大损失。

## 6. 用安全管理软件测试自己的站点

测试网络安全的最好方法是自己尝试进攻自己的系统, 并且不是做一次, 而是定期地做,最好能在人侵者发现安全漏洞之前自己先发现。如果我们从 Internet 上下载一个口令攻击程序并利用它, 这可能会更有利于我们对口令的选择。如果能在人侵者之前自己已经发现并更改了不好的或易猜测的口令, 这是再好不过的了。

## 7. 请第三方评估机构或专家来完成网络安全的评估

这样做的好处是能对自己所处的环境有个更加清醒的认识,把未来可能的风险降到最小。

## 8 . 做好数据的备份工作

这是非常关键的一个步骤, 有了完整的数据备份, 在遭到攻击或系统出现故障时才可能迅速恢复系统。

### 10.4.2 安全监测技术

## 1. 安全监测概述

网络安全监测工具是防范网络人侵的有力手段, 它们帮助系统管理员发现系统的漏洞,监视系统异常的行为, 以及追查安全事件。网络安全监测系统的基本功能包括检测出正在
发生的攻击活动; 发现攻击活动的范围和后果; 诊断并发现攻击者的人侵方式和人侵地点,并给出解决建议,以及收集并记录人侵的活动证据。

人侵检测系统 (IDS) 是一种网络监测系统, 当有敌人或者恶意用户试图通过 Internet 进人网络甚至计算机系统时, IDS 能够检测出来,并进行报警, 通知网络该采取措施进行响应。

## 2.入侵检测系统

(1)基本概念

人侵检测 (Intrusion Detection), 顾名思义,便是对人侵行为的发觉。它通过对计算机网络或计算机系统中的若干关键点收集信息并对其进行分析, 从中发现网络或系统中是否有违反安全策略的行为和被攻击的迹象。进行人侵检测的软件与硬件的组合便是人侵检测系统(Intrusion Detection System, 简称 IDS)。与其他安全产品不同的是, 人侵检测系统需要更多的智能, 它必须可以将得到的数据进行分析, 并得出有用的结果。一个合格的人侵检测系统能大大地简化管理员的工作,保证网络安全的运行。

具体说来,人侵检测系统的主要功能有:

1)监测并分析用户和系统的活动;

2)核查系统配置和漏洞;

3) 评估系统关键资源和数据文件的完整性;
4) 识别已知的攻击行为;

$5)$ 统计分析异常行为;

6)操作系统日志管理,并识别违反安全策略的用户活动。

(2) 人侵检测系统的类型和性能比较

根据人侵检测的信息来源不同,可以将人侵检测系统分为两类:基于主机的人侵检测系统和基于网络的人侵检测系统。

基于主机的人侵检测系统: 主要用于保护运行关键应用的服务器。它通过监视与分析主机的审计记录和日志文件来检测人侵。日志中包含发生在系统上的不寻常和不期望活动的证据, 这些证据可以指出有人正在人侵或已成功人侵了系统。通过查看日志文件, 能够发现成功的人侵或人侵企图,并很快地启动相应的应急响应程序。

基于网络的人侵检测系统: 主要用于实时监控网络关键路径的信息, 它监听网络上的所有分组来采集数据, 分析可疑现象。

(3) 人侵检测技术

对各种事件进行分析, 从中发现违反安全策略的行为是人侵检测系统的核心功能。从技术上, 人侵检测分为两类:一种基于标志 (signature-based), 另一种基于异常情况 (anomaly-based)。

基于标志的检测也称为特征检测, 对于基于标志的检测技术来说,首先要定义违背安全策略的事件的特征,如网络数据包的某些头信息。检测主要判别这类特征是否在所收集到的数据中出现。此方法非常类似杀毒软件。

而基于异常的检测技术则是先定义一组系统“正常”情况的数值,如 CPU 利用率、内存利用率、文件校验和等 (这类数据可以人为定义, 也可以通过观察系统、并用统计的办法得出), 然后将系统运行时的数值与所定义的 “正常” 情况比较, 得出是否有被攻击的迹象。这种检测方式的核心在于如何定义所谓的 “正常”情况。
两种检测技术的方法、所得出的结论有非常大的差异。基于异常的检测技术的核心是维护一个知识库。对于已知的攻击, 它可以详细、准确的报告出攻击类型, 但是对未知攻击却效果有限, 而且知识库必须不断更新。基于异常的检测技术则无法准确判别出攻击的手法,但它可以(至少在理论上可以)判别更广范、甚至未发觉的攻击。

(4) 人侵检测的步骤

入侵检测系统的作用是实时地监控计算机系统的活动, 发现可疑的攻击行为, 以避免攻击的发生, 或减少攻击造成的危害。由此也划分了人侵检测的三个基本步骤: 信息收集、数据分析和响应。

## 1)信息收集

人侵检测的第一步就是信息收集, 收集的内容包括整个计算机网络中系统、网络、数据及用户活动的状态和行为。

人侵检测很大程度上依赖于收集信息的可靠性和正确性, 因此, 很有必要只利用所知道的真正的和精确的软件来报告这些信息。因为黑客经常替换软件以搞混合移走这些信息,例如替换被程序调用的子程序、记录文件和其他工具。黑客对系统的修改可能使系统功能失常并看起来跟正常的一样。例如, U NIX 系统的 PS 指令可以被替换为一个不显示侵人过程的指令, 或者是编辑器被替换成一个读取不同于指定文件的文件 (黑客隐藏了初始文件并用另一版本代替) 。这需要保证用来检测网络系统的软件的完整性, 特别是人侵检测系统软件本身应具有相当强的坚固性，防止被篡改而收集到错误的信息。人侵检测利用的信息一般来自以下三个方面(这里不包括物理形式的人侵信息):

(1)系统和网络日志文件

黑客经常在系统日志文件中留下他们的踪迹, 因此, 可以充分利用系统和网络日志文件信息。日志中包含发生在系统和网络上的不寻常和不期望活动的证据, 这些证据可以指出有人正在人侵或已成功人侵了系统。通过查看日志文件, 能够发现成功的人侵或人侵企图,并很快地启动相应的应急响应程序。日志文件中记录了各种行为类型, 每种类型又包含不同的信息,例如记录“用户活动”类型的日志,就包含登录、用户 ID 改变、用户对文件的访问、授权和认证信息等内容。很显然地, 对用户活动来讲, 不正常的或不期望的行为就是重复登录失败、登录到不期望的位置以及非授权的企图访问重要文件等等。

(2)非正常的目录和文件改变

网络环境中的文件系统包含很多软件和数据文件, 他们经常是黑客修改或破坏的目标。目录和文件中非正常改变 (包括修改、创建和删除), 特别是那些正常情况下限制访问的, 很可能就是一种人侵产生的指示和信号。黑客经常替换、修改和破坏他们获得访问权的系统上的文件, 同时为了隐藏系统中他们的表现及活动痕迹, 都会尽力去替换系统程序或修改系统日志文件。

(3)非正常的程序执行

网络系统上的程序执行一般包括操作系统、网络服务、用户启动的程序和特定目的的应用, 例如 Web 服务器。每个在系统上执行的程序由一到多个进程来实现。一个进程的执行行为由它运行时执行的操作来表现, 操作执行的方式不同, 它利用的系统资源也就不同。操作包括计算、文件传输、设备和其他进程,以及与网络间其他进程的通讯。

一个进程出现了不期望的行为可能表明黑客正在人侵你的系统。黑客可能会将程序或
服务的运行分解,从而导致其失败,或者是以非用户或管理员意图的方式操作。

2)数据分析

数据分析 (Analysis Schemes) 是人侵检测系统的核心, 它的效率高低直接决定了整个人侵检测系统的性能。一般通过三种技术手段进行分析: 模式匹配, 统计分析和完整性分析。其中前两种方法用于实时的人侵检测, 而完整性分析则用于事后分析。具体的技术形式如下所述：

模式匹配就是将收集到的信息与已知的网络人侵和系统误用模式数据库进行比较, 从而发现违背安全策略的行为。该过程可以很简单(如通过字符串匹配以寻找一个简单的条目或指令), 也可以很复杂 (如利用正规的数学表达式来表示安全状态的变化)。一般来讲,一种进攻模式可以用一个过程 (如执行一条指令)或一个输出(如获得权限)来表示。该方法的一大优点是只需收集相关的数据集合, 显著减少系统负担, 且技术已相当成熟。它与病毒防火墙采用的方法一样, 检测准确率和效率都相当高。但是, 该方法存在的弱点是需要不断的升级以对付不断出现的黑客攻击手法,不能检测到从未出现过的黑客攻击手段。

统计分析首先给信息对象 (如用户、连接、文件、目录和设备等)创建一个统计描述,统计正常使用时的一些测量属性 (如访问次数、操作失败次数和延时等) 。测量属性的平均值将被用来与网络、系统的行为进行比较, 任何观察值在正常偏差之外时, 就认为有人侵发生。例如, 统计分析可能标识一个不正常行为, 因为它发现一个在晚八点至早六点不登录的帐户却在凌晨两点试图登录。其优点是可检测到未知的人侵和更为复杂的人侵, 缺点是误报、漏报率高,且不适应用户正常行为的突然改变。

完整性分析主要关注某个文件或对象是否被更改,包括文件和目录的内容及属性,在发现被更改的、被安装木马的应用程序方面特别有效。完整性分析利用强有力的加密机制, 称为消息摘要函数 (例如 MD5), 能识别极其微小的变化。其优点是不管模式匹配方法和统计分析方法能否发现人侵, 只要是成功的攻击导致了文件或其他对象的任何改变, 它都能够发现。缺点是一般以批处理方式实现,不用于实时响应。这种方式主要应用于基于主机的人侵检测系统(HIDS)。

3)响应

数据分析发现人侵迹象后, 人侵检测系统的下一步工作就是响应。而响应并不局限于对可疑的攻击者。目前的人侵检测系统一般采取下列响应。

(1)将分析结果记录在日志文件中,并产生相应的报告。

(2)触发警报: 如在系统管理员的桌面上产生一个警告标志位, 向系统管理员发送传呼或电子邮件等等。

(3)修改人侵检测系统或目标系统,如终止进程、切断攻击者的网络连接,或更改防火墙配置等。

(5) 人侵检测系统实例

1) Snort 简介

Snort 是一个强大的轻量级的网络人侵检测系统。作者是 Martin Roesch。最新版本是 2.6.0 版。它具有实时数据流量分析和日志 IP 网络数据包的能力, 能够进行协议分析,对内容进行搜索/匹配。它能够检测各种不同的攻击方式,对攻击进行实时报警。

此外,Snort 具有很好的扩展性和可移植性。还有, 这个软件遵循通用公共许可证

GPL,所以只要遵守 GPL 任何组织和个人都可以自由使用。

2) Snort 的特点

(1) Snort 是一个轻量级的人侵检测系统

(2) Snort 虽然功能强大, 但是其代码极为简洁、短小, 其源代码压缩包只有大约 $110 \mathrm{~KB}$

(3)Snort 的可移植性很好

Snort 的跨平台性能极佳, 目前已经支持 Linux, Solaris, BSD, IRIX, HP - U X, Win2K 等系统。

(4) Snort 的功能非常强大

Snort 具有实时流量分析和日志 IP 网络数据包的能力。能够快速地检测网络攻击, 及时地发出报警。Snort 的报警机制很丰富,例如: syslog、用户指定的文件、一个 UNIX 套接字,还有使用SAMBA 协议向 Windows 客户程序发出WinPopup 消息。利用 XML 插件, Snort 可以使用 SNML(简单网络标记语言, Simple Network Markup Language)把日志存放到一个文件或者适时报警。

Snort 能够进行协议分析, 内容的搜索/匹配。现在 Snort 能够分析的协议有 TCP、 UDP 和 ICMP。将来,可能提供对 ARP、IGRP、GRE、OSPF、RIP、IPX 等协议的支持。它能够检测多种方式的攻击和探测, 例如: 缓冲区溢出、秘密端口扫描、CGI 攻击、SMB 探测、探测操作系统指纹特征的企图等等。

Snort 的日志格式既可以是 tcpdump 式的二进制格式,也可以解码成 ASCII 字符形式,更加便于用户尤其是新手检查。使用数据库输出插件,Snort 可以把日志记人数据库, 当前支持的数据库包括: Postgresql、MySQL、任何 UNIXODBC 数据库, 还有Oracle。

使用 TCP 流插件 (tcpstream), Snort 可以对 TCP 包进行重组。Snort 能够对 IP 包的内容进行匹配, 但是对于 TCP 攻击, 如果攻击者使用一个程序, 每次发送只有一个字节的 TCP 包, 完全可以避开 Snort 的模式匹配。而被攻击的主机的 TCP 协议栈会重组这些数据, 将其送给在目标端口上监听的进程, 从而使攻击包逃过 Snort 的监视。使用 TCP 流插件, 可以对 TCP 包进行缓冲, 然后进行匹配, 使 Snort 具备了对付上面这种攻击的能力。

使用 SPADE(Statistical Packet Anomaly Detection Engine)插件,Snort 能够报告非正常的可疑包, 从而对端口扫描进行有效的检测。

Snort 还有很强的系统防护能力。使用 FlexResp 功能, Snort 能够主动断开恶意连接。

(5)扩展性能较好, 对于新的攻击威胁反应迅速

作为一个轻量级的网络人侵检测系统, Snort 有足够的扩展能力。它使用一种简单的规则描述语言。最基本的规则只是包含四个域:处理动作、协议、方向、注意的端口。

例如: $\log$ tcp any any->10.1.1.0/24 79 。还有一些功能选项可以组合使用, 实现更为复杂的功能。用户可以从 http://www.snort.org 得到其规则集。

Snort 支持插件, 可以使用具有特定功能的报告、检测子系统插件对其功能进行扩展。 Snort 当前支持的插件包括: 数据库日志输出插件、碎数据包检测插件、端口扫描检测插件、 HTTP URI normalization 插件、XML 插件等。

Snort 的规则语言非常简单, 能够对新的网络攻击做出很快的反应。发现新的攻击后,可以很快根据 Bugtraq 邮件列表, 找出特征码, 写出检测规则。因为其规则语言简单, 所以很容易上手, 节省人员的培训费用。

(6)遵循公共通用许可证 GPL

Snort 遵循 GPL, 所以任何企业、个人、组织都可以免费使用它作为自己的 NIDS。

3) Snort 主要参数

命令行是 snort-[options $]$

选项:

-A 设置的模式是 full,fast, 还是 none; full 模式是记录标准的 alert 模式到 alert 文件中; fast 模式只写人时间㘍, messages, IPs, ports 到文件中; none 模式关闭报警。

-a 是显示 ARP包。

$-c$ 使用配置文件,这个规则文件是告诉系统哪些信息要 LOG,或者要报警,或者通过。

$-\mathrm{d}$ 解码应用层。

-e 显示并记录 2 个信息包头的数据。

$-\mathrm{I}$ 使用网络接口参数。

-1 记录 LOG 信息包到目录中去。

$-n$ 是指定在处理 $\mathrm{n}$ 个数据包后退出。

$-\mathrm{N}$ 关闭 LOG 记录,但 alert 功能仍旧正常。

-o 改变所采用的记录文件,如正常情况下采用 ALERT - >PASS - >LOG 的顺序,而采用此选项是这样的顺序: PASS - >ALERT - > LOG, 其中 PASS 是那些允许通过的规则而不记录和报警, ALERT 是不允许通过的规则, LOG 指 LOG 记录。

$-S$ 这个是设置变量值, 这可以用来在命令行定义 Snort rules 文件中的变量, 如你要在 Snort rules 文件中定义变量 HOME_NET,你可以在命令行中给它预定义值。

$-\mathrm{v}$ 使用为 verbose 模式,把信息包打印在 console 中,这个选项使用后,会使速度很慢,在记录多的时候会出现丢包现象。

-? 显示使用列表并退出。

4)Snort 工作模式

Snort 有三种工作模式:

(1)嗅探器模式

嗅探器模式仅仅是从网络上读取数据包并作为连续不断的数据流显示在终端上。如果你只要把 TCP/IP 包头信息打印在屏幕上,只需要输人下面的命令:

./snort ${ }^{-} \mathrm{v}$

使用这个命令将使 Snort 只输出 IP 和 TCP/UDP/ICMP 的包头信息。如果想看到应用层的数据, 可以使用:

./snort -vd

这条命令使 Snort 在输出包头信息的同时显示包的数据信息。如果还要显示数据链路层的信息,就使用下面的命令:

./snort-vde

注意这些选项开关还可以分开写或者任意结合在一块。例如: 下面的命令就和上面最后一条命令等价:

./ snort $-\mathrm{d}-\mathrm{v}-\mathrm{e}$

(2)数据包记录器模式
数据包记录器模式把数据包记录到硬盘上。如果要把所有的包记录到硬盘上, 需要指定一个日志目录, Snort 就会自动对数据包进行日志:

./snort-dev-1./ $/ \log$

当然, $/ \log$ 目录必须存在,否则 Snort 就会报告错误信息并退出。当 Snort 在这种模式下运行, 它会记录所有看到的包将其放到一个目录中, 这个目录以数据包目的主机的 IP 地址命名,例如:192.168.10.1。

如果只指定了-1 命令开关,而没有设置目录名, Snort 有时会使用远程主机的 IP 地址作为目录, 有时会使用本地主机 IP 地址作为目录。为了只对本地网络进行日志, 需要给出本地网络:

./snort-dev $-1 . / \log -\mathrm{h} 192.168 .10 .0 / 24$

这个命令告诉 Snort 把进人 C 类网络 192.168.10 的所有包的数据链路、 TCP/IP 以及应用层的数据记录到目录. $/ \log$ 中。

如果网络速度很快,或者你想使日志更加紧凑以便以后的分析,那么应该使用二进制的日志文件格式。所谓的二进制日志文件格式就是 tcpdump 程序使用的格式。使用下面的命令可以把所有的包日志整合到一个单一的二进制文件中:

./snort $-1 . / \log -\mathrm{b}$

注意此处的命令行和上面的有很大的不同。勿需指定本地网络,因为所有的都被记录到一个单一的文件。不必冗余模式或者使用 $-\mathrm{d} 、 \mathrm{e}$ 功能选项, 因为数据包中的所有内容都会被记录到日志文件中。

可以使用任何支持 tcpdump 二进制格式的嗅探器程序从这个文件中读出数据包, 例如: tcpdump 或者 Ethereal。使用-r 功能开关, 也能使 Snort 读出包的数据。Snort 在所有运行模式下都能够处理 tcpdump 格式的文件。例如: 如果想在嗅探器模式下把一个 tcpdump 格式的二进制文件中的包打印到屏幕上,可以输人下面的命令:

./snort-dv-r packet.log

在日志包和入侵检测模式下, 通过 BPF (BSD Packet Filter) 接口, 可以使用许多方式维护日志文件中的数据。例如, 只想从日志文件中提取 ICMP 包, 只需要输人下面的命令行:

./snort-dvr packet.log icmp

(3)网路人侵检测系统模式

Snort 最重要的用途还是作为网络人侵检测系统 (NIDS), 使用下面命令行可以启动这种模式:

./snort-dev-1./log -h 192.168.10.0/24 -c snort.conf

snort.conf 是规则集文件。Snort 会对每个包和规则集进行匹配,发现这样的包就采取相应的行动。如果不指定输出目录,Snort 就输出到 $/ \mathrm{var} / \log /$ Snort 目录。

注意: 如果想长期使用 Snort 作为自己的人侵检测系统,最好不要使用 $-v$ 选项。因为使用这个选项,使 Snort 向屏幕上输出一些信息,会大大降低 Snort 的处理速度, 从而在向显示器输出的过程中丢弃一些包。

此外, 在绝大多数情况下, 也没有必要记录数据链路层的包头, 所以 $-\mathrm{e}$ 选项也可以不用:

./snort-d -h 192.168.10.0/24-1 ./log -c snort.conf
这是使用 Snort 作为网络人侵检测系统最基本的形式, 日志符合规则的包, 以 ASCII 形式保存在有层次的目录结构中。

网络人侵检测模式下的输出选项在 NIDS 模式下, 有很多的方式来配置 Snort 的输出。在默认情况下, Snort 以 ASCII 格式记录日志, 使用 full 报警机制。如果使用 full 报警机制,Snort 会在包头之后打印报警消息。如果不需要日志包,可以使用 $-\mathrm{N}$ 选项。

Snort 有 6 种报警机制: full、fast、socket、syslog、smb(winpopup) 和 none。其中有 4 个可以在命令行状态下使用- $\mathrm{A}$ 选项设置。这 4 个是:

-A fast :报警信息包括:一个时间翟(timestamp)、报警消息、源/目的 IP 地址和端口。

-A full: 是默认的报警模式。

-A unsock: 把报警发送到一个 UNIX 套接字, 需要有一个程序进行监听, 这样可以实现适时的报警。

-A none: 关闭报警机制。

使用-s 选项可以使 Snort 把报警消息发送到 syslog, 默认的设备是 LOG_AUTHPRIV 和 LOG_ALERT。可以修改 snort.conf 文件修改其配置。

Snort 还可以使用 SMB 报警机制,通过 SAMBA 把报警消息发送到Windows 主机。为了使用这个报警机制, 在运行./configure 脚本时, 必须使用-enable-smbalerts 选项。

下面是一些输出配置的例子:

(1)使用默认的日志方式 (以解码的 ASCII 格式)并且把报警发给 syslog:

./snort-c snort.conf-1 ./log -s -h 192.168.10.0/24

(2)使用二进制日志格式和 SMB 报警机制:

./ snort -c snort.conf-b-M WORKSTATIONS

5) Snort 规则简介

Snort 最重要的用途是作为网络人侵检测系统, 它有自己的规则语言。从语法上看, 这种规则语言非常简单, 但是对于人侵检测来说它足够强大。对于匹配特定规则的数据包, Snort 有三种处理动作: pass、log、alert。

(1)pass:放行数据包

(2) $\log$ :把数据包记录到日志文件

(3)alert:产生报警消息并日志数据包

Snort 的每条规则都可以分成逻辑上的两个部分: 规则头和规则选项。规则头包括: 规则行动 (rules action)、协议 (protocol)、源/目的 IP 地址、子网掩码以及源/目的端口。规则选项包含报警消息和异常包的信息(特征码),使用这些特征码来决定是否采取规则规定的行动。最基本的规则只是包含四个域:处理动作、协议、方向、注意的端口。例如：

$\log$ tep any any $->10.1 .1 .0 / 2479$

这条规则表示: 让 Snort 记录从外部网络到 C 类网址 10.1.1 所有数据包。

Snort 规则中还可以有规则选项 (rule option), 使用规则选项可以定义更为复杂的行为, 实现更加强大的功能。下面是一条含有规则选项的规则。

alert tcp any any $->$ 10.1.1.0/24 80 (content: "/cgi-bin/phf"; msg "PHF probe!")

这条规则用来检测对本地网络 Web 服务器的 PHF 服务的探测,一旦检测到这种探测数据包,Snort 就发出报警消息,并把整个探测包记录到日志。
在规则中, IP 地址的定义也有很大的灵活性。使用 any 关键词表示任何 IP 地址或者端口。一般地, IP 地址可以使用 $x x \cdot x x \cdot x x \cdot x x /$ 子网掩码的形式定义,其中 $x x \cdot x x \cdot x x \cdot x x$ 是由.分割的四个字节的数字。注意不能使用域名方式,Snort 不对域名进行解析。还可以使用非操作符! 对 IP 地址和端口进行操作, 这个操作符就是逻辑非的意思。对于端口, 还可以使用操作符: 限制端口的范围。例如:

alert tcp ! 10.1.1.0/24 any -> 10.1.1.0/24 6000:6010 (msg:"X traffic")警。

这条规则使 Snort 对于从外部网络到内部网络 X-window 服务端口的数据包发出报

关于 Snort 的规则详细的说明可以参考 Snort 的随机文档。

## 实验题

## 实验 10.1 安全审计与安全漏洞扫描实验

一、实验目的

1 . 掌握设置安全审计的方法。

2. 理解扫描器的工作机制和作用; 掌握利用扫描器进行主动探测、收集目标信息的方法; 掌握使用漏洞扫描器检测远程或本地主机安全性弱点; 掌握常用的网络命令。

3 . 了解日志清除工具的使用; 利用日志清除工具远程删除 Windows 的日志文件。

二、实验环境

1. Windows 2000 系统, 局域网环境
2. 扫描器小榕流光软件

3.日志清除工具

三、实验内容

1. Windows 2000 审计日志: 查看 Windows 2000 审计日志, 配置审核策略, 设置日志的大小和行为
2. Windows 攻击实例—net 命令和小榕流光

使用“小榕流光”对目标机器上的 Windows 帐户进行扫描, 然后用 net 命令进行攻击。

3 .审计清除—clearel.exe 的使用

四、操作步骤及工作要点

实验一: Windows 2000 审计日志

1 .查看 Windows 2000 审计日志

2. 配置审核策略
3. 设置日志的大小和行为

实验二: Windows 攻击实例—net 命令和小榕流光

1. 设置流光扫描相关参数

启动小榕流光 5 betal, 扫描一段 IP (在此为扫描一段局域网 IP), 寻找网络中一台 Windows 2000/NT 的主机。

2. 启动扫描, 查看扫描结果
3. 根据扫描结果对目标主机进行探测得到目标主机帐户相关信息

4 . 根据已探测出的用户名和口令用 net 命令进行攻击
实验三: 审计清除

1.查看日志信息

打开 PC 机的 Windows 事件查看器, 可以看到日志中有各种信息的记录。

2 .清除准备: 使用工具 clearel.exe 来清除系统日志, 将该文件上传到对方主机

3 .删除系统日志、安全日志、应用程序日志这三种日志

命令格式为:

Clearel System

Clearel Security

Clearel Application

Clearel All

这四条命令分别删除系统日志、安全日志、应用程序日志和删除全部日志。

五、实验思考题

安全审核的结果记录应在哪里查看?

## 习 题

## 10.1 网络攻击一般经过哪些步骤?

10.2 网络监听技术的原理是什么?

10.3 拒绝服务攻击的原理是什么?

10.4 什么叫入侵检测系统?

10.5 对于收集到的信息,一般用哪三种技术手段来进行分析?

## 实验题参考答案

实验 10.1

安全审核的结果记录应在 “控制面板” $\rightarrow$ “管理工具” $\rightarrow$ “本地安全策略” $\rightarrow$ “本地策略” $\rightarrow$ “策略审核”里查看。

## 习题参考答案

10.1 一次成功的攻击,一般都经过下面这些步骤,但是根据实际情况可以随时调整。

(1) 隐藏 IP: 这一步必须做, 因为如果自己的人侵的痕迹被发现了, 当找上门的时候就一切都晚了。

(2) 踩点扫描: 踩点就是通过各种途径对所要攻击的目标进行多方面的了解 (包括任何可得到的蛛丝马迹,但要确保信息的准确), 确定攻击的时间和地点。

扫描的目的是利用各种工具在攻击目标的 IP 地址或地址段的主机上寻找漏洞。

(3)获得系统或管理员权限: 得到管理员权限的目的是连接到远程计算机, 对其进行控制,达到自己攻击目的。

(4) 种植后门: 为了保持长期对自己胜利果实的访问权, 在已经攻破的计算机上种植一些供自己访问的后门。

(5)在网络中隐身: 一次成功人侵之后,一般在对方的计算机上已经存储了相关的登录日志, 这样就容易被管理员发现。在人侵完毕后需要清除登录日志以及其他相关的日志。

10.2 网络监听技术的原理是: 在局域网中与其他计算机进行数据交换的时候, 发送的数据包发往所有连在一起的主机, 也就是广播, 在报头中包含目标机的正确地址。因此只有与数据包中目标地址一致的那台主机才会接收数据包, 其他的机器都会将包丢弃。但是, 当主机工作在监听模式下时, 无论接收到的数据包中目标地址是什么, 主机都将其接收下来。然后对数据包进行分析, 就得到了局域网中通信的数据。网络监听就是使主机工作在监听模式以监听同一网段所有的数据包。

10.3 拒绝服务攻击的原理是:利用 TCP/IP 中的某种漏洞,或者系统存在的某些漏洞, 对目标系统发起大规模的攻击, 使得攻击目标失去工作能力, 且系统不可访问, 因而合法用户不能及时得到应得的服务或系统资源, 如 CPU 处理时间与网络带宽等。它最本质的特征是延长正常的应用服务的等待时间。

10.4 进行人侵检测的软件与硬件的组合便是人侵检测系统 (Intrusion Detection System,简称 IDS)。

10.5 对于收集到的信息,一般通过三种技术手段进行分析: 模式匹配,统计分析和完整性分析。其中前两种方法用于实时的人侵检测, 而完整性分析则用于事后分析。模式匹配就是将收集到的信息与已知的网络人侵和系统误用模式数据库进行比较, 从而发现违背安全策略的行为。统计分析首先给信息对象 (如用户、连接、文件、目录和设备等)创建一个统计描述, 统计正常使用时的一些测量属性 (如访问次数、操作失败次数和延时等)。测量属性的平均值将被用来与网络、系统的行为进行比较, 任何观察值在正常偏差之外时, 就认为有人侵发生。完整性分析主要关注某个文件或对象是否被更改,包括文件和目录的内容及属性, 在发现被更改的、被安装木马的应用程序方面特别有效。

## IP 与 TCP 安全



教学要求

本章以IETF 安全领域一些工作组的工作内容为背景介绍了 Internet 基础设施安全方面的一些新进展, 使学生能够追踪有关网络安全领域前沿的研究方向和研究课题。通过本章的学习, 了解 DNS 系统实现中的安全问题及其改进, 了解 IP 安全协议工作组 IPSec 的工作内容, 了解网络传输服务的安全性问题。



IP 安全是整个 $\mathrm{TCP} / \mathrm{IP}$ 安全的基础与核心。它可对上层的各种应用服务提供透明的安全保护。IPv4 没有考虑安全性, 缺乏对通信双方身份的认证, 缺乏对传输数据的保护, 并且容易受窃听、IP 地址欺骗等攻击。IPSec 工作组于 1994 年成立, 1995 年 8 月公布了一系列建议标准:

RFC2401:IPSec 协议

RFC2406:ESP

RFC2403: HM AC-M D5-96
RFC2406: A H

RFC2409:IKE

RFC2404: H M AC-SH A-96

### 11.1.1 IPSec 协议凝

IPSec 实际上是一套协议包而不是单个的协议, IPSec 是在 IP 网络上保证安全通信的开放标准框架, 它在 IP 层提供数据源验证、数据完整性和数据保密性。其中比较重要的有 RFC2409 IKE(Internet Key Exchange)互联网密钥交换、RFC2401 IPSec 协议、RFC2402 AH (Authentication Header)验证包头、RFC2406 ESP (Encapsulating Security Payload) 加密数据等协议。IPSec 独立于密码学算法,这使得不同的用户群可以选择不同的一套安全算法。

IPSec 主要由 AH (认证头)协议、ESP (封装安全载荷) 协议以及负责密钥管理的IKE (因特网密钥交换) 协议组成, 其体系结构如图 11-1 所示。A H 为 IP 数据包提供无连接的数据完整性和数据源身份认证。数据完整性通过消息认证码(如 MD5、SHA1) 产生的校验
值来保证, 数据源身份认证通过在待认证的数据中加人一个共享密钥来实现。ESP 为 IP 数据包提供数据的保密性 (通过加密机制) 、无连接的数据完整性、数据源身份认证以及防重防攻击保护。AH 和 ESP 可以单独使用, 也可以配合使用, 通过组合可以配置多种灵活的安全机制。相对来说, ESP 开销较大, 要求使用高强度加密算法, 会受到许多限制。多数情况下, 使用 AH 的认证服务已能满足要求。密钥管理包括 IKE 协议和安全联盟 SA (Security Association) 等部分。IKE 在通信双方之间建立安全联盟, 提供密钥确定、密钥管理机制, 是一个产生和交换密钥材料并协商 IPSec 参数的框架。IKE 将密钥协商的结果保留在 SA 中,供 AH 和 ESP 通信时使用。



图 11-1 IPSec 体系结构图

### 11.1.2 IPSec 的工作方式

IPSec 有两种工作方式: 传输方式 (Transport Mode) 和隧道模式 (Tunnel Mode), A H 和 ESP 均可应用于这两种方式。传输方式通常应用于主机之间端对端通信, 该方式要求主机支持 IPSec。隧道方式应用于网关模式中, 即在主机的网关 (防火墙、路由器) 上加载 IPSec, 这个网关就同时升级为安全网关 (Security Gateway, SG)。

传输模式主要为上层协议提供保护, A H 或 ESP 包头插人在 IP 包头和运输层协议包头之间。其包结构如图 11-2 所示, 显然传输模式下 ESP 并没有对 IP 包头加密处理, 源、目的 IP 地址内容是可见的.而 AH 认证的是整个 IP 头.宗整吽保护强干 ESP。

| 原始IP头 | 传输层包头(TCP/UDP) | 数据 |
| :--- | :--- | :--- |

传输模式应用AH后



图 11-2 传输方式包结构图
在隧道方式下, 整个 IP 包都封装在一个新的 IP 包中, 并在新的 IP 包头和原来的 IP 包头之间插人 IPSec 头 (A H/ESP)。其结构如图 11-3 所示。



隧道方式应用ESP后



图 11-3 隧道方式包头结构

从图 11-3 可以看出, 在隧道模式下, 如果应用了 ESP, 原始 IP 包头是加密的, 真正的源、目的 IP 地址是隐藏的,新 IP 头中指定的源、目的 IP 地址一般是源、目的安全网关的地址。

### 11.1.3 $\mathrm{AH}$ (认证头)

认证头 (Authentication Header, A H) 是一个安全协议头 (如图 11-4 所示), 可在传输模式下使用, 为 IP 包提供数据完整性和认证服务。通过使用数据完整性检查, 可判定数据包在传输过程中是否被修改; 通过使用认证机制, 终端系统或网络设备可对用户或应用进行认证, 过滤通信流; 认证机制还可防止地址欺骗攻击及重播攻击。 $\mathrm{AH}$ 头插在 IP 头和上层协议头(如 TCP 或 UDP 头)之间。

AH 结构如图 11-4 所示, 所有字段都是必须的。各字段含义如下:

| 下一个认证头 | 有效载荷长度 | 保留 |
| :---: | :---: | :---: |
| 安全参数索引 (SPI) |  |  |
| 序列号字段 |  |  |
| 认证数据 |  |  |

图 11-4 认证头

下一个认证头 (8 比特): 标识紧跟认证头的下一个头的类型。

有效载荷长度 (8 比特): 以 32 位字为单位的认证头的长度, 再减去 2 。例如, 缺省的认证数据字段的长度是 96 比特 (3个 32 位字), 加上 3 个字长的固定头, 头部共 6 个字长, 因此该字段的值为 4 。

保留 (16 比特): 为将来使用。

安全参数索引( 32 比特) : 用于标识一个安全关联。

序列号字段 (8 比特): 单增的计数器值。

认证数据(可变): 该字段的长度可变(但应为 32 位字的整数倍), 包含的数据有数据包的 $\operatorname{ICV}$ (完整性校验值)或 MAC。

### 11.1.4 ESP(封装安全有效载荷)

像 AH 一样, 封装安全载荷 (Encapsulating Security Payload) 也是一个安全协议头, 采用加密和认证机制, 为 IP 数据报提供数据源验证、数据完整性、抗重播和机密性安全服务,可在传输模式和隧道模式下使用。 $\mathrm{ESP}$ 头插在 IP 头和上层协议头 (如 TCP 或 UDP 头)之间,隧道模式下,要对整个 IP 包封装, ESP 头位于内外 IP 头之间。

图 11-5 说明了 ESP 的封装, 各部分含义如下:



图 11-5 封装安全有效载荷

安全参数索引 (32 比特): 标识一个安全关联。

序列号字段 (32 比特): 单增的计数器值。

有效载荷数据(可变): 传输层数据段 (传输模式) 或 IP 包(隧道模式), 通过加密受到保护。

填充 ( $0 \sim 255$ 字节): 填充数据包含多到 255 个字节的数据。在以下情况, 填充数据就可能被使用到:

(1) 因加密算法的需要 (获得所需要的输人块大小);

(2)认证数据的大小必须是 32 的倍数;

(3)掩盖实际的有效载荷的长度(防止流量分析)。

填充长度 (8 比特): 表示填充的字节数。

下一信息头 (8 比特): 通过标识载荷中的第一个头 (如 IPv6 中的扩展头, 或诸如 TCP 之类的上层协议头), 决定载荷数据字段中数据的类型。

认证数据(可变): 长度可变的字段(应为 32 位字的整数倍), 用于填人 ICV。ICV 的计算范围为 ESP 包中除掉认证数据字段的部分。

### 11.1.5 IKE(密詮交换)

两台 IPSec 计算机在交换数据之前, 必须首先建立某种约定, 这种约定, 称为安全关联 (SA), 指双方需要就如何保护信息、交换信息等公用的安全设置达成一致, 更重要的是, 必须有一种方法,使那两台计算机安全地交换一套密钥,以便在它们的连接中使用。

IPSec 的密钥管理包括密钥的确定和分配, 有手工和自动两种方式。IPSec 默认的自动密钥管理协议是 IKE。IKE 规定了自动验证 IPSec 对等实体、协商安全服务和产生共享密钥的标准, 其用途是在 IPSec 通信双方之间, 建立起共享安全参数及认证过的密钥 (即建立

“安全关联”)。

IKE 属于一种混合型协议, 由 Internet 安全关联和密钥管理协议 (ISAKMP) 和两种密钥交换协议 OAKLEY 与 SKEME 组成。IKE 创建在由 ISAKMP 定义的框架上, 沿用了 OAKLEY 的密钥交换模式以及 SKEME 的共享和密钥更新技术, 还定义了它自己的两种密钥交换方式。

建立 IKE 分为两个阶段:第一阶段,协商创建一个通信信道(IKE SA), 并对该信道进行验证, 为双方进一步的 IKE 通信提供机密性、消息完整性以及消息源验证服务; 第二阶段,使用已建立的 IKE SA 建立 IPSec SA, 如图 11-6 所示。



图 11-6 IKE 的建立

### 11.1.6 IPSec 的实施

IPSec 可在终端主机、网关/路由器或两者同时进行实施和配置。在需要确保端到端的通信安全时, 在主机实施显得尤为有用。在需要确保网络一部分的通信安全时, 在路由器中实施 IPSec 就显得非常必要, 比如在 VPN 和内联网中。

(1) 主机实施:

优点: 保障端到端的安全性; 能够实现所有的 IPSec 安全模式,即传输模式和隧道模式;能够为数据流提供安全保障; 在 SA 的协商过程中, 能够自己维持用户身份验证的“场景”。

主机实施可分成两类:

IPSec 与操作系统集成实施。IPSec 可当作网络层的一部分来实现。IPSec 层需要 IP 层的服务构建 IP 头;

IPSec 作为一个“契子”插人在协议堆栈的网络层与数据链路层之间实施, 称为 “堆栈中的块(BITS)”实施方案。

(2) 在路由器中实施:

优点: 保障通过公用网络, 在两个子网之间传输数据的安全性; 可通过身份验证, 授权用户进人私有网络。

路由器实施方案有两种类型:

原始实施:IPSec 集成在路由器的软件中,和主机 OS 集成实施方案类似。

线缆中的块 (BITW): IPSec 在一个硬件设备中实现, 这个设备直接接人路由器的物理接口。该设备一般不运行任何路由算法, 只是附着在路由器设备上用来保障数据包的安全。

### 11.1.7 IPSec 的应用

IPSec 是 IPv6 必须支持的功能, 它与防火墙、安全网关结合可形成各种安全解决方案;与其他协议相结合将使安全性更高; 能使企业将其 Extranet 扩展到贸易伙伴进行电子商务,而不用担心安全协议的兼容性。IPSec 的典型应用是构建虚拟专用网 VPN。

VPN 通过保密隧道在非信任公共网络上产生安全私有连接。它能把远程用户、分支机构和商业伙伴连接组成一个自治网络, 能达到与专用网有同样的安全、可靠、可扩充、可管理的服务质量。IPSec 为 VPN 的互操作性、管理、通信提供了有力手段。

图 11-7 表示了某政府部门通过 IPSec VPN 建立的电子政务移动办公网络。



图 11-7 某政府电子政务移动办公网络

## 11.2 网络传输眼务的安全性

前面主要介绍了网络层安全协议 IPSec, 本节将介绍一些与传输层相关的网络安全协议,它们可以满足不同用户之间的安全需求,可以各自单独使用也可以相互配合联合使用。

### 11.2.1 SSL 的安全性

SSL(Secure Socket Layer) 是 Netscape 公司设计的主要用于 Web 的安全传输协议。它是一个介于 HTTP 协议与 TCP 协议之间的一个可选层, 如图 11-8 所示, 这种协议在 Web 上获得了广泛的应用。

| HTTP/SHTTP | FTP | SMTP |
| :---: | :---: | :---: |
| SSL/TLS |  |  |
| TCP |  |  |
| IP |  |  |

图 11-8 SSL 所处的位置

在 Internet 应用程序中,通常使用广义的进程间通信 (IPC) 机制来与不同层次的安全协议打交道。比较流行的两个 IPC 编程界面是 BSD Sockets 和传输层界面 (T LI), 在 UNIX 系统 V 命令里可以找到。

在 Internet 中提供安全服务的第一个想法便是强化它的 IPC 界面,如 BSD Sockets 等,具体做法包括双端实体的认证, 数据加密密钥的交换等。Netscape 公司遵循了这个思路,制定了建立在可靠的传输服务 (如 TCP/IP 所提供) 基础上的安全套接层协议 (SSL)。SSL 版本 3(SSL v3)于 1995 年 12 月制定。它主要包含以下两个协议:

SSL 记录协议:涉及应用程序提供的信息的分段、压缩、数据认证和加密。SSL v3 提供对数据认证使用的 MD5 和 SHA 以及数据加密使用的 R4 和 DES 等的支持, 用来对数据进行认证和加密的密钥可以通过 SSL 的握手协议来协商。

SSL 握手协议:用来交换版本号、加密算法、(相互)身份认证并交换密钥。SSL v3 提供对 Deffie-Hellman 密钥交换算法、基于 RSA 的密钥交换机制和另一种实现在 Fortezza chip 上的密钥交换机制的支持。

SSL 安全协议主要提供三方面的服务:

用户和服务器的合法性认证。认证用户和服务器的合法性, 使得它们能够确信数据将被发送到正确的客户机和服务器上。客户机和服务器都是有各自的识别号, 这些识别号由公开密钥进行编号, 为了验证用户是否合法, 安全套接层协议要求在握手交换数据时进行数字认证, 以此来确保用户的合法性。

加密数据以隐藏被传送的数据。安全套接层协议所采用的加密技术既有对称密钥技术, 也有公开密钥技术。在客户机与服务器进行数据交换之前, 交换 SSL 初始握手信息, 在 SSL 握手信息中采用了各种加密技术对其加密, 以保证其机密性和数据的完整性, 并且用数字证书进行鉴别。这样就可以防止非法用户进行破译。

保护数据的完整性。安全套接层协议采用 Hash 函数和机密共享的方法来提供信息的完整性服务, 建立客户机与服务器之间的安全通道, 使所有经过安全套接层协议处理的业务在传输过程中能全部完整准确无误地到达目的地。

### 11.2.2 TLS 的安全性

IETF 将 SSL 作了标准化, 即 RFC2246, 并将其称为 TLS (Transport Layer Security),从技术上讲, TLS 1.0 与 SSL 3.0 的差别非常微小。

TLS 的主要目标是在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成: TLS 记录协议 (TLS Record) 和 TLS 握手协议 (TLS Handshake)。较低的层为 TLS 记录协议,位于某个可靠的传输协议 (例如 TCP) 上面。TLS 记录协议提供了具有两个基本特性的连接安全性:
私有一一对称加密系统被用来加密数据。用于连接的对称加密术密钥是惟一产生的,并且基于由另一个协议 (如握手协议)协商的密钥。记录协议也可以不加密使用。

可靠一一信息传输包括使用密钥进行信息完整性检查。可靠的功能被用于估算。在没有记录协议的情况下也能操作, 但一般只能用于这样的模式情形, 即有另一个协议正在使用记录协议传输协商安全参数。

TLS 记录协议是一种分层协议。每一层中的信息可能包含长度、描述和内容等字段。记录协议支持信息传输、将数据分段到可处理块、压缩数据、应用 $\mathrm{MAC}$ 、加密以及传输结果等。对接收到的数据进行解密、校验、解压缩、重组等, 然后将它们传送到高层客户机。TLS 记录协议可以支持的高层协议有许多, 在 TLS 协议文本中定义的有四类: 握手协议, 警报协议、改变密文定义协议和应用数据协议, 此外还支持其他的协议扩展。T TS 实现将忽略不能识别的上层协议不做任何处理, 以提高互操作性和兼容性。但是由于 TLS 记录长度和类型信息没有被加密保护,因此在实现中必须小心地判断这些值。

握手协议提供了具有三个基本特性的连接安全性:

可以使用非对称的或公共密钥的密码术来认证对等方的身份。该认证是可选的,但至少需要一个对等方。

共享密钥的协商是安全的。对偷窃者来说协商密钥是难以获得的。此外经过认证的连接不能获得密钥,即使是进人连接中间的攻击者也不能。

协商是可靠的。没有经过通信成员的检测,任何攻击者都不能修改通信协商。

TLS 的一大优势在于 TLS 是独立的应用协议。高层协议可以分布在 TLS 协议上面。然而 TLS 标准把如何添加 TLS 协议安全性、如何启动 TLS 握手协议以及如何解释认证证明的决定权留给运行在 TLS 上的协议的设计者和实施者来判断。

前面已介绍网络层安全机制的主要优点是它的透明性,即安全服务的提供不要求应用层做任何改变。这对传输层来说是做不到的。原则上,任何 $\mathrm{TCP} / \mathrm{IP}$ 应用, 只要应用传输层安全协议, 比如说 SSL 或 PCT, 就必定要进行若干修改以增加相应的功能, 并使用(稍微)不同的 IPC 界面。于是,传输层安全机制的主要缺点就是要对传输层 IPC 界面和应用程序两端都进行修改。可是,比起 Internet 层和应用层的安全机制来,这里的修改还是相当小的。另一个缺点是, 基于 UDP 的通信很难在传输层建立起安全机制来。同网络层安全机制相比,传输层安全机制的主要优点是它提供基于进程对进程的(而不是主机对主机的)安全服务。这一成就如果再加上应用级的安全服务, 就可以再向前跨越一大步了。

## 实验题

实验 11.1

架构一个基于 Windows 2000 操作系统的网络, 在其中配置基于 IPSec 的 VPN, 理解 IPSec 在 VPN 中的应用。

## 习 题

11.1 IPSec 的两种工作方式有何不同?

11.2 IPSec 的实施方式有哪些?

## 实验题参考答案

实验 11.2

本实验主要介绍的是基于 IPSec 的 VPN 中网关到网关的模拟环境配置步骤。其中地址均为假设的。图示如下图 11-14, 所需环境为: 两台安装 Windows 2000 Server 的 PC 机，分别安装两块网卡,我们称其为 A 机和 B 机, A 机所在私有地址段为 192.168.5.0/ 255.255 .255 .0 , 互联网端网卡 IP 地址为 202.1.1.1/255.255.255.0, B 机所在私有地址段为 $192.168 .6 .0 / 255.255 .255 .0$, 互联网端网卡 IP 地址为 202.1.1.2/255.255.255.0, 用一交叉网线直连 $A 、 B$ 两机模拟互联网, 另外一台内网 PC 机地址 192.168.6.2/255.255. 255.0 , 称为 C 机。目的是通过 VPN 将两段内部网络互联。



图 11-14 配置 IPSec 的模拟网络环境图

IPSec 网关 A 机和 B 机需要配置的主要内容为: 创建 IPSec 策略; 定义 IPSec 第选器列表 (Filter List); 配置 IPSec 第选器操作 (Filter Action); 配置身份验证方法。具体步骤如下:

1. A 机上的配置步骤:

(1)创建 IPSec 策略:

1)在 A 机上运行 IPSec 策略管理控制台 (方法:“开始” $\rightarrow$ “程序” $\rightarrow$ “管理工具” $\rightarrow$ “本地安全策略”) 。右击“IP 安全策略, 在本地机器”, 选择“创建 IP 安全策略”, 出现 IP 安全策略向导。

2)单击“下一步”。

3)命名所建的安全策略, 比如“A 和 B 的安全通信”, 单击“下一步”。

4) 清除“激活默认响应规则”复选框, 单击“下一步”。

5)选中“编辑属性” 复选框, 单击“完成”, 至此已创建名为 “A 和 B 的安全通信” 的 IP 安全策略,以下步骤为设置其属性。

(2) 定义 IPSec 篮选器列表:

1)在“A 和 B 的安全通信”属性框中,清除“使用添加向导”复选框,单击“添加”按钮, 添
加 IPSec 第选器, 如图 11-15 所示。



图 11-15 安全策略属性

2)命名篮选器, 比如为 “A 到 B 的笁选器”, 清除“使用添加向导”复选框, 如图 11-16, 单击“添加”按钮, 出现第选器属性对话框。



图 11-16 IP 第选器列表

3)“源地址”选择“一个特定的子网”, “目标地址” 也选择“一个特定的子网”, 分别填上 IP 地址, 清除“镜像”复选框, 在“协议”标签中“选择协议类型”为“任意”, 如图 11-17 所示, 单击“确定”, 再单击“关闭”, 至此已添加好名为“A 到 B 的笁选器”的第选器。



图 11-17 “A 到 B 的篮选器”具体配置信息

(3) 定义 IPSec 筛选器操作:

1)在“新规则属性”对话框中,单击“IP 笁选器列表”标签, 选中新建的“A 到 B 的篮选器”, 再单击“篮选器操作” 标签, 单击“添加” 按钮, 在 “篮选器操作属性” 对话框中, 选择“常规”标签, 命名该操作, 比如 “A 和 B 篮选器操作”, 如图 11-18 所示, 选择“安全措施”标签,单击“添加”按钮。



图 11-18 新笁选器操作属性

2)选择“自定义”单选框,单击“设置”按钮。

3) 在此对话框中, 设置 A H 完整性算法和 ESP 完整性算法及加密算法, 比如 AH 选 M D5, ESP 选 SHA1 和 3DES, 单击“确定”, 再单击“确定”, 出现如图 11-19 所示对话框, 单击“确定”, 至此已添加好名为“A 到 B 的篮选器操作”的篮选器操作。



图 11-19 篮选器操作属性对话框

(4) 配置身份验证方法:

身份验证方法定义在篮选器适用的通讯中需如何验证标识。双方都必须至少有一个通用身份验证方法, 否则通讯将失败。Windows 2000 提供 Kerberos、公钥证书、指定预共享密钥三种身份验证方法,使用 Kerberos 需合理设置 $A 、 B$ 机之间的域关系,使用公钥证书需申请和安装相应证书, 甚至需建立 CA(Certification Authority) 中心, 为简化起见, 此处只介绍使用指定预共享密钥的身份验证方法配置步骤。

1)在“新规则属性”对话框中, 确保在“IP 笤选器列表”标签中选中“A 到 B 篮选器”, 在 “笕选器操作”标签中选中“A 到 B 笁选器操作”, 然后单击“身份验证方法”标签。

2) 单击“添加” 按钮, 选择 “此字串用来保护密钥交换 (预共享密钥) ”单选框, 输人 “123456789”, 单击“确定”。至此已配置好身份验证方法, 如图 11-20 所示。



图 11-20身份验证方法属性对话框

(5)设置隧道终点:

1)在“新规则属性”对话框中,单击“隧道设置”标签。

2)选择“隧道终点由此 IP 地址指定”, 并输人 B 机互联网端地址 202.1.1.2。如图 11-21所示。



图 11-21“设置隧道终点”界面

(6) 配置人站篮选器:

IPSec 需要在第选器列表中指定的计算机之间同时有人站和出站篮选器。人站第选器适用于传人的通讯, 并允许接收端的计算机响应安全通讯请求; 或者按照 IP 篮选器列表匹配通讯。出站篮选器适用于传出的通讯, 并触发一个在通讯发送之前进行的安全协商。例如,如果计算机 A 要与计算机 B 安全地交换数据:

计算机 A 上的活动 IPSec 策略必须有针对计算机 B 的任何出站包的第选器。 Source $=A$ 且 Destination $=B$ 。

计算机 A 上的活动 IPSec 策略必须有针对计算机 B 的任何人站包的第选器。 Source $=B$ 且 Destination $=A$ 。

每方都必须有反向的第选器:

计算机 B 上的活动 IPSec 策略必须有针对计算机 A 的任何人站包的第选器。 Source $=A$ 且 Destination $=B$ 。

计算机 B 上的活动 IPSec 策略必须有针对计算机 A 的任何出站包的第选器。 Source $=B$ 且 Destination $=A$ 。

因此, 至此还只是设置好了 A 机上的出站篮选器, 还需在 A 机按 2) 至 5) 的步骤设置 A 机上的人站䉅选器, 只需将源和目的 IP 子网地址互换, 且此时的隧道终点 IP 地址为 202.1.1.1即可。

2. B 机上的配置步骤:

完全按在 A 机的配置过程, 在 B 机上做同样配置, 只需注意源和目的 IP 子网地址及隧道终点 IP 地址不要设置混淆即可。

3.测试 IPSec 策略:

配置好 IPSec 策略后, 需测试其是否正常工作, 在测试前需将 A、B 两机配置成路由器,并启用 IP 路由功能, 以在两网卡间路由 IP 包 (启用方法在“管理工具”中的“路由和远程访问”工具中启用)。同时需在 A 机上添加到 B 机所在内网段的路由项, 在 B 机上添加到 A 机所在内网段的路由项。在做好这些准备工作后, IPSec 策略测试步骤如下:

(1)运行 IPSec 策略管理控制台, 在左边窗口选择“IP 安全策略, 在本地机器”, 在右边窗口出现创建的名为 “A 和 B 的安全通信”的 IPSec 策略,右击 “A 和 B 的安全通信”, 选择“指派”,则其“策略已指派”栏由“否”变为“是”。在 A、B 两机上均需做此操作。

(2) 在 C 机上打开命令窗口, 做 PING 操作 (即 ping -t 192.168.5.1)。该操作中源和目的 IP 地址匹配我们在 $A 、 B$ 两机上设置的第选器, 其将触发 B、A 之间的安全通信。

(3)在 B 机上打开 IP 安全监控工具(方法: “开始” $\rightarrow$ “运行” $\rightarrow$ “ipsecmon”即可)。此时在其窗口上可看到目前在用 A、B 机之间建立的 SA 详细信息及发送和接收的身份验证字节数和加密的字节数等。如图 11-22 所示。

本实验中设置的 IP 笁选器协议选择的是缺省的“任意”值, 其实还可以非常灵活地设置源和目的协议、端口号等,以设置更严格的过滤器规则。

Windows 2000 的 IPSec 服务为我们建立基于 IPSec 的 V PN 提供了非常方便的手段,利用它建立起来的安全通信对应用程序是完全透明的, 应用程序不需做任何修改就可以获得安全通信功能。同时, Windows 2000 中的 IPSec 功能在内部局域网中建立关键主机之间的安全加密通信也是非常方便有效的。它是通过采用 IPSec 的传输模式工作方式来实现



图 11-22 在 B 机上打开的 IP 安全监控工具窗口信息

的,不需改变或增加 IP 地址,可以非常方便地实现对关键主机之间的不同类型流量实施不同的安全策略。

## 习题参考答案

11.1 为了加固 DNS 服务, 目前最常用的做法是给提供 DNS 服务的硬件服务器足够高的配置, 在高配置、性能过剩的机器面前, 伪造信息和 DoS/DdoS 攻击对正常应用基本上没有影响。所以针对 DNS 服务器重载循环运行的特性, 硬件资源配备要充足, 这不但保证了服务器运行的完整性而且具有很好的安全性。

- 采用 Split DNS。
- 完善和加固服务器上的 host 文件。
- 采用多台 DNS 服务器。
- 使用 DNS 缓存服务器。

服务器的安全可以通过严格的管理和维护得到很大提高。穴余检测、过滤、防止欺骗以及基于过滤的转发可以将 UDP 请求从 TCP 中区分出来, 通过网络中位于服务器前的路由设备和防火墙的设置很好地保护应用服务器。可以使用不同的操作系统做主域名和辅域名。

## 11.2 通过百度, Google 等搜索 DNS 安全。

11.3 IPSec 有两种工作方式: 传输方式 (Transport Mode) 和隧道模式 (Tunnel Mode), AH 和 ESP 均可应用于这两种方式。传输方式通常应用于主机之间端对端通信，该方式要求主机支持 IPSec。隧道方式应用于网关模式中,即在主机的网关(防火墙、路由器) 上加载 IPSec, 这个网关就同时升级为安全网关(Security Gateway, SG)。

传输模式主要为上层协议提供保护, A H 或 ESP 包头插人在 IP 包头和运输层协议包头之间。传输模式下 ESP 并没有对 IP 包头加密处理, 源、目的 IP 地址内容是可见的,而 AH 认证的是整个 IP 头,完整性保护强于 ESP。

在隧道方式下, 整个 IP 包都封装在一个新的 IP 包中,并在新的 IP 包头和原来的 IP 包头之间插人 IPSec 头 $(\mathrm{AH} / \mathrm{ESP})$ 。在隧道模式下, 如果应用了 $\mathrm{ESP}$, 原始 IP 包头是加密的,
真正的源、目的 IP 地址是隐藏的, 新 IP 头中指定的源、目的 IP 地址一般是源、目的安全网关的地址。

11.4 IPSec 可在终端主机、网关/路由器或两者中同时进行实施和配置。

(1) 主机实施:

主机实施可分成两类:IPSec 与操作系统集成实施。IPSec 可当作网络层的一部分来实现。IPSec 层需要 IP 层的服务构建 IP 头; IPSec 作为一个“契子” 插人在协议堆栈的网络层与数据链路层之间实施, 称为“堆栈中的块 (BITS)”实施方案。

(2) 在路由器中实施:

路由器实施方案有两种类型: 原始实施: IPSec 集成在路由器的软件中, 和主机 OS 集成实施方案类似。线缆中的块 (BITW): IPSec 在一个硬件设备中实现, 这个设备直接接人路由器的物理接口。该设备一般不运行任何路由算法, 只是附着在路由器设备上用来保障数据包的安全。

## 第 <br> 章

## Internet 的基础设施安全



本章重点与难点

DNS 以及 PGP 应用安全。

教学要求

本章主要介绍 Internet 部分网络基础设施 DNS、PGP。通过本章内容的学习, 要求学生掌握如何在 Internet 中保障域名服务的安全, 如何使邮件变得更安全。本章的重点在于操作,特别要熟练掌握 PGP 软件的使用。

### 12.1 DNS 安全

针对动态域名服务 (DNS)的攻击比针对因特网其他组件的攻击要少一些。因此, 直到最近才出现一些针对保护 DNS 的协议,即 DNS 安全扩展 (DNSSEC), 保护域名到 IP 地址的映射不被伪造。

### 12.1.1 DNS 基本概念

下面来快速浏览一下 DNS 的概念: DNS 通过访问一系列的域名服务器将域名解析为 IP 地址。你的个人计算机上的 DNS 解析器配置为系统启动的时候运行, 直接查询你的组名或者你的 ISP 的域名服务器。如果你请求一个本地域名服务器但不知道的名字, 它就会转而查询其他的域名服务器来满足你的请求。

例如,如果你查询一个类似 $w w w . x y z . c o m$ 的名字,并且你的本地域名服务器没有有关 xyz.com 的信息, 它就会查询维护所有.com 信息的域名服务器来找到它。然后, 它会在 xyz.com 这个域内查询 www.xyz.com 的地址。如果攻击者能够在这个路径上的某个地方截获你的请求,那么它就可以返回一个虚假的信息。收到查询响应中的虚假地址的 DNS 客户端就会定位到一个伪装成合法网站的站点去。一个假的银行网站可以收集到类似用户名和密码等的信用卡信息。

因为这些查询都是使用 UDP 来完成的, 攻击者甚至都不需要去阻塞发送到合法目标的请求。攻击者只需要比合法服务器更快响应即可。发出请求的人就会接收到它的响应,
并会忽略随后的合法答案。想了解更多有关 DNS 的威胁类型的细节, 请查看 《RFC 3833 Threat Analysis of the Domain Name System (DNS)》。

攻击者不需要截取受攻击的站点的查询,而是使用“缓存中毒 (Cache Poisoning)”攻击。这里, 攻击者用合法的信息响应请求, 但是在响应中附加额外的域名进行地址映射。额外的信息并不立即执行, 而是会保留在请求者的缓存中。例如, 攻击者响应一个来自 ISP 域名服务器对于 xyz.com 返回的信息的请求, 并提供了一个正确的 xyz.com 的地址, 但是同时附加了一个虚假的域名, 作为 yourbank.com 的地址映射。所有请求了 yourbank.com 的地址的 ISP 用户都会收到这个错误的信息。

DNSSEC 通过数字签名和公钥加密保证了 DNS 信息的有效性。支持 DNSSEC 的域名服务器给他们维护的每个域名到地址的映射加上数字签名。查询信息的解析器和域名服务器都采用提供给域名服务器的公钥来验证签名和数据。

使用“信任链”的方法解决了以安全方式分发公钥所面临的挑战。这个技术阻止了攻击者截获密钥并应用他们自己的假公钥。这比在因特网上维护一个拥有数百万域的单独的注册表更容易实现。

根名字服务器通过因特网团体来进行维护, 提供顶级域名,例如.com 和. org 的名字到地址的映射。通常, 解析器也使用这些人所共知的根名字服务器的地址来进行配置。在 DNSSEC 中, 解析器还用能够对顶级域名的名字到地址映射进行数字签名的根名字服务器公钥进行配置。这个密钥, 依次被用于直接对顶级域名以下的各级域名进行名字到地址映射的签名。这个链可以根据需要延长。

性能一直都是加密的主题之一。域名服务器只在它们被存储的时候进行一次映射, 所以每次请求映射的时候就不会再有延迟。更进一步的讲, 没有必要解密映射的整个内容。提供域名的服务器提供了信息的哈希表, 并对哈希表加密; 解析器重新计算, 解密提供的哈希, 并对这两个哈希进行比较。如果它们一样, 来自有效资源的数据在路上就没有被更改过。想要了解更多有关 DNSSEC 的细节, 请看 http://www.dnssec.net。

DNSSEC 部署是从一些隔离的域开始的。根据额外获得的经验, 它会推广到整个网络。要将 DNSSEC 添加到你公司的域名服务器上, 你需要更新你的 DNS 软件以支持它。公共的域名 BIND 软件通过修改支持 DNSSEC。你需要创建一个私钥, 并将其维护在一个安全的地方。

将 DNSSEC 添加到你的网络中意味着额外的工作, 但是如果你的站点受到攻击者的青睐, 这也是值得的。

### 12.1.2 DNS 安全级别

## 1. 低级安全性

低级安全性是一种标准的 DNS 部署, 不配置任何安全预防措施。只在不关心 DNS 数据完整性的网络环境或不存在外部连接威胁的专用网络中才部署该级别 DNS 安全性。

- 企业的 DNS 结构完全暴露给 Internet。
- 标准 DNS 解决方案是由企业网络中的所有 DNS 服务器执行的。
- 所有 DNS 服务器都配置有指向 Internet 的根提示的根服务器。
- 所有 DNS 服务器都允许向任何服务器进行区域传输。
- 所有 DNS 服务器都配置为侦听其所有的 IP 地址。
- 在所有 DNS 服务器上禁用防止缓存污染。
- 允许对所有 DNS 区域进行动态更新。
- 用户数据报协议 (UDP) 和传输控制协议/Internet 协议 (TCP/IP) 在企业网络的源和目标地址的防火墙上处于打开状态。


## 2.中级安全性

中级安全性使用可用的 DNS 安全功能, 不在域控制器上运行 DNS 服务器, 也不在 Active Directory 中存储 DNS 区域。

- 企业的 DNS 结构有限暴露给 Internet。
- 所有 DNS 服务器在本地都无法解析名称时, 将其配置为使用转发器指向内部 DNS 服务器的特定列表。
- 所有 DNS 服务器都将区域传输限制为其区域中的名称服务器 (NS) 资源记录中列出的服务器。
- 配置 DNS 服务器为在指定的 IP 地址上侦听。
- 在所有 DNS 服务器上已启用防止缓存污染。
- 不允许对任何 DNS 区域进行动态更新。
- 内部 DNS 服务器通过防火墙与外部 DNS 服务器通信, 该防火墙具有所允许的源和目标地址的有限列表。
- 防火墙前方的外部 DNS 服务器都配置有指向 Internet 的根服务器的根提示。
- 所有 Internet 名称解析都使用代理服务器和网关执行。


## 3. 高级安全性

高级安全性使用与中级安全性具有相同的配置, DNS 服务器在域控制器上运行且 DNS 区域存储在 Active Directory 中时, 也使用可用的安全功能。此外, 高级安全性还完全取消了与 Internet 的 DNS 通信。这不是通常使用的配置, 但是, 每当不需要 Internet 连接时,则建议使用该配置。

- 企业的 DNS 结构不通过内部 DNS 服务器与 Internet 通信。
- 企业网络使用内部 DNS 根目录和名称空间, 其中对于 DNS 区域的所有权限都是内部的。
- 配置为使用转发器的 DNS 服务器只使用内部 DNS 服务器的 IP 地址。
- 所有 DNS 服务器都将区域传输限制为指定的 IP 地址。
- 配置 DNS 服务器为在指定的 IP 地址上侦听。
- 在所有 DNS 服务器上已启用防止缓存污染。
- 内部 DNS 服务器都配置有指向内部 DNS 服务器的根提示, 这些服务器主持企业内部名称空间的根目录区域。
- 所有 DNS 服务器都在域控制器上运行。DNS 服务器上配置有随机访问控制列表 (DACL), 只允许特定的个人在 DNS 服务器上执行管理任务。
- 所有 DNS 区域都存储在 Active Directory 中。
- DNS 资源记录上的 DACL 被配置为只允许特定个人创建、删除或修改 DNS 数据。
- 为 DNS 区域配置了安全的动态更新, 顶级和根目录区域除外, 它们根本不允许进行
动态更新。


### 12.1.3 DNS 安全面临的挑战

域名系统是一个分布式数据库, 由运行于网络上的域名服务器组成。每台域名服务器负责控制整个数据库中的一部分段,每一段中的数据通过客户端/服务器模式在整个网络上均可存取。作为一个分布式的数据库, DNS 服务发展如果没有相当强壮的机制, 那么 Internet 总有一天会走到崩溃的边缘。DNS 服务同时还和网络上的一些其他应用相联系, 比如基于域名的信息检索、规范化主机名管理、电子邮件服务器的定义等。

互联网络发展的初期, 由于应用范围小,使用人数有限, 大多是了解学习阶段, 网络环境相对简单和安全,DNS 也度过了它萌芽发展的几年。但是现在我们可以看到很多报告显示: 一些敏感机密的数据(如信用卡、银行数据等) 被篡改偷窃、网站发布大量垃圾信息甚至已影响到青少年的身心健康、通过网络欺计、犯罪等。在初期应用环境下产生的东西在今天都受到了不小的冲击。DNS 在处理数据时缺少真实性和完整性的检测,一些协议的访问控制机制又都基于主机名的管理更恶化了这种情形,现在来自域名的威胁不但已经存在而且已经作为更多网络攻击的基础。

我们可以肯定 DNS 安全方面的缺陷对 Internet 的影响是巨大的, 因为 DNS 服务需要对所有网络上的用户开放, 这就意味着网络安全的大门——防火墙不能对 DNS 端口做任何限制一一必须是开放的。最常使用的 DNS 协议是 BIND。而 BIND 的源代码广泛应用在起源于 BSD 的操作系统中, 是 Internet 流行的开放源代码的可执行的 DNS 服务。事实上, 如果源代码是公开可用的, 就意味着程序的漏洞也是可利用的。只要一个新的弱点被发现, 计算机网络蠕虫和一些怀有恶意的代码都会对这些弱点加以利用。这会导致大范围的不可想象的影响,例如:数据完整性的破坏、拒绝服务攻击、机密信息泄漏、个人隐私的侵害等。

DNS 的安全不要仅局限于服务器、网络访问控制以及软件层次, 我们还需要考虑物理上的安全、代码保护、逻辑存取控制等方面。对 DNS 最好采用严格并且灵敏的保护, 防火墙、反病毒软件可以为它创建必要的保护环境。如果需要的话, 人侵检测和授权认证服务也要考虑到, 也可采用 DNSSEC 功能加固 DNS 服务。更重要的是软件要及时升级, 管理员要了解软件最新的更新状况, 最新补丁发布情况。这样就形成了一个主机服务访问限制、专人授权管理、真实性和完整性检测的相对安全的环境。

### 12.1.4DNS 安全攻击与防范

域名系统在网络世界的作用至关重要,保证其安全自然排在首位。目前常见的攻击 DNS 的方式可以归结为三种类型: 首先是使 DNS 服务不可用,如 DdoS 攻击或得到超级用户的权限彻底使应用服务崩溃; 其次是破坏数据, 通过一台或多台主机重写数据库; 第三种是伪装成一台授权 DNS 服务器进行域名解析。

为了加固 DNS 服务, 目前最常用的做法是给提供 DNS 服务的硬件服务器足够高的配置, 在高配置、性能过剩的机器面前, 伪造信息和 DoS/DdoS 攻击对正常应用基本上没有影响。所以针对 DNS 服务器重载循环运行的特性, 硬件资源配备要充足, 这不但保证服务器运行的完整性而且具有很好的安全性。

前两种攻击类型发生在 TCP/IP 层, 对 DNS 应用服务器本身没很大影响, 它的目标是
通过 DNS 攻击邮件服务器或 Web 服务器, 如果 DNS 采用了足够的防御手段抵制这种攻击,那么也就保护了邮件服务器和 Web 服务器。

而防范第三种攻击 DNS 不但需要安全的操作系统, 也需要健全的支撑 DNS 运行的软件。在一个典型的 UNIX 环境下, 常用的解析软件是 BIND (Berkeley Internet Name Domain）。虽然 IETF 组织在过去的几年中就提出在已经存在的 DNS 协议中加人 DNS 安全扩展检测以加强它的应用。而且在最新发行的 BIND9 中已经支持了 DNSSEC 的所有特征, 但启用 DNSSEC 时由于涉及到 PKI 的复杂计算, 会占用大量的处理器资源, 给服务器造成很大的负担,所以 DNSSEC 没能大范围地推广起来。

除了上述常规的方法以外, 对如何保证 DNS 服务器的安全, 人们通过实践也总结了不少很实用的技巧：

- 采用 Split DNS。Split DNS 是指在两台不同的服务器上分离 DNS 的功能, 由内、外 DNS 服务器守护进程组成。内部 DNS 守护进程监听内部网络接口, 负责提供本地局域网内部域名的查询,若该域名不属于内部,则提交给外部 DNS 守护进程。外部 DNS 守护进程监听外部网络接口, 负责提供外部用户的查询, 同时处理来自内部守护进程提交的请求。对内部主机开放需要利用 allow-query 子语句限制查询。BIND 的 allow-query 子语句允许用户根据 IP 地址来创建名字服务器的访问列表。且采取 allow-transfer 控制来加强安全, 只有授权的辅名字服务器才能从主名字服务器上获得区数据信息。
- 完善和加固服务器上的 host 文件。如果同时拥有多台服务器, 而且 IP 地址不用高频率地更换, 可以将所有的 IP 地址和主机名的映射记录写人每台服务器的 host 文件。这样即使 DNS 运行有问题, 在整个内网内,所有的服务器都可以正常运行。
- 采用多台 DNS 服务器。很多大公司都采用这种方式来应付意外情况。多台服务器同时运行, 即使遭到攻击, 同时被 “黑掉”的可能性很小, 这样尽可能地保证客户端和服务器端不受影响。
- 使用 DNS 缓存服务器。如果不能设置多台服务器同时运行, 可以使用缓存服务器。客户端使用 DNS 解析服务时, 先从网络上设置的 DNS 缓存查询记录, 如果 DNS 服务器遭遇攻击, 用户可以从缓存中读取旧数据。缓存服务器要设置更新周期, 每小时或每几天更新一次。

服务器的安全可以通过严格的管理和维护得到很大提高。兄余检测、过滤、防止欺骗以及基于过滤的转发可以将 UDP 请求从 TCP 中区分出来, 通过网络中位于服务器前的路由设备和防火墙设置能很好地保护应用服务器。可以使用不同的操作系统做主域名和辅域名,例如主域名可以运行在基于 Linux 的服务器上, 而辅域名运行于基于 Windows 的服务器上, 同时不要将 DNS 信息对不需要此服务的人开放, 只允许在主辅域区间进行域传输交换,在域管理上采用授权机制等。

## 12.2 $\mathrm{PGP}$ 的使用

要了解 PGP 的基本情况, 读者可以参阅 3.3 节的内容, 这里主要介绍 PGP 软件的安装及使用。

## 1. 安装 PGP

目前 PGP 的最新版本为 9.0 , 但是由于版本变动不大,且国内只能下载到 PGP 8.1 版,因此本章以 PGP 8.1 作为实例来讲解。讲解所采用的系统为 Windows Server 2000 SP4。使用 PGP 8.1 可以实现邮件加/解密、文件加/解密、数字签名等功能。

首先到 PGP 中文网站下载 PGP 8.1 的安装文件。运行安装程序后, 经过短暂的自解压准备安装的过程后,进人安装界面, 显示欢迎信息, 点 “NEXT”按钮, 阅读许可协议, 点 “YES”按钮,进入提示安装 PGP 所需要的系统以及软件配置情况的界面, 点 “NEXT”按钮,出现创建用户类型的界面,如图 12-1 所示。还可以下载 PGP 8.1 的汉化软件。



图 12-1 选择用户类型

因为是首次安装,选择“新用户”, 将创建并设置一个新的用户信息, 点 “NEXT”按钮, 程序将提示选择安装目录, 建议将 PGP 安装在安装程序默认的目录, 接下来根据需要选择要安装组件,一般默认即可,第一项“PGPdisk Volume Security”是磁盘加密组件,第三项“PGPmail for Microsoft Outlook”是微软的 Outlook 邮件加密组件, 第四项 “PGPmail for Microsoft Outlook Express”是 Outlook Express(OE) 邮件加密组件, 如图 12-2 所示。



图 12-2

安装完毕后,提示重新启动计算机,这样 PGP 软件就安装成功了。

## 2.生成密钥对

计算机重新启动之后, 系统时会自动启动 PGPtray .exe。如图 12-3 所示。

启动 PGPtray 后, 会出现一个 PGP Key Generation Wizard (PGP 密钥生成向导), 点“下一步”按锄,进入 Name and Email Assignment(用户名和电子邮件分配) PGPtray 界面,在“全名 (F)”处输人你想要创建的用户名,“Email 地址 (E)”处输人用户所对应的电子邮件地址, 如图 12-4 所示。

分配姓名和电子信箱

毎一个密锄对都有一个与其关联的姓名、姓名和电子信箱地址让你的通信人知道地们正茬使用的公钥属于你。

全名(E): PGP 被关联的电子信箱地址和你的密钥对, 你将会使PGP协助你的通信人在与你通信时选择歨确的公钥。

Emailt地址(E): pgptest@163.com
点 “下一步”按钮出现 Passphrase Assignment 界面, 提示用户输人口令短语以保护私钥。如图 12-5 所示。



图 12-5

进人 Key Generation Progress(密钥生成进程), 等待主密钥 (Key) 和次密钥 (Subkey)生成完毕。点击“下一步”按钮, 进人 Completing the PGP Key Generation Wizard(完成该 PGP 密钥生成向导)再点 “完成”按钮,一个新的密钥对就创建并设置好了。如图 12-6 所示。



图 12-6

点右键密钥属性可以查看密钥的一些基本信息, 如: Validity (有效性, PGP 系统检查是否符合要求, 如符合, 就显示为绿色)、Trust (信任度)、Size(大小)、Description(描述)、Key ID(密钥 ID)、Creation(创建时间)、Expiration(到期时间)等。如图 12-7 所示。



图 12-7

当密钥对生成结束后, PGP 会自动建立一个文件夹存储公钥环和私钥环, 如图 12-8 是公钥环文件 pubring.pkr 和私钥环文件 secring.skr,以及它们的备份文件。



图 12-8

3. 加密邮件

在使用 PGP 加密邮件之前, 首先要把自己的公钥分发给其他人, 这样, 在他们给你发送加密邮件的时候使用你的公钥进行加密, 然后你再用你的私钥进行解密。

打开 PGPkeys, 在创建的密钥对上点右键, 选择“发送到” $\rightarrow$ “邮件接收人”寄给对方 PGP 公钥。
如果系统默认是采用 Outlook Express 来收发邮件的,将会开启 Outlook Express 并附加了你的公钥,如图 12-9 所示。



图 12-9

同时在 Outlook Express 中,如果安装了 PGPmail for Outlook Express 的插件,我们可以看到 PGPkeys 加载到了 $\mathrm{OE}$ 的工具栏里,如图 12-10 所示。



图 12-10

创建一封新邮件时, 可以看到工具条上多了 PGP 加密信息和 PGP 签名信息的按锄, 如图 12-11 所示。



图 12-11

要发送加密邮件时点击“加密信息 (PGP), 就会弹出选择公钥的对话框,选择你的收件人的公钥即可发送加密邮件给对方。对方收到加密的邮件后, 可按照提示信息进行解密操作。

## 4. 加密文件

很多时候我们会以附件形式寄出邮件, 这个时候, 打开 PGPmail, 在 PGPmail 窗口中,按下“加密”按钮,如图 12-12 所示。



图 12-12

然后选择需要加密的文件, 确定后在弹出的“PGPmail一密码选择”对话框中,选择你所需要使用的公钥进行加密。加密时有以下选项: “文本输出”、“输人文本”、“粉碎原件”、“安全查看器”、“常规加密”和“自解密文档”。

文本输出:解密后以文本形式输出。

输人文本: 选择此项, 解密时将以另存为文本输人方式进行解密。

粉碎原件: 加密后粉碎掉原来的文件,不可恢复。

安全查看器: 使用了 TEMPEST 防攻击字体进行模糊化, 为了防止监视设备监视你的显示器。

常规加密: 输人密码后进行常规加密。

自解密文档: 继承于常规加密,此方式也经常使用到,通常加密目录下的所有文件。

例如将“要加密的文件.txt”通过 PGP 用对方的公钥常规加密, 将生成“要加密的文件 .txt.asc”, 此时即可将.asc 为后缀的文件作为附件发送出去。对方收到后要用相应的私钥解密, 解密时选择 PGPmail 解密/校验功能, 需要输人密码。



图 12-13

## 5. 其他功能的使用

(1) 文件签名/签名验证

启动 PGPmail,选择相应的功能按钮即可, 操作过程与文件加密过程类似。

(2) 当前窗口内容加解密、签名认证
在 PGPTray 选择当前窗口, 出现签名、加密、解密、校验按钮, 点击完成相应的功能。

(3) 剪贴板内容加解密、签名认证

在 PGPTray 选择剪贴板, 出现签名、加密、解密、校验按钮, 点击完成相应的功能。

如果 PGP 安装了许可证书, 还可以起用 PGPdisk 的功能, 可以对磁盘进行加密和解密的操作。



SHTTP 是一个面向信息的安全协议, 它采用了 HTTP 的交互模式和实现特征, 因此可以和 HTTP 共存, 并且很容易被集成到 HTTP 应用程序中。SHTTP 为 HTTP 服务器和客户提供了可选择的安全机制以适应于各种 WWW 的应用环境, 而且 SHTTP 协议平等地对待服务器和客户, 使它们具有相同的能力。当 HTTP 客户和 SHTTP 服务器通信时,虽然不能够提供 SHTTP 的安全特征, 但是也应该能够交互。它支持使用原来的 HTTP 鉴别机制建立端到端的安全交互, 允许客户首先尝试这种方式, 客户可以使用信息头来建立安全会话,这种方式可以保护 form 中的敏感信息不在网上以明文传送。

SHTTP 信息由三部分构成: 明文信息; 接受着的加密选项和其密钥构成的信息 (可明文定义或缺省配置) ; 发送者的加密选项和密钥信息 (通常发送者已熟记)。发送者汇总双方的加密系统信息,根据明文信息创建 SHTTP 信息。

SHTTP 提供了安全的加密算法、模式和参数选择, 允许客户和服务器协商传输模式、加密算法和证书。它不需要客户端的公开密钥证书 (或公开密钥), 也支持对称密钥工作模式, 这意味着不公开密钥也可以建立安全传输, 虽然 SHTTP 不需要公开密钥证书的基础设施,但是在这个基础上的实施时会更好。

目前还没有 Web 安全性的公认标准。这样的标准只能由 WWW Consortium, IETF 或其他有关的标准化组织来制定。而正式的标准化过程是漫长的, 可能要拖上好几年, 直到所有的标准化组织都充分认识到 Web 安全的重要性。SHTTP 和 SSL 是从不同角度提供 Web 的安全性的。SHTTP 对单个文件作 “私人/签字”之区分, 而 SSL 则把参与通信的相应进程之间的数据通道按“私用” 和 “已认证”进行监管。Terisa 公司的 Secure Web 工具软件包可以用来为任何 Web 应用提供安全功能。该工具软件包提供有 RSA 数据安全公司的加密算法库,并提供对 SSL 和 SHTTP 的全面支持。

## 12.4 $\mathrm{SSH}$ 的兵全姓

传统的网络服务程序, 如 FTP、Pop 和 Telnet 在传输机制和实现原理上是没有考虑安全机制的, 其本质上都是不安全的; 因为它们在网络上用明文传送数据、用户账号和用户口令, 别有用心的人通过窃听等网络攻击手段非常容易地就可以截获这些数据、用户账号和用户口令。而且,这些网络服务程序的简单安全验证方式也有其弱点, 那就是很容易受到“中间人”(man-in-the-middle)这种攻击方式的攻击。所谓“中间人”的攻击方式, 就是“中间人”冒充真正的服务器接收你传给服务器的数据, 然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后, 就会出现很严重的问题。

SSH 是英文 Secure Shell 的简写形式。通过使用 SSH,可以把所有传输的数据进行加密,这样“中间人”这种攻击方式就不可能实现了,而且也能够防止 DNS 欺骗和 IP 欺骗。使用 $\mathrm{SSH}$, 还有一个额外的好处就是传输的数据是经过压缩的, 所以可以加快传输的速度。SSH 有很多功能, 它既可以代替 Telnet, 又可以为 FTP、Pop、甚至为 PPP 提供一个安全的“通道”。

最初的 SSH 是由芬兰的一家公司开发的。但是因为受版权和加密算法的限制, 现在很多人都转而使用 OpenSSH。OpenSSH 是 SSH 的替代软件包, 而且是免费的, 可以预计将来会有越来越多的人使用它而不是 $\mathrm{SSH}$ 。SSH 协议是建立在应用层和传输层基础上的安全协议,它主要由以下三部分组成,共同实现 SSH 的安全保密机制:

传输层协议: 提供诸如认证、信任和完整性检验等安全措施, 此外它还可以任意地提供数据压缩功能。通常情况下, 这些传输层协议都建立在面向连接的 TCP 数据流之上。

用户认证协议层: 用来实现服务器跟客户端用户之间的身份认证, 它运行在传输层协议之上。

连接协议层: 分配多个加密通道至一些逻辑通道上, 它运行在用户认证层协议之上。

当安全的传输层连接建立之后, 客户端将发送一个服务请求。当用户认证层连接建立之后将发送第二个服务请求。这就允许新定义的协议可以和以前的协议共存。连接协议提供可用作多种目的通道, 为设置安全交互 Shell 会话和传输任意的 TCP/IP 端口和 X11 连接提供标准方法。

从客户端来看, $\mathrm{SSH}$ 提供两种级别的安全验证:

第一种级别 (基于口令的安全验证), 只要你知道自己的账号和口令, 就可以登录到远程主机, 并且所有传输的数据都会被加密。但是, 这种验证方式不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器, 也就是受到 “中间人”这种攻击方式的攻击。

第二种级别 (基于密匙的安全验证), 需要依靠密匙, 也就是你必须为自己创建一对密匙, 并把公有密匙放在需要访问的服务器上。如果你要连接到 SSH 服务器上, 客户端软件就会向服务器发出请求, 请求用你的密匙进行安全验证。服务器收到请求之后, 先在该服务器的用户根目录下寻找你的公有密匙, 然后把它和你发送过来的公有密匙进行比较。如果两个密匙一致,服务器就用公有密匙加密“质询” (Challenge) 并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。

与第一种级别相比, 第二种级别不需要在网络上传送用户口令。另外, 第二种级别加密所有传送的数据, 因而 “中间人” 这种攻击方式也是不可能的 (因为他没有你的私人密匙)。但是整个登录的过程可能慢一些。

最后, SSH 在运行方式上也很有特色。不像其他的 TCP/IP 应用, SSH 被设计为工作于自己的基础之上,而不是利用包装 (Wrappers)或通过 Internet 守护进程 inetd。但是许多人想通过 TCP 包装来运行 $\mathrm{SSH}$ 守护进程。虽然你可以通过 $\operatorname{tcpd}$ (从 inetd 上运行启动)来运行 SSH 进程, 但这完全没有必要。

## 实验题

## 实验 12.1 DNS 服务器的配置

一、实验目的

练习配置 Windows 2000 DNS 服务器。

二、实验环境

Windows 2000 Server 服务器软件。

三、实验内容

练习建立 DNS 域及主机,并测试域名的正确性。

四、实验用时

20 分钟。

## 实验 12.2 使用 PGP 加密电子邮件

一、实验目的

掌握 PGP 软件的使用方法, 使用 PGP 加密电子邮件, 加深对加密技术应用的理解。二、实验环境

1. Windows 2000 系统, Internet 网络。

2.PGP 8.1 安装软件 (可以安装汉化补丁)。

3.0 utlook Express 邮件系统。

三、实验内容

1 .安装 PGP 软件。

2.为自己的邮箱生成密钥对。

要求用户 ID 中必须包含自己的学号。

3. 加密文件: 任意选择一个文件, 用常规加密方式对它进行加密和解密。观察各选项的作用。
4. 交换并验证公钥: 通过电子邮件 (或其他方式) 和其他同学交换公钥, 并验证公钥的有效性。然后, 可以相互发送加密电子邮件。

四、实验用时

45 分钟。

## 实验 12.3 使用 PGP 其他功能

一、实验目的

掌握 PGP 软件的其他功能, 使用 PGP 对文件进行签名、验证, 加深对加密技术应用的理解。

二、实验环境

1. Windows 2000 系统, Internet 网络。

2.PGP 8.1 安装软件。

三、实验内容

1.安装 PGP 软件。

2.为自己的邮箱生成密钥对。

要求用户 ID 中必须包含自己的学号。

3. 数字签名。任意选择一个文件, 对它进行签名, 然后验证。对文件略作修改后, 检查是否仍能通过验证。

4 . 对剪切版的内容进行加密和解密。

5 . 对当前窗口内容进行加密和解密。

6. 了解 PGPdisk 的创建和编辑。

四、实验用时

45 分钟。

## 习 题

12.1 简述 DNS 的安全级别。

12.2 DNS 攻击有哪几种形式?

12.3 了解 Windows 2000 Server 平台下的 SSH 服务器的安装。

12.4 结合讲课内容上网搜索 DNS 系统安全问题及解决手段。

## 实验参考答案

## 实验 12.1

Windows 2000 DNS 的设置

1.打开 DNS 控制台:选“开始菜单” $\rightarrow$ “程序” $\rightarrow$ “管理工具” $\rightarrow$ “DNS”。

2.建立域名“admin.abc.com”映射 IP 地址“192.168.0.50”的主机记录。

(1)建立“com”区域: 选“DNS $\rightarrow$ WY (你的服务器名) $\rightarrow$ 正向搜索区域 $\rightarrow$ 右键 $\rightarrow$ 新建区域”,然后根据提示选“标准主要区域”、在“名称”处输人“com”。如图 12-14 所示。



图 12-14 新建区域

(2)建立“abc”域:选“com” $\rightarrow$ “右键” $\rightarrow$ “新建域”, 在“键入新域名”处输人“abc”。

(3)建立“admin”主机。选“abc $\rightarrow$ 右键 $\rightarrow$ 新建主机”, “名称”处为 “admin”, “IP 地址”处输人“192.168.0.50”, 再按“添加主机”。如图 12-15 所示。



图 12-15 新建主机
3.建立域名“w w w.abc.com”,映射 IP 地址“192.168.0.48”的主机记录。

(1)由于域名“ww w.abc.com”和域名“admin.abc.com”均位于同一个“区域”和“域”中,均在上步已建立好, 因此应直接使用, 只需再在“域”中添加相应“主机名”即可。

(2)建立“ww w”主机: 选“abc $\rightarrow$ 右键 $\rightarrow$ 新建主机”, 在“名称”处输人 “w w w”, “IP 地址”处输人“192.168.0.48”,最后再“添加主机”即可。

4.建立域名“ftp.abc.com”,映射 IP 地址“192.168.0.49”的主机记录。方法同上。

5.建立域名“abc.com”,映射 IP 地址“192.168.0.48”的主机记录方法也和上述相同，只是必须保持 “名称”一项为空！建立好后它的 “名称”处将显示 “与父文件夹相同”。建立好的 DNS 控制台如图 12-16 所示。



图 12-16 DNS 控制台

6.建立更多的主机记录或其他各种记录方法类似。更多的建立后如图 12-17 所示。



图 12-17 多条主机记录

7.建立时也可以采用将“abc.com”整个作为“区域”, 然后在它下面直接建立“主机”的作法。不过对于同类记录较多时, 这种方法显得较为不便。

8. 为了测试所进行的设置是否成功, 通常采用 “ping” 命令来完成。格式如 “ping www.abc.com”。成功的测试如图 12-18 所示。



图 12-18 DNS 测试结果

实验 12.2

1.安装 PGP 软件。参见 $12.2 \mathrm{PGP}$ 软件的使用部分内容。

2.为自己的邮箱生成密钥对。

参见 12.2 生成密钥对部分内容, 注意用户 ID 中必须包含自己的学号。

3. 加密文件: 任意选择一个文件, 用混合加密方式对它进行加密和解密。

打开 PGPmail,在 PGPmail 窗口中,按下“加密”,如图 12-19 所示。



图 12-19 DNS 测试结果

然后选择需要加密的文件, 确定后在弹出的“PGPmail一密码选择对话框” 中, 选择你所需要使用的公钥进行加密。

加密时有以下选项, “文本输出”、“输人文本”、“粉碎原件”、“安全查看器”、“常规加密”、 “自解密文档”。

文本输出: 解密后以文本形式输出。

输人文本: 选择此项, 解密时将以另存为文本输人方式进行加密。

粉碎原件: 加密后粉碎掉原来的文件,不可恢复。

安全查看器: 使用了 TEMPEST 防攻击字体进行模糊化, 为了防止监视设备监视你的显示器。

常规加密: 输人密码后进行常规加密。

自解密文档: 继承于 “常规加密”, 此方式也经常使用到, 通常加密目录下的所有文件。

4. 交换并验证公钥: 通过电子邮件 (或其他方式) 和其他同学交换公钥, 并验证公钥的有效性。然后, 可以相互发送加密电子邮件。

将公钥以附件的形式发送给对方, 选中密钥, 点击右键, 选“发送到” —“邮件接收人”,填人对方邮箱地址。

接收到他人的公钥后,导人,就可以用来选择加密邮件或文件了。

发送加密电子邮件可在 OutLook express 中直接发送加密邮件, 也可以将加密的文件以附件的形式发送给对方。

实验 12.3

1.数字签名: 任意选择一个文件, 对它进行签名, 然后验证。

启动 PGPmail,选择相应的功能按钮即可, 操作过程与文件加密过程类似。

对文件略做修改后, 不能通过验证, 因为文件被修改, 则生成的消息摘要若不同, 验证签
名时, 比较两个消息摘要不同,则验证不通过。

2.对剪切板的内容进行加密和解密。

在 PGPTray 选择“剪切板”, 出现“签名”、“加密”、“解密”、“校验按钮”, 点击完成相应的功能。

3 . 对当前窗口内容进行加密和解密。

在 PGPTray 选择“当前窗口”, 出现“签名”、“加密”、“解密”、“校验按钿”, 点击完成相应的功能。

4.了解 PGPdisk 的创建和编辑。

注意只有进行了注册的 PGP 软件才可以使用 PGPdisk 的功能, 可到 PGP 中文站下载 PGP 新手指南,内含许可证号等相关信息。

## 习题参考答案

## 12.1 见 12.2 参考教材。

12.3 SSH 服务器的安装步骤:

下面以 Windows 2000 Server 为例介绍 SSH 服务器的安装, 可在 SSH 服务器端使用 “F-Secure SSH Server”软件, 它的安装非常简单, 和一般软件安装没什么区别。安装完成后,需要启动“SSH Server”服务,这一过程比较复杂, 这里介绍三种启动“SSH Server”的方法。

方法一:使用批处理文件

在服务器端安装目录下有两个批处理文件“start-ssh. bat”和“stop-ssh. bat”。运行 “start-ssh.bat”文件就可以启动 SSH 服务,要停止该服务只要执行“stop-ssh.bat”文件即可。

方法二: 使用 SSH 服务配置程序

在安装目录下, 运行“fsshconf.exe”程序, 它虽是 SSH 服务器的配置程序, 但也可以用来启动和停止 SSH 服务。在弹出的“F-Secure SSH Server Configuration”窗口中, 点击左面列表框中的“Server Settings”后, 在右边的“Service status”栏中会显示服务器状态按钮,如果服务器是停止状态, 则按钮显示为 “Start service”, 点击该按钮就可启动 SSH 服务, 再次点击可停止 SSH 服务。

方法三:使用 NET 命令

在服务器端的“命令提示符”窗口中, 输人“net start "F-secure SSH Server””命令, 就可以启动 SSH 服务, 要停止该服务, 输人“net stop "F-Secure SSH Server"” 命令即可。其中 “F-Secure SSH Server”为 SSH 服务器名, “net start” 和“ net stop” 为 Windows 系统启动和停止系统服务所使用的命令。

提示: 启动了 SSH 服务后, 一定要关闭 TELNET 服务, 这样服务器就处在安全环境之中了,不用再怕数据被窃取。

具体可以查阅 www.ccidnet.com 等相关技术网站。

## 第

## 网络操作系统安全



教学要求

本章介绍了操作系统安全的基本概念、访问控制的概念、类型与措施、 Windows 系列操作系统、UNIX 和 Linux 系统的安全漏洞与安全措施。通过本章的学习, 了解 UNIX 和 Linux 操作系统的安全漏洞和安全措施, 掌握 Windows 系列操作系统的安全措施、安全服务和安全配置。





计算机网络是由多个相互独立的计算机系统通过通信媒体连接起来的。各计算机都具有一个完整独立的操作系统, 网络操作系统 (NOS) 是建立在这些独立的操作系统基础上用以扩充网络功能的系统(系统平台)。

网络操作系统是为使网络用户能够方便而有效地共享网络资源而提供各种服务的软件及相关规程, 它是整个网络的核心, 通过对网络资源的管理, 使网上用户能方便、快捷、有效地共享网络资源。操作系统的主要功能包括: 进程控制和调度、信息处理、存储器管理、文件管理、输人/输出管理、资源管理等。NOS 是一种运行在硬件基础上的网络操作和管理软件,是网络软件系统的基础,它建立一种集成的网络系统环境,为用户方便而有效地使用和管理网络资源提供网络接口和网络服务。NOS 除了具有一般操作系统所具有的处理机管理、存储器管理、设备管理和文件管理功能外, 还提供高效而可靠的网络通信环境和多种网络服务功能。如文件服务、打印服务、记账服务、数据库服务以及支持 Internet 和 Intranet 服务。

目前, 常用的网络操作系统有 Windows 2000 Server、Windows NT Server, NetWare、 UNIX 和 Linux。

Windows 2000 是在 Windows NT 基础上发展起来的,在安全性、可操作性等方面都做了较大的改进, 又增加了活动目录、分布式文件系统、智能镜像技术、管理咨询和强大的网络
通信等新功能, 为广大用户所接受。Windows 2003 操作系统也已逐渐进人应用, 已有超过且取代 Windows 2000 之势。Windows XP 作为一个崭新的操作系统, 它继承了 Windows N T 的稳定性和 Windows 2000 的安全性, 已经得到广泛的应用。

网络操作系统在网络应用中发挥着十分重要的作用。因此,网络操作系统本身的安全,就成为网络安全保护中的重要内容。

## 13. 130 :

操作系统主要的安全功能包括: 存储器保护 (限定存储区和地址重定位, 保护存储信息)、文件保护(保护用户和系统文件,防止非授权用户访问)、访问控制、身份认证(识别请求访问的用户权限和身份)等。

网络操作系统主要有以下两大类安全漏洞:

- 输人/输出 (I/O) 非法访问。在一些操作系统中,一旦 $\mathrm{I} / \mathrm{O}$ 操作被检查通过后, 该操作系统就继续执行操作而不再进行检查, 这样就可能造成后续操作的非法访问。某些操作系统使用公共的系统缓冲区,任何用户都可以搜索该缓冲区。如果该缓冲区没有严格的安全措施,那么其中的机密信息 (用户的认证数据、身份证号码、密码等) 就有可能被泄漏。
- 操作系统陷门。某些操作系统为了维护方便、使系统兼容性和开放性更好, 在设计时预留了一些端口或保留了某些特殊的管理程序功能。但这些端口和功能在安全性方面未受到严格的监视和控制,为黑客留下了人侵系统的“后门”。


### 13.2.1 操作系统安全

操作系统安全保护的研究, 通常包括如下内容: 第一, 操作系统本身提供的安全功能和安全服务。现代操作系统本身往往要提供一定的访问控制、认证和授权等方面的安全服务。如何对操作系统本身的安全性能进行研究和开发, 使之符合特定的环境和需求, 是操作系统安全保护的一个方面; 第二, 针对各种常用的操作系统, 进行相关配置, 使之能正确对付和防御各种人侵;第三,保证网络操作系统本身所提供的网络服务能得到安全配置。

网络操作系统的安全是整个网络系统安全的基础。操作系统安全机制主要包括访问控制和隔离控制。隔离控制主要有物理(设备或部件)隔离、时间隔离、逻辑隔离和加密隔离等实现方法; 而访问控制是安全机制的关键，也是操作系统安全中最有效、最直接的安全措施。

访问控制系统一般包括:

- 主体 (Subject)。主体是指发出访问操作、存取请求的主动方, 它包括用户、用户组、主机、终端或应用进程等。主体可以访问客体。
- 客体(Object)。客体是指被调用的程序或要存取的数据访问,它包括文件、程序、内存、目录、队列、进程间报文、 $\mathrm{I} / \mathrm{O}$ 设备和物理介质等。
- 安全访问政策。安全访问政策是一套规则,可用于确定一个主体是否对客体拥有访问能力。

操作系统内的活动都可以看作是主体对计算机系统内部所有客体的一系列操作。操作系统中任何含有数据的东西都是客体, 可能是一个字节、字段或记录程序等。能访问或使用
客体活动的实体是主体,主体一般是用户或者代表用户进行操作的进程。

在计算机系统中,对于给定的主体和客体,必须有一套严格的规则来确定一个主体是否被授权获得对客体的访问。

一般来说, 如果一个计算机系统是安全的, 即指该系统能通过特定的安全功能控制主体对客体信息的访问。也就是说只有经过授权的主体才能读、写、创建或删除客体信息。

### 13.2.2 访问控制的涵义

为了系统信息的保密性和完整性,系统需要实施访问控制。访问控制也叫授权,它是对用户访问网络系统资源进行的控制过程。只有被授予一定权限的用户,才有资格去访问有关的资源。访问控制具体包括两方面涵义,一是指对用户进人系统的控制, 最简单最常用的方法是用户账户和口令限制, 其次还有一些身份验证措施; 二是用户进人系统后对其所能访问的资源进行限制, 最常用的方法是访问权限和资源属性限制。

访问控制所考虑的是对主体访问客体的控制。主体一般是以用户为单位实施访问控制 (划分用户组只是对相同访问权限用户的一种管理方法), 此外, 网络用户也有以 IP 地址为单位实施访问控制的。客体的访问控制范围可以是整个应用系统,包括网络系统、服务器系统、操作系统、数据库管理系统、文件、数据库、数据库中的某个表甚至是某个记录或字段等。一般来说,对整个应用系统的访问,宏观上通常是采用身份鉴别的方法进行控制,而微观控制通常是指在操作系统、数据库管理系统所提供的用户对文件或数据库表、记录及字段的访问所进行的控制。

### 13.2.3 访问控制的类型

访问控制可分为自主访问控制和强制访问控制两大类。

所谓自主访问控制, 是指由系统提供用户有权对自身所创建的访问对象 (文件、数据表等)进行访问,并可将这些对象的访问权授予其他用户或从被授予权限的用户处收回其访问权限。访问对象的创建者还有权进行 “权限转让”, 即将 “授予其他用户访问权限” 的权限转让给别的用户。需要指出的是, 在一些系统中, 往往是由系统管理员充当访问对象的创建者,并进行访问授权，而在其后通过“授权转让”将权限转让给指定用户。

自主访问控制允许用户自行定义其所创建的数据, 它以一个访问矩阵来表示包括读、写、执行、附加以及控制等访问模式。

所谓强制访问控制, 是指由系统 (通过专门设置的系统安全员)对用户所创建的对象进行统一的强制性控制, 按照规定的规则决定哪些用户可以对哪些对象进行何种操作系统类型的访问,即使是创建者用户,在创建一个对象后,也可能无权访问该对象。

强制访问控制策略以等级和范畴作为其主、客体的敏感标记。这样的等级和范畴, 必须由专门设置的系统安全员, 通过由系统提供的专门界面来进行设置和维护, 每感标记的改变意味着访问权限的改变。因此可以说,所有用户的访问权限完全是由安全员根据需要确定的。强制访问控制还有其他安全策略,如 “角色授权管理”。该策略将系统中的访问操作按角色进行分组管理, 一种角色执行一种操作, 由系统安全员进行统一授权。当授予某一用户某个角色时,该用户就有执行该角色所对应的一组操作的权限。当安全员撤消授予用户的某一角色时,其相应的操作权限也同时被撤消。

### 13.2.4 访问控制措施

访问控制是保证网络系统安全的主要措施,也是维护网络系统安全、保护网络资源的重要手段。通常具体的访问控制措施有以下几种:

## 1. 入网访问控制

人网访问控制是为用户安全访问网络设置的第一道关口。它是通过对某些条件的设置来控制用户是否能进入网络的一种安全控制方法。它能控制哪些用户可以登录网络, 在什么时间、地点(站点)登录网络等。

人网访问控制主要就是对要进人系统的用户进行识别, 并验证其合法身份。系统可以采用用户账户和口令、账户锁定、安全标识符及其他一些身份验证等方法实现。

## (1) 用户名和口令验证

每个用户在进行网络注册时,都要由系统指定或由用户自己选择一个用户账户(用户名)和用户口令。这些用户账户及口令信息都被存储于系统的用户信息数据库中。也就是说,每个要人网的合法用户都有一个系统认可的用户名和用户口令。

当用户要登录网络时,首先要输人自己的用户名和用户口令, 然后服务器将验证用户输入的用户名和用户口令信息是否合法。如果验证通过, 用户即可进人网络, 去访问其所需要且有权访问的资源, 否则用户将被拒于网络之外。

为保证用户口令的安全性, 要从口令的选取和口令的保护两方面着眼。

一般对口令的选取有一定的限制, 比如: 口令长度尽量长 (不得少于若干个字符, 比如 6 个字符); 口令不能是一个普通的英语单词、英文名字、昵称或其变形; 口令中要含有一些特殊字符; 口令中要字母、数字和其他符号的交叉混用; 不要使用系统的缺省口令; 不要选择用户的明显标识作为口令, 如用户的电话号码、出生日期、自己或家人姓名的拼音组合、自家的门/车牌号等等。这样的口令选取限制可有效地减少口令被猜中的可能性。

一般进行口令保护的方式有: 不要将口令告诉别人, 不要与别人共用一个口令; 不要将其记录在笔记本或计算机等明显位置; 要定期或不定期地更改口令;使用系统安全程序测试口令的安全性;重要的口令要进行加密处理等。

## (2)账户锁定

为了防止非法用户冒充合法用户尝试用穷举法猜测口令而登录系统, 系统应为用户设定尝试登录的最大次数。在达到该次数数值后, 系统将自动锁定该用户, 不允许其再尝试登录。

## (3) 用户账户的默认限制

必要时,系统为用户建立的账户中还可包含用户的人网时间、人网站点、人网次数和用户访问的资源容量等进行限制。

- 入网时间限制。系统可对用户的人网时间段加以限制。比如限制某用户只能在一星期中的星期一、三、五上午 8:00 11:00 时间段内人网,除此时间段外用户均不得人网。
- 入网站点限制。管理员可对用户人网使用的站点进行限制。比如限制某用户只能在第 15 号机上人网。这种限制可采取用户账户与站点的物理地址绑定的方法实现。
- 入网次数限制。系统可设定对同一个用户名的人网次数进行限制。
- 资源容量限制。系统可以对某用户账号使用的磁盘空间进行限制,或用户对交费网
络的访问“资费”用尽时, 系统应能对该账户进行限制, 不允许其再登录网络。


## 2. 权限访问控制

一个用户登录人网后,并不意味着他能够访问网络中的所有资源。用户访问网络资源的能力将受到访问权限的限制。访问权限控制一个用户能访问哪些资源 (目录和文件), 以及对这些资源能进行哪些操作。

在系统为用户指定用户账户后, 系统根据该用户在网络系统中要做的工作及相关要求,可为用户要访问系统资源设定访问权限。用户要访问的系统资源包括目录、子目录、文件和设备资源;用户要对这些资源的访问操作有读、写、建立、删除、更改等。

## 3. 属性访问控制

属性是文件、目录等资源的访问特性。系统可直接对目录、文件等资源规定其访问属性。通过设置资源属性可以控制用户对资源的访问。属性是在权限安全性的基础上提供的进一步的安全性。

属性是系统直接设置给资源的, 它对所有用户都具有约束权,一旦目录、文件等资源具有了某些属性, 用户(包括超级用户) 都不能进行超出这些属性规定的访问, 即不论用户的访问权限如何, 只按照资源自身的属性实施访问控制。如某文件具有只读属性, 对其有读写权限的用户也不能对该文件进行写操作。要修改目录或文件的属性, 必须有对该目录或文件的修改权; 要改变用户对目录或文件的权限, 用户必须具有对该目录或文件的访问控制权。属性可以控制访问权限不能控制的权限,如可以控制一个文件是否可以同时被多个用户使用等。

## 4. 网络服务器安全性

系统可控制使网络服务器上的软件只能从系统目录上装载, 而只有网络管理员才具有访问系统目录的权限; 网络允许在服务器控制台上执行一系列操作, 系统可授权控制台操作员具有操作服务器的权利, 控制台操作员可通过服务器控制台装载和卸载功能模块、安装和删除软件; 可通过设置口令和相关实用程序, 锁定服务器控制台键盘、禁止非控制台操作员操作服务器、修改和删除重要信息或破坏数据; 可以设定服务器登录时间限制、非法访问者检测和关闭的时间间隔等。

一个局域网上可有多个服务器, 每个服务器独立完成本系统的安全管理,而不依赖于其他服务器;每个服务器具有自己的管理员和管理员口令。

## 5. 身份验证

身份验证是证明某人是否为合法用户的过程,它是信息安全体系中的重要组成部分。

身份验证的方法有很多种,不同方法适合于不同的环境,网络组织可以根据自己的情况加以选择。以下是几种常用的身份验证方法。

- 用户名和口令验证。这是一种最简单的身份验证方法, 也是大家用得最多最熟悉的方法, 在前面已经有所介绍。
- 数字证书验证。数字证书是 CA 认证中心签发的用于对用户进行身份验证的一种 “执照”。数字证书的内容在 5.8 .3 中介绍。
- Security ID 验证。Security ID 已成为令牌身份验证事实上的标准,许多应用软件都能配置成支持 Security ID 作为身份验证手段的模式。Security ID 需要有一个能够验证用户身份的硬件装置 (安全卡), 该卡上有一个显示一串数字的液晶屏幕, 其数字每分钟变化一
次。用户在登录时先输人自己的用户名, 然后输人卡上显示的数字。系统通过对用户输人的数字进行验证, 如果数字正确, 用户则通过了身份验证, 即可进人系统访问资源了。
- 用户的生理特征验证。该验证是通过对用户人体的一处或多处生理特征进行检测而进行的验证。众所周知, 每个人的指纹是不一样的, 因此指纹是最常见的人体特征, 可用来进行身份验证。此外, 人们的视网膜、面部轮廓、笔迹、声音等都可作为人体特征用来进行身份验证。
- 智能卡验证。智能卡的外观和手感就像一张信用卡,但其原理就像一台小型计算机。智能卡是可编程的, 卡里有一个处理器, 具有存储和处理能力, 可用来对数值进行运算, 可无数次地接收写入信息, 可下载应用软件和数据, 然后可多次反复地使用它。用户在登录计算机网络时, 可用它来证明自己的身份。不仅如此, 它还可以代替身份证、旅行证件、信用卡、出人证等多种现代生活中离不开的证件。


## 6. 网络监测和锁定控制

网络管理员应对网络实施监控,服务器应记录用户对网络资源的访问,并以图形或文字或声音等形式报警,以引起网络管理员的注意。如果非法用户试图进人网络,网络服务器应能自动记录其企图尝试进入网络的次数, 如果非法访问的次数达到设定数值, 那么该账户将被自动锁定。

## 7. 网络端口和节点的安全控制

网络中服务器的端口往往使用自动回呼设备、静默调制解调器加以保护, 并以加密的形式来识别节点的身份。自动回呼设备用于防止假冒合法用户, 静默调制解调器用以防范黑客的自动拨号程序对计算机进行的攻击。网络还常对服务器端和用户端采取控制, 用户必须携带证实身份的验证器 (如智能卡、磁卡、安全密码发生器等), 在对用户的身份进行验证合法之后,才允许用户进人用户端。然后, 用户端和服务器端再进行相互验证。

## 8. 防火墙控制

防火墙是近期发展起来的一种保护计算机网络安全的技术性措施。防火墙是一个用以阻止网络中的黑客访问某个企业网络的屏障,也可称之为控制进/出两个方向通信的网关。在网络边界上通过建立起来的具有防火墙功能的网络通信监控系统, 可以隔离内部和外部网络,以阻挡外部网络的侵人。

## 13. <br> Windows NT 系统安全

Windows NT 系统在设计之初就将网络的安全问题作为其主要功能之一。Windows N T 就是设计在一套完整的安全机制基础上的,因而,使用 Windows N T 的任何部门都必须明确本系统的人网限制、访问控制、信息保护和系统审核的要求。通过对 Windows N T 系统的配置,可以对信息进行安全管理和控制非法用户的访问。Windows NT V3.5 和 Windows NT V4.0 版都已达到 TCSEC 的 C2 安全级; 其部分程序, 如身份验证、审计和把操作员和管理员账号分开等功能达到了更高的 B2 安全级。在 Windows NT 中, C2 级安全特性表现为: 可自由决定访问控制 (允许管理员和用户自己定义对所拥有对象的访问控制);
对象重用;身份的确认和验证; 安全审计(建立和维护访问记录以便于管理员进行审计)。

### 13.3.1 Windows NT 的安全基础

Windows NT 系统可使用户将网络资源作为对象组进行管理,并实施身份验证和访问控制。只有将部门的安全要求与 Windows NT 系统底层的安全机制有机地结合起来, 才能充分发挥 Windows NT 的各项安全特性。

## 1. Windows NT 中的对象

Windows N T 的安全机制是建立在对象的基础上的, 因此,对象的概念与安全问题密切相关。

对象是构成 Windows NT 操作系统的基本元素, 它可以是文件、目录、存储器、驱动器或系统程序等。

对象为 Windows NT 操作系统提供了较高的安全级别。对外部用户, 他们的数据封装在对象中,并只按对象的功能所定义的方式提供数据。对所有对象的操作都必须事先得到授权并由操作系统来执行。这就建立起一个保护层, 可以有效地防止外部程序直接访问网络数据。Windows NT 正是通过组织程序直接访问对象来获得较好的安全性的。

在 Windows NT 中, 对象的属性可由安全描述器和存储标识来设定和保护。可被设定的属性包括: 对象的所有者和使用者的安全身份标识(SID); 可移植性操作系统界面子系统使用的组安全身份标识 (GID); 用户和组访问权限的访问控制列表 (ACL); 审核信息生成的系统访问控制列表(ACL)。

## 2.Windows NT 中的网络模型

Windows NT 系统中有两种基本的网络模型:工作组模型和域模型。

## (1) 工作组模型

工作组是一组由网络连接在一起的计算机群, 但它们的资源与管理是分散在网络的各个计算机上的,与域的集中式管理不同。每台运行 Windows N T 的计算机都有自己的目录数据库。网络中没有专门的域控制器和服务器。这是一种“对等网”结构,工作组中的每台计算机既可以是工作站, 也可以是服务器。它们在管理自己的账号的同时, 只要经过适当的权限设置, 每台计算机就可访问其他计算机的资源, 也可以提供资源给其他计算机使用。这种结构的设计和实现容易, 易于维护, 适合于用户较少的网络, 一旦用户增多, 效率将迅速下

降。

## (2)域模型

域(Domain)是一个共享公共目录数据库和安全策略的计算机及用户的集合, 它提供登录认证, 并具有惟一的域名。域也是 Windows NT 网络环境中一个基本的安全集中管理的单位,是 Windows NT 目录服务的基本单元。在一个单机工作站上, 域就是计算机本身。每个域都有自己的安全策略以及与其他域相关的安全关系。

一个域必须有一台运行 Windows N T Server 并被配置为主域控制器的计算机。为了安全起见, 还可以设置一台备份域控制器, 平时它可分担主域控制器的负荷。一旦主域控制器出现故障, 备份域控制器将自动“升格”为主域控制器, 从而可保证整个域仍能正常工作。

信任关系也叫委托关系, 是用来建立域与域之间的连接关系的。它可以执行对经过委托的域内用户的登录审核工作。域之间经过委托后, 用户只要在某一个域内有一个用户账
号, 就可以使用建立了委托关系的其他域内的网络资源了。信任关系分为单向和双向两种。若 A 域信任委托 B 域, 则 B 域的用户可以访问 A 域的资源, 而 A 域的用户则不能访问 B 域的资源, 这就是单向委托; 若 A 域的用户也想访问 B 域的资源, 那么必须再建立 B 域信任 A 域的委托关系, 这就是双向委托。

Windows N T 系统提供四种基本的域模型来组合各种配置, 以满足用户需求。四种域模型为单域模型、主域模型、多主域模型和完全信任域模型。

- 单域模型: 网络中只有一个域, 就是主域, 域中有一个主域控制器和一个或多个备份域控制器。该模型适合于用户较少的网络中。
- 主域模型: 网络中至少有两个域,但只在其中一个域(主域)中创建所有用户并存储这些用户信息。其他域则称为资源域,负责维护文件目录和打印机资源,但不需要维护用户账户。资源域都信任主域,使用主域中定义的用户和全局组。该模型适合于用户不太多,但又必须将资源分组的情况。
- 多主域模型: 网络中有多个主域和多个资源域,其中主域作为账户域,所有的用户账户和组都在主域之上创建。各主域都相互信任,其他的资源域都信任主域,但各资源域之间不相互信任。该模型便于大网络的统一管理, 具有较好的伸缩性。因此,该模型适合于用户数很多且有一个专门管理机构的网络中。
- 完全信任域模型 : 网络中有多个主域,且这些域都相互信任。所有域在控制上都是平等的,每个域都执行自己的管理。该模型适合于各部门管理自己的网络情况。


## 3. 用户账户、权力和权限

每个要登录 Windows NT 的用户, 都要有一个用户账户, 该账户是由系统管理员创建的, 用户账户中包括用户的名称、密码、用户权力、访问权限等信息。创建账户后, Windows NT 再为账户指定一个惟一的安全标识符(SID)。

用户和组都有一定的权力, 权力定义了用户在系统中能做什么。用户和组的普通权力有: 从网络中访问计算机、向域中添加工作站和成员服务器、备份文件和目录、改变系统时间、强制从远程系统退出、装/卸设备驱动器、本地登录、恢复文件和目录等。这些权力大多数只指定给负责管理的用户。

用户和组要有权限才能使用对象。权限可由系统管理员赋予用户, 也可由文件、目录等对象的所有者赋予用户。Windows N T 的权限有:列表、读取、添加、修改、添加并读取、完全控制等。

## 4.目录数据库

目录数据库是整个网络系统中不可缺少的重要组成部分。目录数据库用来存放域中所有的安全数据和用户账户信息。用户登录时, 用它来核对、检验用户输入的数据是否符合其相应的身份和使用权限。该数据库被存放在主域控制器中, 在备份域控制器中也有它的备份。

## 5. 注册表

注册表是包括应用程序、硬件设备、设备驱动程序配置、网络协议和网卡设置等信息的数据库。它是一个具有容错功能的数据库, 如果系统出现错误, 日志文件使用 Windows NT 能够恢复和修改数据库, 以保证系统正常运行。注册表数据结构包含四个子树: HKEY_ LOCAL_MACHINE (含有本地系统的硬件设置、操作系统设置、启动控制数据和驱动器驱
动程序等部分信息), HKEY_CLASSES_ROOT (含有与对象的连接及文件级关联相关的信息), HKEY_CURRENT_USER(含有正登录上网的用户信息) 和 HKEY_USERS(含有所有登录人网的用户信息)。

### 13.3.2 Windows NT 的安全漏洞

虽然Windows NT 系统采用了较强的安全性规则, 但该系统还是存在许多安全漏洞。

## 1.SAM 数据库漏洞

SAM (安全账户管理) 数据库的一个拷贝能够被某些工具用来破解口令, 这样的工具有 PW Dump 和 NT Crack。PW Dump 的作者还有另一个软件包 PW Audit, 它可以跟踪由 PW Dump 获得的资料或软件的内容。而 Windows NT 的 Administrator 账户、Administrator 组中的所有成员、备份操作员、服务器操作员以及所有具有备份特权的用户, 都可以拷贝 SAM 数据库的内容。采取严格限制 Administrator 组和备份组账户的成员资格, 加强对这些账户的跟踪, 通过对 SAM 数据库进行的任何权限改变和对其自身修改进行审计, 改变默认权限设置等措施,可避免或减少黑客对 SAM 数据库漏洞的攻击。

SAM 数据库的另一个漏洞是: 木马和病毒可能利用默认权限对 SAM 数据库进行备份,获取访问 SAM 数据库中的口令信息,或通过访问紧急修复磁盘的更新盘来获取信息。而木马和病毒在 Administrator 管理员、Administrator 组成员、备份操作员、服务器操作员以及具有备份特权的用户操作时, 或在用默认权限作备份时,或在访问紧急修复磁盘的更新盘时均可执行。限制所有具有 Administrator 和备份特权的账户不能浏览 Web 站点, 所有账户只能具有 User 或 Power User 组的权限, 可以克服这种漏洞。

## 2.SMB 协议漏洞

SAM 数据库和Windows NT 服务器文件都可能被Windows NT 的 SMB (Server Message Block) 所读取。而SMB 协议存在一些尚未公开的漏洞: SMB 协议可不用授权即可存取 SAM 数据库和 Windows NT 上的文件; SMB 协议允许远程访问共享目录、Registry 数据库和其他一些系统服务; SMB 协议在验证用户身份时,使用一种简易加密方法发送申请包,因此它的文件传输授权机制很容易被击溃。

SMB 协议漏洞的补救办法:在防火墙上截断从端口 135 到 142 的所有 TCP 和 UDP 协议连接, 这样可有利于控制, 其中包括对基于 RPG 协议工作于端口 135 的安全漏洞的控制。最安全的方法是利用代理(Proxy)限制或拒绝网络上基于 SMB 协议的连接。在内部路由器上设置 ACL, 在各独立子网间, 截断端口 135 到 142 , 但限制 SMB 的连接可能导致系统功能的局限性。

## 3. Registry 数据库权限漏洞

Windows N T 上的默认数据库 Registry 的权限设置有很多不合适之处。Registry 数据库的默认权限是将“完全控制” (Full Control)和“创建” (Create)权限赋予了“所有人”, 这样的设置可能引起 Registry 数据库文件被删除或改变。

采取以下措施, 可避免或减少 Registry 数据库漏洞的损失: 严格限制对 Registry 数据库只可进行本地注册, 不可远程访问; 在 Windows NT 工作站上限制对 Registry 数据库编辑工具的访问;使用第三方工具软件锁住 Registry 数据库; 把 “所有人”默认的 “完全控制”权限改为只有“创建”。

## 4. 权限设置漏洞

Windows N T 系统文件权限的设置上存在安全漏洞。比如,复制或移动一个文件到其他目录下, 则该文件的权限将继承其新目录的权限。而在 Windows NT 系统中对文件进行复制和移动操作是很容易的。因此, 要经常检查文件权限的设置是否恰当, 尤其是在复制和移动文件后, 这样就可能避免这种漏洞的影响。

## 5.打印机漏洞

打印机操作员组中的任何一个成员对打印驱动程序都具有系统级访问权。人侵者可以利用这个安全漏洞, 用一个木马程序替换一个打印驱动程序, 或在打印驱动程序中插人恶意病毒, 它不需要任何特权就可执行。因此, 在赋予打印机操作员权限时, 要采取审慎态度, 要限制打印机操作员组的成员人数, 并进行系统完整性检查, 适当配置和调整审计, 并定期检查审计文件。

## 6.建立域别名漏洞

Windows N T 域用户可以不断地建立新的用户组直至系统资源枯竭。Windows N T 能方便地建立用户组的这个特性很容易遭到拒绝服务的攻击。虽然针对该问题, 微软公司已开发了补丁程序,但用户发现该补丁程序与注册表的设置有冲突。

除以上 6 种漏洞外, Windows NT 系统还存在默认账号漏洞、无限制地尝试连接、 Administrator特权被利用、登录用户名显示、NTFS 文件系统的安全设置容易被绕过, 以及浏览器与 Windows NT 计算机有关的安全漏洞等。

### 13.3.3 Windows NT 的安全性机制和技术

## 1 . 安全性机制

Windows NT Server 采用域模型来建立网络安全环境。每个域都有一个惟一的名称,并由一个域控制器对一个域的网络用户和资源进行安全管理。这种域模型采用的是客户/服务器结构。Windows N T 的安全管理主要包括账号规则、用户权限规则、审计规则和域管理机制等。

## (1) 账号规则

账号规则就是对用户账号和口令进行安全管理,即人网访问控制。

Windows N T 的安全机制可根据用户请求,为要人网的用户分配一个用户账号和用户密码, 以便进行人网安全控制。该用户账号是 Windows NT 基本的安全措施, 它决定着用户对网络资源的访问能力和权限。用户账号主要包括：

- 用户名: 每个用户都要使用用户名来标识,且在网络中用户名必须是惟一的。用户必须使用用户名登录入网。
- 用户密码: 每个用户都可以设置一个密码, 密码将被加密并存储起来。通常, 密码要有最小长度、最短修改周期、最长使用期限、密码惟一性等限制。

此外,用户账号还包括对用户入网的时间限制、人网站点限制、账号锁定、用户对特定文件/目录的访问权限限制和用户使用的网络环境的限制等。

## (2) 用户权限规则

用户人网后,并不意味着能访问网络中的所有资源。用户访问网络资源的能力将受到访问权限的控制。Windows N T Server 采用两类访问权限: 用户访问权限和资源访问权限。
用户访问权限 (也称共享权限) 规定了人网用户以何种权限使用网络资源。Windows N T Server 的用户访问权限有四种: 完全控制、更改、读写和拒绝访问,其中完全控制权限最大。

资源访问权限是由资源的属性决定的。在 Windows N T 网络中, 磁盘文件、目录等资源的属性也称为访问权限, 并取决于 Windows N T 系统安装时所采用的文件系统。

Windows NT 网络支持两种文件系统: FAT 和 NTFS。FAT 是与 DOS 相兼容的文件系统, 但不提供任何资源访问权限, 网络访问控制只能依赖于用户的访问权限; NTFS 是 Windows N T 特有的文件系统,具有严格的目录和文件访问限制。用户对网络资源的访问将受到 NTFS 访问权限和用户访问权限的双重限制, 但以 NTFS 访问权限为主。

NTFS 允许用两种访问权限来控制用户对特定目录和文件的访问: 一种是标准权限, 是口径较宽的基本安全性措施; 另一种是特殊权限, 是口径较窄的精确性安全措施。

在标准权限中,文件访问权限有: No Access(不可访问)、Read(读)、Change(改变) 和 Full Control(完全控制); 目录访问权限有: No Access(不可访问)、List(列表)、Read(读)、 Add(增加)、Change(改变)和 Full Control(完全控制)。

在特殊权限中,文件访问权限有: Read(读)、Write(写)、Execute(执行)、Delete(删除)、 Change Permission(改变权限) 和 Take Ownership(获取所有权); 目录访问权限也是这 6 种,但它与文件访问权限的使用范围和限制程度不同。

在一般情况下,使用标准权限来控制用户对特定目录和文件的访问。当访问权不能满足系统安全性需要时, 可以进一步使用特殊权限进行更精确的安全性控制。如果 Windows NT Server 安装时采用的是 NTFS, 则系统的主要目录都被自动设置了相应的标准权限, 在这些目录中所建立的文件将自动继承其父目录的访问权限。

(3) 审核规则

审核是系统对用户操作行为的跟踪, 管理员可根据审核结果来控制用户的操作。 Windows N T 可对如下事件进行审核: 登录和注销、文件和对象的访问、用户权限的使用、用户和组的管理、安全性策略的改变、启动与关闭系统的安全性和进程的跟踪等。跟踪审核结果存放在安全日志文件中。

## (4)域管理机制

用户每次登录的是整个域,而不是某一服务器。用户所在域的物理范围即使相隔较远,但在逻辑上是一个域, 这样就便于管理。在网络环境下, 使用域管理机制就显得更为有效。在 Windows NT 中,域所使用的安全机制信息或用户账号信息都存放在目录数据库中,这就是安全账号管理数据库。目录数据库存放在服务器中并复制到备份服务器中。在每次用户登录时, 都要通过目录数据库检查用户账号信息, 因此, 在对 Windows N T 进行维护时,应特别注意目录数据库的完整性。

## 2. 安全性技术

(1) Kerberos

Kerberos 是 Windows NT 系统一种验证协议, 它定义了客户端和密钥分配中心网络验证服务间的接口。Windows NT 5.0 密钥分配中心在域的每个域控制器上进行验证服务。 Kerberos 客户端的运行是通过一个基于 SSPI (一个 Win32 的安全系统 API) 的 Windows NT 安全性接口来实现的。Kerberos 协议已被完全集成到 Windows NT 5.0 的安全性结构
中。

## (2) 加密文件系统

Windows NT 中提供了一种新一代 NTFS 的加密文件系统(EFS)。系统中一个文件在使用之前不需要手工解密, 因为 EFS 使加密和解密对用户都是透明的, 加密和解密过程自动地发生在向硬盘中写人数据和从硬盘中读取数据时。当发生磁盘输人/输出时, EFS 能自动地检测对象是否为加密过的文件。如果是加密文件, EFS 从系统的密钥存储区得到一个用户的私有密钥。如果访问加密文件的用户不是原来对该文件加密的用户,他的私有密钥必然与加密用户的私有密钥是不同的,因此他也就得不到原文件的解密文件,而得到的却是一个对文件的拒绝访问信息。所有数据加密和解密都不需要用户的参与,用户访问一个经过加密的文件或目录,可以有两种结果,那就是允许访问或拒绝访问。

Windows NT 的 EFS 提供从单一文件到整个目录的加密和解密功能。如果对于一个目录进行加密,目录中所有的子目录和文件都被自动加密。

## (3) IP Security

为了防止来自网络内部的攻击, Windows NT 推出一种新的网络安全性方案-IP Security。它符合 IETF (Internet 工程部) 的 IP 安全性协议标准, 支持在网络层一级的验证、数据完整性和加密。IP Security 与 Windows NT Server 内置的安全性集成在一起, 为维护安全的 Internet 和 Intranet 通信提供了一个理想的平台。

IP Security 使用基于工业标准的算法和全面的安全性管理,为发生在企业防火墙两侧的基于 TCP/IP 的通信提供了安全性支持,使 Windows NT 能够同时抵御来自内部和外部的攻击。

Windows N T 的 IP Security 功能的实现是透明的。利用 IP Security 功能,网络管理员可为网络提供一层强有力的保护,所有的应用程序都自动地继承了 Window N T 的新安全性。

### 13.3.4 Windows NT 的安全管理措施

Windows NT 在进行安全管理时,具体可采取如下一些安全措施。

## 1.物理安全管理

Windows NT 采取了摘掉或锁死软盘驱动器, 禁止 DOS 或其他操作系统访问 NTFS 分区, 在服务器上设置系统启动口令, 设置 BIOS 禁用软盘引导系统, 不创建任何 DOS 分区,保证机房的物理安全等管理措施。

## 2. 账号和密码策略

Windows NT 域用户管理器通过为用户分配的账号和密码来验证用户身份, 保证系统资源的安全。用户账号是系统根据用户的使用要求和网络所能给予的服务为用户分配的，账号名称通常是公开的。用户账号密码在密码的选取、密码的维护等方面都要符合安全性要求和使用方便的原则,用户账号密码是保密的。

## 3. 控制授权用户的访问

在 Windows NT 域中配置适当的 NTFS 访问控制可增强网络安全。在系统默认情况下, 每建立一个新的共享, Everyone 用户就享有 “完全控制” 的共享权限, 因此在使用时要取消或更改默认情况下 Everyone 组的 “完全控制”权限, 要始终设置用户所能允许的最小目录
和文件的访问权限。为安装后默认的 Guest 用户设置密码,以防被黑客利用。

为每个用户指定一个工作组, 为工作组指定文件和目录访问权限, 这样, 当某个用户角色变更时, 只要把该用户从工作组中删除或指定他属于另一组,即可收回或更改该用户的访问权限。所以说,将用户以“组”的方式进行管理,是用户管理的一个有效方法。

## 4. 及时下载和更新补丁程序

经常光顾安全网站, 下载最新补丁程序, 或用最新的 Service Pack 升级 Windows NT Server, 因为 Service Pack 中有所有补丁程序和新发表的诸多安全补丁程序。

## 5. 控制远程访问服务

远程访问是人侵者攻击 Windows N T 系统的常用手段,因此可以采取控制远程服务的方法减少对系统的攻击。Windows NT 防止外来人侵最好的功能是认证系统。Windows 95/98 和 Windows NT Workstation 客户机不仅可以交换用户 ID 和口令数据, 而且还使用 Windows 专用的响应协议, 这可确保不会出现相同的认证数据, 并可以有效地阻止内部黑客捕捉网络信息包。如条件允许,可使用回叫安全机制,并尽量采用数据加密技术,以保证数据安全。

## 6. 启动审查功能

为防止未经授权的访问, 可以利用域用户管理器启用安全审查功能, 以便在安全日志中记录未经授权的访问企图, 以便尽早发现安全漏洞并及时补救。但要结合工作实际, 设置合理的审计规则。切忌审查太多,以免无时间全部审查安全问题。

## 7 . 应用系统的安全

在 Windows N T 上运行的应用系统, 应及时通过各种途径获得补丁程序, 以解决其安全问题。把 IIS 中的 sample、scripts、iisadmin 和 msadc 等 Web 目录设置为禁止匿名访问并限制 IP 地址。把 FTP、Telnet 的 TCP 端口改为非标准端口。Web 目录、CGI 目录、scripts 目录和 WinN T 目录只允许管理员完全控制。凡是涉及到访问与系统有关的重要文件, 除系统管理员账号 Administrator 外, 其他账号均应设置为只读权限。

## 8 . 取消 TCP/IP 上的 NetBIOS 绑定

Windows NT 系统管理员可以通过构造目标站 NetBIOS 名与其IP 地址之间的影像,对 Internet 或 Intranet 上的其他服务器进行管理,但非法用户也可从中找到可乘之机。如果这种远程管理不是必需的, 可立即取消 (通过网络属性的绑定选项, 取消 NetBIOS 与 TCP/IP 之间的绑定),或禁用 NetBIOS 端口。

### 13.3.5 Windows NT 的数据保护

由于网络系统出现故障、数据丢失等原因致使系统不能可靠运行或系统不能正常启动时, Windows N T 系统可为网络用户提供快速、准确的服务, 如系统修复或数据恢复等, 使系统能正常工作。

## 1. Windows NT 数据保护方法

Windows NT 系统可提供以下的数据保护方法:

(1) 磁带备份

磁带备份就是将主机上的数据备份到其他存储介质上, 以确保数据的安全, 这是最简单也是最经济的数据保护方法。
磁带备份又分为完全备份、一般拷贝、日常备份、增量备份和差异备份。

完全备份是将所有文件(不管其数据是否有变化) 都存人备份介质中;一般拷贝就是只将没有备份的数据进行备份,但不将其标记为 “已备份”; 日常备份就是把那些一天中发生了改变却还没有备份的数据备份,也不将其标记为 “已备份”; 增量备份就是只备份那些自从上次备份以来发生了变化的数据; 差异备份与增量备份差不多,只是差异备份不将备份后的数据作“已备份”标记。

## (2) 不间断电源保护

不间断电源 (UPS)保护可使 Windows N T 系统在突然断电的情况下继续使用一段时间,在电源恢复之前安全关机, 从而避免因断电造成的数据丢失。

UPS 可根据其工作方式的不同可分为后备式 UPS 和在线式 UPS 两种。后备式 UPS 只在交流电源出现故障时启动, 价格较便宜, 但安全性能较差; 在线式 UPS 可以为服务器提供电压保护, 平时工作时对系统电源实行监控, 在电源掉电时自动接替电源工作, 用户根本觉察不出该过程,这种方式的安全性较好,但价格也较昂贵。

## (3) 系统容错

系统容错技术可使计算机网络系统在发生故障时, 保证系统仍能正常运行, 继续完成预定的工作。Windows NT 网络系统的系统容错是建立在标准化的独立磁盘冗余阵列 (RAID) 基础上的,它采用软件解决方案,提供了三种 RAID 容错手段 (RAID0、RAID1、 RAID5) 和扇区备份。

- 带区集(RAID0)。带区集是将多个磁盘上的可用空间组合成一个大的逻辑卷, 数据将按系统规定的数据段为单位依次写人不同的磁盘上。虽然 RAID0 是顺序传送的,但多个读/写操作可以相互重叠进行, 因此 RAID0 可提供较好的磁盘读写性能,但不提供任何容错功能。
- 镜像集(RAID1)。镜像集由主盘和副盘两个磁盘组成。所有写人主磁盘的数据也同时写人副磁盘, 如果主磁盘发生故障, 则系统便使用副磁盘中的数据。RAID1 通过两个磁盘互为备份来提供数据保护。RAID1 主要用于提供存储数据的可靠性, 但必须以较大的磁盘空间冗余为代价。
- 带奇偶校验的带区集(RAID5)。在带奇偶校验的带区集中,阵列内所有磁盘的大块数据呈带状分布, 数据和奇偶校验信息将存放在磁盘阵列中不同的磁盘上, 以提高数据读写的可靠性。RAID5 具有较好的数据读取性能, 但写人性能较差, 通常需要消耗三倍读取操作的时间, 因为写人操作时要进行奇偶校验计算。因此, RAID5 主要用于以读取操作为主的应用系统中。
- 扇区备份。扇区备份也叫“热修复”, 是 Windows NT 提供的又一种容错方法。系统在发现扇区损坏时, 对该坏扇区进行标记, 并将其上的数据尽可能地转储到好的扇区上, 从而保证数据的完整。这种容错方法只是在 NTFS 分区的 SCSI 硬盘上才能实现, 而 ESDI 和 IDE 磁盘上无法实现此项功能。


## 2. Windows NT 系统的恢复和修复

采用了容错技术的系统恢复的效果较好。但如果没有采用容错技术,由于各种原因使得 Windows NT 系统无法正常启动时, 无论采取什么方法修复系统, 效果都是有限的。以下是常用的 Windows N T 系统修复或恢复方法。

(1)利用“系统配置”环境恢复 Windows NT 系统

当用户由于新增了驱动程序和用户修改了注册表 Registry 数据库后而无法正常启动 Windows NT 系统时, 可以尝试利用上一次正确的 “系统配置” 环境启动系统。但它不适合由于驱动程序或文件损坏、丢失所造成的不能启动的情况。

(2)利用“紧急修复磁盘”修复被损坏的 Windows NT 系统

在 Windows NT 系统工作站或服务器安装时,都允许用户制作一张“紧急修复磁盘”。该磁盘中包含了修复系统所必需的数据。当 Windows NT 系统文件、启动变量或启动分区被损坏时,无法利用上一次正确的“系统配置”环境启动,则利用该磁盘可以恢复系统正常工作。作为网络管理员,应该及时制作该磁盘,并且要定期进行更新。

## (3)利用“Windows NT 启动盘”修复被损坏的系统

当 Windows NT 系统损坏而又无法启动时,用户可以利用自己制作的“Windows NT 启动盘”修复系统。当用户系统的部分启动文件损坏或映射磁盘区出现故障时,也可以使用 “Windows N T 启动盘”进行修复。

利用“Windows NT 系统启动盘”修复系统的方法,要求用户事先制作一张“Windows N T 启动盘”。要注意的是,在本计算机上制作的 “Windows N T 启动盘”只能用于本计算机, 而不能用于其他计算机上, 这一点与“紧急修复磁盘”的使用情况不同。



### 13.4.1 Windows 2000 的安全漏洞

Windows 2000 系统面世不久,就被发现存在安全漏洞。作为已被广泛应用的网络操作系统, 无论是对于普通用户还是对于公司企业用户, Windows 2000 的影响都是巨大的。如果用户不能对这些漏洞进行及时的补救, 系统就可能被攻击, 造成不必要的损失。下面简单介绍 Windows 2000 的漏洞及相应的应付策略。

## 1. 登录验证机制漏洞

在 Windows 2000 启动之后, 按照屏幕提示按下“Alt $+\mathrm{Ctrl}+$ Del”进行登录, 在登录界面将光标移至用户名输人框, 按键盘上的 “ $C \mathrm{Ctrl}+\mathrm{Shift}$ ”键进行输人法的切换, 屏幕上出现输人法状态条, 在出现的 “全拼”输人法中将鼠标移至输人法状态条点击鼠标右键, 出现的选单中选择 “帮助”, 然后继续选择“输人法人门”, 在窗口顶部会出现几个按钮, 奥妙就在 “选项按钮”上。如果是未安装 Windows 2000 Service Pack1 或 IE5.5 的系统, 用鼠标左键点击“选项”按钮, 在出现的选单中选择 “主页”, 这时在已出现的帮助窗口的右侧会出现 IE 浏览器界面中的 “此页不可显示”页面, 其中有个“检测网络设置”的链接, 点击它就会出现网络设置选项, 这样任何人都可以对网络设置甚至控制面板做任何修改。或者之前用鼠标左键点击“选项”按钮时, 在出现的选单中选择“Internet 选项”, 就可以对主页、连接,安全、高级选项等做任何修改。最为严重的是用鼠标右键点击先前提到的“选项”按钮会出现一个选单, 选择“跳至 URL”, 这时会出现一个对话框, 其中有一个跳至该 URL 输人框, 输人你想看到的路径,比如 $C$ : \, 那么这时在已出现的帮助窗口的右侧会出现资源管理器 $C$ 盘的界面显示, 这时已
经是使用系统管理员权限对 $\mathrm{C}$ 盘进行操作了。操作者可以对看到的数据做任何操作, 这样他就完全绕过了 Windows 2000 的登录验证机制。

如果系统是安装了 Windows 2000 Service Pack1 或 IE5.5 的系统, 上面所用的“网络设置选项”就不能执行了, 但“Internet 选项”仍可执行, 资源管理器界面仍可出现, 通过路径输人, 所有的文件夹中的文件和根目录下的文件都可看到, 虽已不能直接对文件夹和文件进行操作, 然而仍可以用鼠标右键点击文件夹和文件选择进行删除、重命名和发送到软盘等操作, 而且更为严重的是操作者可以对文件夹进行共享操作, 在单个文件出现的对话框中选择属性, 就可以任意添加共享权限, 如任何人都能完全控制的权限, 这样网络中的所有人都可以通过网络远程登录完全控制所有数据资料。

Windows 2000 中该漏洞的危害性是很大的,可采取以下步骤修补漏洞:

- 把不必要的输人法删除掉, 如郑码。
- 把要使用的但有漏洞的输人法的帮助文件删除掉。这些帮助文件通常存放在 Windows 2000 的安装目录下, 如帮助文件 Winim.com (输人法操作指南), Winsp.chm (双拼输人法帮助), Winzm.chm (郑码输人法帮助), Winpy.chm (全拼输人法帮助), Wingb. $\operatorname{chm}$ (内码输人法帮助)。
- 尽快从微软公司网站上下载相关的简体中文版和英文版 Windows 2000 补丁程序。


## 2. NetBIOS 漏洞

NETBIOS 共享人侵问题从 Windows NT 问世时就从未解决, 且它一直是 Windows NT 系统最常见的人侵手段。特别是 IPC \$Null Session(空对话) 在 Windows NT 系统里是已知的安全隐患, 虽然加了 SP3 补丁程序后可以通过修改注册表对其进行限制, 但不知为什么在 Windows 2000 中又原封不动地保留了该漏洞。

对于该漏洞, 可以通过在注册表中做相应修改来解决。

## 3. Telnet 漏洞

Windows 中的 Telnet 是网络管理员很喜欢的网络实用工具之一。但在 Windows 2000 中 Telnet 在守护其进程时, 在已经被初始化的会话还未复位的情况下, 很容易受到一种普通的拒绝服务攻击。

Telnet 连接后, 在初始化的对话还没有被复位时, 在一定的时间间隔后, 如果连接用户还没有提供登录的用户名和密码, Telnet 的对话将超时。直到用户输人一个字符后连接才被复位。这样, 如果恶意用户连接到 Windows 2000 的 Telnet 守护进程中, 并且对该连接不进行复位操作, 就可以有效地拒绝其他任何用户连接到该 Telnet 服务器。这主要是因为此时 Telnet 的客户连接数的最大值是 “1”。

## 4. 奇怪的系统崩溃漏洞

Windows 2000 系统有一个奇怪的漏洞: 使用系统的终端用户可以通过按住右“Ctrl”键, 同时再按两次 “Scroll Lock”键, 就可使整个 Windows 2000 系统完全崩溃。但同时又在 “ $\mathrm{C}: \backslash \mathrm{WinNT} \backslash$ ” 目录下删除完整的当前系统内存记录, 内存记录文件名为 Memory.dmp。当然, 这个奇怪的漏洞在默认状态下是关闭的, 但可通过修改注册表的方法将其激活。如运行 regedt32.exe(Windows 2000 的 32 位注册表编辑器), 进人到 HKEY_LOCAL_MACHINE $\backslash S Y S T E M \backslash$ CurrentControlSet \Services \i8042prt \Parameters 下, 新建一个名为 Crash $\mathrm{OnCtrlScroll}$ 的双字节值, 然后再设置一个不为零的值, 退出后重新启动。
当这一切做完后, 按住右“Ctrl”键,同时再按两次“Scroll Lock”键,就可以尝试系统崩溃了,显示器出现黑屏,并伴有以下信息:

*     *         * STOP:0x000000e2(0x00000000,0x00000000,0x00000000,0x00000000)

The end-user manually generated the crashdump.

值得注意的是, 该奇怪特性在 Windows NT 中也存在, 不知这是不是微软程序员作测试的一个小功能。不过,如果被黑客或病毒利用是很危险的。

## 5.IIS 服务泄漏文件内容

Windows 的 IIS 是在大多数 Windows NT/2000 服务器上使用的服务器软件。安装了 IIS 后, 就自动安装了多个 ISAPI (Internet 服务的应用编程接口), 允许开发人员使用 DLL 扩展 IIS 服务器的性能。

IIS 服务泄漏文件内容漏洞: 当 Windows IIS 4.0/5.0(远东地区版)在处理包含有不完整的双字节编码字符的 HTTP 命令请求时, 将导致 Web 目录下的文件内容泄漏给远程攻击者。

Windows IIS 的远东地区版本包括中文、韩文和日文版,这些都是使用双字节编码的格式。攻击者通过提交一个特殊的 URL, 可使 IIS 使用某个 ISAPI 动态链接库打开某种所不能解释的类型文件, 并获得该文件的内容。依靠系统安装的 ISAPI 应用程序的类型, 攻击者可以获得 Web 根目录或虚拟目录下的文件内容, 这些文件可以是普通的文本文件,也可以是二进制文件。

黑客们可使用 Unicode(采用双字节对字符进行编码的统一的字符编码标准) 方法对这个漏洞进行攻击。可以说这是近一段时期较为流行的攻击人侵手段, 仅国内 2003 年初就有几个网络公司的网站被这样攻击。

由于某些双字节的原因, Windows 2000 在处理某些特殊字符时, 与英文版本不同。利用这种漏洞, 攻击者就可以通过这些特殊字符绕过 IIS 的目录审计, 远程执行任意命令。

## 6.ICMP 漏洞

ICMP 是 Internet 控制报文协议,其主要作用是当系统出错时向源主机传输错误报告控制信息, 以便源主机更好地重发传送失败的数据报信息。ICM P 的一个特点是无连接。只要发送端完成 ICMP 报文的封装, 并将其传输给路由器, 该报文就会自己去寻找目的地址。该特点使得 ICM P 协议非常灵活方便,但这同时也带来了致命的缺陷, 信息包很容易被伪造。

任何人都可以伪造一个 ICMP 报文并发送出去。伪造者可以利用 SOCK_RAW 编程直接改写报文的 ICMP 首部和 IP 首部,这样的报文携带的源地址是伪造的, 目的端根本无法追查。根据这个原理, 出现了不少基于 ICM P 的攻击软件, 有通过网络架构缺陷制造 ICMP 风暴的, 有使用大报文堵塞网络的, 有利用 ICMP 碎片攻击消耗服务器 CPU 的, 甚至如果将 ICMP 协议用来进行通信,可以制造出不需要任何 TCP/UDP 端口的木马。

### 13.4.2 Windows 2000 的安全性措施和技术

## 1. 安全性措施

由于 Windows 2000 操作系统有良好的网络功能, 在 Internet 中有部分网站服务器使用 Windows 2000 作为主操作系统, 因此它也往往会被攻击者选为攻击对象。作为

Windows 2000 的用户,可以采取以下措施来提高 Windows 2000 系统的安全性。

## (1)及时备份系统

为防止系统在使用过程中发生意外而不能正常运行, 应对 Windows 2000 系统进行系统备份, 最好是在完成 Windows 2000 系统安装后就对整个系统进行备份。以此作为完整的备份系统来验证系统的完整性, 检查系统文件是否给非法修改过。如果发生系统文件被破坏,也可使用系统备份来恢复到正常状态。备份信息时,可以把完好的系统信息备份在 CD- ROM 光盘上。以后可以定期地将系统与光盘上的信息进行比较, 以验证系统的完整性是否受到破坏。如果对安全级别的要求特别高, 则可将光盘设置为可启动的, 并将验证工作作为启动过程的一部分, 这样, 只要可以通过光盘启动, 就说明系统是完整的。

## (2)设置系统格式为 NTFS

安装 Windows 2000 时,应选择自定义安装, 仅选择个人或单位必需的系统组件和服务, 取消不必要的网络服务和协议。因为服务和协议安装得越多, 人侵者可利用的途径就越多, 潜在的系统安全隐患也就越大。在选择 Windows 2000 文件系统时, 应选择 NTFS 文件系统, 充分利用 NTFS 文件系统的安全性。NTFS 文件系统可将每个用户允许读写的文件限制在磁盘目录下的任何一个文件夹内,而且 Windows 2000 新增的磁盘限额服务还可以控制每个用户允许使用的磁盘空间大小。

## (3) 加密文件或文件夹

为提高文件的保密性,可利用 Windows 2000 系统提供的加密工具对文件或文件夹进行保护。其具体操作步骤为: 在“资源管理器”中用鼠标右键单击想要加密的文件或文件夹,选择“属性” $\rightarrow$ “常规” $\rightarrow$ “高级”, 然后选择“加密内容以保证数据安全”复选框即可。

## (4)取消共享目录的 Everyone 组

默认情况下, Windows 2000 新增一个共享目录时, 操作系统会自动将 Everyone 用户组添加到权限模块中。由于 Everyone 组的默认权限是完全控制, 结果会使任何用户都可对共享目录进行读写。因此, 在新建共享目录后, 要立即删除 Everyone 组或将该组的权限设置为只读。

## (5)创建紧急修复磁盘

如果一不小心, 使系统被破坏而不能正常启动时, 就要用专用的系统启动盘来启动。为此,一定要记住在Windows 2000 安装后, 要创建一个紧急修复磁盘。可利用 Windows 2000 一个名为 NTBACKUP.EXE 的工具实现创建启动磁盘。运行 NTBACKUP. EXE, 在工具栏中选择“Create an Emergency Repair Disk(创建紧急修复盘)”, 然后在 A 驱动器中插一张空白软盘并单击“确定”按钮, 直到完成后, 再单击“确定”按钮。

## (6) 使用好安全规则

严格管理和使用好 Windows 2000 的安全规则, 如密码规则、账号锁定规则、用户权限分配规则、审核规则以及 IP 安全规则等。对用户进行合理地分组是进行系统安全设计的重要基础, 因此, 对所有用户都应按工作需要进行分组。利用安全规则可以限定用户口令的有效期、口令长度、设置账户锁定功能, 并对用户备份文件、目录、关机、网络访问等各项行为进行有效控制。

## (7) 对系统进行跟踪记录

为了能密切监视黑客的人侵活动, 应该启动 Windows 2000 的日志文件来记录系统的
运行情况。当黑客攻击系统时, 其蛛丝马迹都会被记录在日志文件中。因此, 有许多黑客在攻击系统时, 往往首先通过修改系统的日志文件来隐藏自己的行踪。为此, 必须限制对日志文件的访问,禁止一切权限的用户查看日志文件。当然,系统中内置的日志管理功能不是太强, 可采用专门的日志程序来观察那些可疑的多次连接尝试。另外, 还要保护好具有根权限的用户和密码, 因为黑客一旦知道了具有根权限的用户账号后, 就可以用修改日志文件方法来隐藏其踪迹了。

## 2. 安全性技术

Windows 2000 是在 Windows NT 基础上发展起来的,在安全性、可操作性等方面都做了较大的改进, 又增加了活动目录、分布式文件系统、智能镜像技术、管理咨询和强大的网络通信等新的服务和管理功能, 为广大用户所接受。Windows 2000 系统在 Windows N T 所具有的安全规则和安全措施基础上,增加了一些新的安全措施和技术,同时又改进、增强了一些安全措施和技术。下面介绍 Windows 2000 系统新增加和改进的相关安全措施和技术。

## (1) 活动目录 $(\mathrm{AD})$ 和安全性

活动目录通过使用对象和用户数据的访问控制提供了对用户账号和组信息的安全存储保护。由于活动目录不仅存储用户数据, 还存储访问控制信息, 因此, 登录的用户将同时获得访问系统资源的身份验证和权限。然后当用户试图使用网络服务时, 系统检查由任意访问控制列表为该服务定义的属性。由于活动目录允许管理员创建组用户, 因此管理员可以更有效地管理系统的安全性。比如,通过调节文件属性,管理员可使组中的所有用户读取文件。

## (2)身份验证

身份验证是系统安全性的一个基本方面, 它负责确认欲登录网络域或访问网络资源的用户的身份。Windows 2000 的身份验证赋予用户登录系统和访问网络资源的能力, 允许他对整个网络资源进行单独登记。采用单独登记的方法, 用户可以使用单个密码或智能卡一次性登录到域,然后通过身份验证向域中的所有计算机表明身份。

Windows 2000 的安全系统提供了两种类型的身份验证。一种是交互式登录验证, 它是根据用户的本地计算机或活动目录账户来确认用户的身份; 另一种是网络身份验证, 它是根据用户试图访问的任何网络服务来确认用户的身份。Windows 2000 提供了进行身份验证的三种身份验证机制: Kerberos V5 身份验证、公钥证书身份验证和 NTLM 身份验证。

## (3)基于对象的访问控制

通过用户身份验证, Windows 2000 允许管理员控制用户对网上资源或对象的访问。 Windows 2000 通过管理员为存储在活动目录中的对象分配安全描述符实现访问控制。安全描述符列出了允许访问对象的用户或组, 以及分配给这些用户或组的特殊权限。安全描述符还指定了需要为对象审核的不同访问事件, 比如文件、打印机和服务都是具体的对象。通过管理对象的属性,管理员可以设置权限,分配所有权以及监视用户访问。

管理员不仅可以控制对特殊对象的访问，也可以控制对该对象特定属性的访问。比如，通过适当配置对象的安全描述符,可以允许用户访问一部分特定信息而非全部信息。

## (4) 数据安全性技术

在用户登录网络时,系统的数据保护开始。Windows 2000 支持网络数据保护和存储数
据保护两种数据保护方式。

网络数据保护是指对本地网络中的数据和不同网络间传输的数据的安全保护。对于本地网络的数据, 可采用身份验证协议和 IP 安全协议 (IP Security) 加密实现保护; 对于网络间传输的数据, 可以采用 IP 安全协议加密、Windows 2000 路由和远程访问服务 (配置远程访问协议和路由)、代理服务(提供防火墙和代理服务器)等实现保护。

保护存储数据可用 Windows 2000 的文件加密系统 EFS 和数字签名技术来实现。文件加密系统使用公钥加密技术对本地的 NTFS 数据进行加密, 数字签名对软件进行签名以保证它们的合法性。

## 1)认证服务

Windows 2000 提供了完全支持提供者界面 (SSPI), 利用其 API 函数提供完整的认证功能。SSPI 为客户机/服务器双方的身份验证提供了上层应用的 API, 屏蔽了网络安全的实现细节, 减少了为支持多方认证而需要实现协议的代码量。此外, Windows 2000 还使用 Kerberos 认证协议作为认证系统。

## 2)证书服务

Windows NT 中的证书服务器提供了证书请求、发布和管理等基本功能。在 Windows 2000 中更名为证书服务, 它是借助于密码保护的加密数据文件, 其中包含的数据可用于对传输系统进行鉴别。证书服务可以分发、管理和撤消数字证书, 同时也更容易与操作系统的其他部件集成。证书服务可以对数据库进行独立管理。

## 3) 加密功能

Windows 2000 提供了 IP Security 和 EFS (加密文件系统) 服务, 可提供认证、加密、数据完整和数据过滤功能。

- IP Security (因特网安全协议, 简写为 IPSec)。IP Security 是由 IP 安全性工作组 (IETF) 定义的端-端保证数据安全性的协议, 它支持对数据的加密, 同时确保数据的完整性。IP Security 使用验证包头的方法来提供数据源验证。IP Security 不需发送方和接收方知道保密密钥。如果验证数据有效, 接收方就可知道数据来自发送方, 并且在传输中没受到破坏。IP Security 提供最高级别的 VPN 安全协议, 有了 IP Security, 就可以对网络层的每项内容进行加密, 确保网络层的安全通信。
- EFS。Windows 2000 的加密文件系统 EFS 可对本地存储数据的安全保密提供更多的保证。EFS 可对本地计算机上指定的文件或目录进行加密, 未经授权的人就无法读取这些文件。EFS 对保护便携式计算机的数据特别有用, 配置 EFS 的这些计算机上的所有机密信息均可被加密。当对 NTFS 系统卷上的文件或文件夹启用 EFS 时,操作系统会使用公钥和通过 Crypto API 取得对称加密算法来加密文件。通过相应配置, 使得 EFS 在保存文件时自动对其进行加密, 并在用户再次打开文件时解密。除了加密者和具有 EFS 文件恢复能力的管理员外,其他人不能读取这些文件。EFS 使用各不相同的对称密钥对每个文件加密, 然后再使用文件拥有者的公钥对加密密钥进行加密。这样, 文件拥有者是惟一能够解密的人, 因为别人无法知道他的私钥。如果有人想绕过 EFS, 或即使文件被盗窃, 也无法解密。


### 13.5.1 UNIX 系统安全

U NIX 操作系统经历了几次更新换代, 其功能和安全性都日瑧完善, 尽管如此, 人侵者还是可以利用系统的一些漏洞进人系统。

## 1.UNIX 系统的安全基础

文件系统安全是 UNIX 系统中的重要部分。在 UNIX 中, 所有的对象都是文件。 UNIX 中的基本文件类型有正规文件、特殊文件、目录、链接、套接字、字符设备等, 这些文件以一个分层的树型结构进行组织, 以一个称为 “root”的目录为起点, 整个目录就是一个文件系统。UNIX 中的每个用户有一个惟一的用户名和 UID(用户 ID 号), 每个用户属于一个或多个组。基本分组成员在/etc/passwd 中定义,附加的分组成员在/etc/group 中定义。每个文件和目录有三组权限: 一组是文件的拥有者, 一组是文件所属组的成员,一组是其他所有用户。在所有文件中, 值得注意的是文件的 SUID(置文件所有者 ID 号)位和 SGID (置文件所在组 ID 号) 位, 因为一些人侵者常利用这些文件人侵留下后门。当用户执行一个 SUID 文件时, 用户 ID 在程序运行过程中被置为文件拥有者的用户 ID, 如果文件属于 root,则用户就成为超级用户。同样, 当一个用户执行 SGID 文件时, 用户的组被置为文件的组。 UNIX 系统实际上有两种类型的用户 ID: 实际 ID 和有效 ID。实际 ID 是在登录过程中建立的用户 ID, 有效 ID 是用户运行进程时的有效权限。一般情况下, 当一个用户执行一条命令时, 进程继承了用户登录 Shell 的权限, 这时, 实际 ID 和有效 ID 是相同的。当 SUID 位被设置时, 进程则继承了命令所有者的权限, 通过创建一个 SUID 是 root 的 Shell 拷贝, 攻击者可以借此建立后门。因此, 系统管理员应定期查看系统中有哪些 SUID 和 SGID 文件。

U NIX 早期版本的安全性能很差, 仅达到 TCSEC 的 C1 安全级。但后来的新版本引进了受控访问环境的增强特性, 增加了审计特性, 进一步限制用户执行某些系统指令, 审计特性可跟踪所有的“安全事件”和系统管理员的工作。UNIX 系统达到了 C2 安全级。

## 2.UNIX 系统漏洞

(1) RPC 服务缓冲区溢出

远程过程调用 (RPC) 是 SUN 公司开发的用来在远程主机上执行特定任务的一种协议。RPC 允许一台计算机上的程序执行远程另一台计算机上的程序。它被广泛用来提供网络远程服务, 如 NFS 文件共享等。但由于代码实现的问题, RPC 的几个服务进程很容易遭到远程缓冲区溢出的攻击。因为 RPG 不能进行必要的错误检查, 所以缓冲区溢出允许攻击者发送程序不支持的数据, 使这些数据被继续传送和处理。

采取安装补丁程序、从 Internet 直接访问的计算机上关闭或删除 RPC 服务、关闭 RPC “oopback”端口、关闭路由器或防火墙中的 RPC 端口等措施可避免对该漏洞的攻击。

(2)Sendmail 漏洞

Sendmail 是 UNIX 上用得最多的发送、接收和转发电子邮件的程序。Sendmail 在 Internet上的广泛应用使其成为攻击者的主要目标, 攻击者可利用 Sendmail 存在的缺陷进
行攻击。最常见的攻击是攻击者发送一封特别的邮件消息给运行 Sendmail 的计算机， Sendmail会根据该消息要求被攻击的计算机将其口令文件发送给攻击者, 这样, 口令就会被暴露。

采取更新 Sendmail 为最新版本、及时下载或更新补丁程序、非邮件服务器或代理服务器不要在 daemon 模式下运行 Send mail 等措施防范 Sendmail 攻击。

(3) BIND 的脆弱性

BIND 是域名服务 DNS 中用得最多的软件包。它存在一定的缺陷, 攻击者可利用 BIND 缺陷攻击 DNS 服务器: 删除系统日志, 安装软件工具以获得管理员权限, 编辑安装 IRC 工具和网络扫描工具,扫描网络以寻找更多的易受攻击的 BIND。

采取在所有非 DNS 服务器的计算机上, 取消 BIND 的 “named”; 在 DNS 服务器的计算机上将 DNS 软件升级到最新版本或补丁版本; 选择部分补丁程序, 以非特权用户身份运行 BIND,以防远程控制攻击等措施可防范 BIND 攻击。

## (4) “ $R$ ”命令缺陷

UNIX 系统提供了 “ $R$ ” 系列命令 (rsh、rcp、rlogin 和 remd) 和相应的 “R”服务功能。 U NIX 管理员经常使用“ $R$ ”服务的信任关系和 “ $R$ ”命令, 从一个系统方便地切换到另一个系统。“ $\mathrm{R}$ ”命令允许个人登录远程计算机而不必提供口令, 远程计算机不询问用户名和口令认可来自可信赖 IP 地址的任何人。如果攻击者获得了可信赖网络中的任何一台计算机，就能登录到任何信任该 IP 的计算机。

采取不允许以 IP 为基础的信任关系、不使用“ $\mathrm{R}$ ”命令和更安全的认证方式等措施可防范“ $\mathrm{R}$ ”命令的缺陷。

(5) Sadmind 和Mountd

Sadmind 允许远程登录到 UNIX 系统进行管理, 并提供一个系统管理功能的图形用户接口。Mountd 控制和判断安装在主机上的 NFS 连接。由于软件开发人员的失误, 导致这些应用缓冲区溢出, 攻击者可以利用这些漏洞进行攻击, 以获取 root 的存取权限。

采取在可能情况下在直接与 Internet 连接的计算机上关闭或删除 Sadmind 和 Mountd、安装最新补丁程序等措施来防范 Sadmind 和 Mountd 漏洞。

## 3.UNIX 的主机安全性

UNIX 系统主机的安全是信息网络安全的一个重要方面, 黑客往往通过控制网络中系统主机来人侵信息系统和窃取数据信息,或通过已控制的系统主机来扩大已有的破坏行为。为 UNIX 操作系统安全规定较详细的安全性原则, 可从技术层面指导用户对主机系统进行安全设置和管理,从而使信息系统的安全性达到一个更高的层次。

UNIX 系统安全性措施包括用户与口令安全、文件系统安全和系统配置安全等。

(1) 用户与口令安全性

- 设置/etc/passwd 文件权限为 400 , 且所有者为 root。因为/etc/passwd 文件中存放着系统的账号信息, 只有 root 可以写。如果其他用户可写, 就有可能出现设置后门、提升权限、增删用户等问题。
- 设置用户密码。空密码用户的存在将增加服务器被人侵的可能性, 因此要为每个用户设置密码。密码要有一定的长度, 要大小写字母、数字和符号相间, 增加密码的复杂性, 减少密码被猜中的可能性; 重要情况下, 用户密码应定期更改, 减少密码意外泄漏带来的风险。
- 设置账号锁定功能。攻击者可能会使用一些软件工具通过重复登录来穷举密码, 锁定账号可以使这种穷举密码攻击失效。
- 封闭不常用的账号。bin、sys、daemon、adm、lp、tftp、nobody 等账号一般用不到, 但有可能被攻击者利用,因此,可将这些不用的账号删除。
- 启用审计功能。审计功能可为管理员提供用户登录、监视用户操作及使用网络资源等情况,因此,可使管理员很清楚服务器的使用现状。

(2) 文件系统安全性

- 设置内核文件的所有者为 root, 且组和其他用户对内核文件不可写,防止其他用户修改内核文件。

禁止普通用户运行 crontab,并确保/usr/lib/crontab 和该表中列出的任何程序对任何人不可写。明确 crontab 运行的脚本中的路径和不安全的命令, 因为 crontab 经常会被一些攻击者设置后门,所以要弄清楚 crontab 中的脚本用途。

- . netrc 文件中不能包含密码信息。ftp 命令在执行时会去寻找一个后缀各为. netrc 的文件,如果此文件存在并且其中有 ftp 命令行中指定的主机名,则会执行. netrc 文件中的命令行。netrc 文件中存放有远程主机名、注册用户名、用户密码和定义的宏, 因此要为其设置权限 0600 ,并注意不包含密码信息。
- 对一些开机启动的文件设置正确的权限, 因为这些文件很容易被放置木马。
- 文件/etc/inetd.conf 和/var/adm/inetd. sec 的访问权限设置为 0600 , 并且所有者为 root。这样可以使这些服务配置文件不能被 root 以外的用户读或修改。
- 文件/etc/services 设置成组和其他用户不可读。

・把所有人可以写和执行的文件重新设置权限,把无用户文件重新设置为用户权限。

(3) 系统配置安全性

- 禁止 root 远程登录 Telnet 和 FTP。Telnet 和 FTP 使用明文方式传输用户名和密码, 很容易被窃听。因此,禁止 root 远程登录 Telnet 和 FTP, 可减少 root 密码被窃取的可能。
- 禁止匿名FTP。匿名FTP 不需要账号密码就可执行 FTP 操作。因此, 匿名 FTP 中可能会被人放置一些攻击文件和木马,也可能窃取一些系统资料。
- 在非邮件服务器上禁止运行 Sendmail。Sendmail 存在较多的安全漏洞, 且它是以 root 用户权限运行的,如果发生缓冲区溢出, 就会被攻击者获得 root 权限。
- sn mp 密码不要设置为缺省的 public 和 private。因为使用缺省密码可以使攻击者得到很多关于系统的信息,甚至可以控制系统,所以尽量将 snmp 密码改掉。
- 没必要时不运行 NFS server。NFS 提供不同机器间文件的共享, 大部分系统的 NFS 服务缺省下设定文件共享是可读写的, 而且对访问的机器没有限制, 所以很容易泄漏和被删改。
- 不要以 root 身份运行 apache 服务器。apache 是著名的 Web 服务软件, 早期的版本漏洞很多, 因此, 没有必要时就不要运行它。新版 apache 支持普通用户运行, 对攻击者有较好的防护功能。
- 关闭潜在的危险服务。Echo、chargen、rpc、finger 等服务并没有很重要的用途, 但对攻击者, 它们可以提供系统信息, 或可对它们进行各种溢出攻击, 有的可能直接获取 root 权
限。因此,在不必要时关闭这些服务。
- 禁止非路由器设备转发数据包。这样, 可防止黑客使用 DoS(拒绝服务)来攻击,也可避免黑客利用该设备去 DoS 攻击其他服务器。
- 为系统打最新补丁。系统管理员要随时浏览安全网站信息, 下载最新补丁程序来弥补各种系统漏洞。


### 13.5.2 Linux 系统安全

Linux 是一种类似 UNIX 操作系统的自由软件, 是一种与 UNIX 系统兼容的新型网络操作系统。Linux 的安全达到了 TCSEC 的 C2 安全级, 更高级别的 Linux 还在开发中。 Linux 的一些安全机制(措施)已被标准所接纳,这些安全机制(措施)是:

## 1. 身份验证机制

在 Linux 中, 用户的身份验证和用户权限是分开设计的, 这样, 用户的身份验证就比较简单。Linux 身份验证系统最基本的实现是 Linux login 程序, 不过其他各应用程序也一样要通过身份验证来确定用户身份。

Linux 采用的最基本的验证体系有/password/shadow 体系和 PAM 体系。

- Shadow 身份验证体系是最简单也是最基本的, 就是利用口令进行身份验证。系统将用户输人的口令与系统预设的口令相比较, 若一致, 用户即可进人系统。
- PAM 是安全验证模块体系, 只有在编程时选择了 PAM 库支持, 才能使用 PAM 验证。在这种情况下, 程序调用 PAM 运行库, 运行库则根据当前的 PAM 系统管理设定来进行具体的验证过程, 使得整个验证过程可以添加或删除特定的功能, 从系统核心中分离出来。PAM 验证体系是由一组模块组成的, 可以在一个 PAM 验证过程中使用多种验证模块, 后面的验证过程的执行依赖于前面的验证结果。PAM 验证体系的功能有加密口令, 用户使用资源控制, 限制用户人网的时间、地点, 允许随意 shadow 口令, 支持 $\mathrm{C} / \mathrm{S}$ 中的机器认证等。


## 2. 用户权限体系

Linux 的用户权限体系包括用户权限、超级用户权限和 SUID 机制。

- 用户权限。Linux 使用标准的 UNIX 文件权限体系, 来实现 Linux 的基本用户隔离和存取授权功能。Linux 系统每个文件都有一个属主用户 user 和一个属主程序组 group,除此之外的用户都作为其他用户 other。这样, 每个文件存在三种存取权限: 用户访问权限、组访问权限和其他用户的访问权限。
- 超级用户权限。超级用户 root 作为系统管理者, 其权限很大, 可以访问任何文件并对其进行读写操作。通常说的人侵 Linux 系统, 最主要就是获得 root 权限。比如, 知道 root 密码或获取一个具有 root 权限的 shell。
- SUID 机制。SUID 机制就是在权限组中增加 SUID 和 SGID 位。凡是 SUID 位被置 “ 1 ”的文件, 当它被执行时, 会自动获得文件属组的 UID; 同样, SGID 位被置位时, 也能自动获得文件属组的 GID。不过, 后者实际使用得较少, 主要是 SUID。


## 3. 文件加密机制

加密技术在现代计算机系统中扮演着越来越重要的角色。文件加密机制就是将加密服务引人文件系统, 从而提高计算机系统的安全性。文件加密机制可防止磁盘信息被盗窃、防
止未授权的访问、防止信息的不完整等。

Linux 已有多种加密文件系统, 如 CFS、TCFS、CRYPTFS 等, 较有代表性的是 TCFS (Transparent Cryptographic File System)。TCFS 通过将加密服务和文件系统的紧密结合, 使用户感觉不到文件的加密过程。TCFS 不修改文件系统的数据结构, 备份、修复以及用户访问保密文件的语义也不变。TCFS 可使保密文件对合法拥有者以外的用户、对用户与远程文件系统通信线路上的偷听者、对文件系统服务器的超级用户都不可读,而对于合法用户,访问保密文件与访问普通文件没什么两样。

## 4. 安全系统日志和审计机制

即使网络采取了多种安全措施,还会存在一些漏洞。攻击者在漏洞修补之前会抓住机会攻击更多的机器。Linux 系统具有安全审计功能, 它可对网络安全进行检测, 利用系统日志记录攻击者的行踪。

日志就是对系统行为的记录, 它可记录用户的登录/退出时间以及用户执行的命令, 系统发生的错误等。日志是 Linux 安全结构中的重要内容, 它能提供攻击发生的惟一真实证据。在检查网络人侵者的时候,日志信息是不可缺少的。在标准的 Linux 系统中,操作系统维护三种基本日志: 连接时间日志、进程记账日志和 Syslog 日志。

- 连接时间日志用来记录用户的登录信息。这是最基本的日志系统,管理员可以利用它来记录哪些用户在什么时间进人系统。
- 进程记账日志用来记录系统执行的进程信息,如某进程消耗了多少 CPU 时间等。
- Syslog 系统日志不由系统内核维护, 而是由 syslogd 或者其他一些相关程序完成。它是各种程序对运行中发生的事件的处理代码。

除以上安全机制外, Linux 还采取了很多具体安全措施, 如提升系统的安全级别 (将系统的安全级别从 C2 级提升到 B1 级或 B2 级)、SSH 安全工具、虚拟专用网(VPN) 等。

## 5. 强制访问控制

强制访问控制 (MAC) 是一种由管理员从全系统角度定义和实施的访问控制。它通过标记系统中的主客体,强制性地限制信息的共享和流动,使不同的用户只能访问与其有关的、指定范围的信息,从根本上防止信息泄漏和访问混乱的现象。

由于 Linux 是一种自由式操作系统, 因此在其系统上实现的强制访问也有多种形式, 比较典型的有 SELinux 和 RSBAC,采用的策略也各不相同。

SELinux 是一种安全体系结构, 在该结构中, 安全性策略的逻辑和通用接口一起封装在操作系统独立的被称为安全服务器的组件中。SELinux 安全服务器定义了一种由类型实施 ( $\mathrm{TE}$ )、基于角色的访问控制 (RBAC) 和多级安全 (MLS) 组成的混合安全策略。通过替换安全服务器, 可以支持不同的安全策略。

$\operatorname{RSBAC}$ (基于规则集的访问控制)是根据一种访问控制通用架构 (GFAC) 模型开发的，它可以基于多个模块提供灵活的访问控制。所有与安全相关的系统调用都扩展了安全实施代码。这些代码调用中央决策部件, 该部件随后调用所有被激活的决策模块, 形成一个综合决定,然后由系统调用扩展来实施该决定。

## 6.Linux 安全工具

网络上有各种各样的攻击工具, 也有各种各样的安全工具。以下介绍的是 Linux 系统中的安全工具。与 Linux 本身类似, 这些安全工具大多也是开放源代码的自由软件, 恰当地
使用它们,可提高系统的安全性。

(1)tcpserver

tcpserver 是一个 inetd 类型的服务程序, 它监听进人连接的请求,为要启动的服务设置各种环境变量, 然后启动指定的服务。tcpserver 可限制同时连接一个服务的数量。当服务忙时,inetd 具有一种连接速率限制机制,可暂时停止服务。

(2) xinetd

xinetd 与 inetd 非常相似,但较之于 inetd 更强大更安全。许多发行的系统版本都带有 xinetd 程序,若提供的服务比较简单且负担较轻,则 xinetd 是一个较合适的选择。

xinetd 具有可支持 TCP、UDP、RPC 服务,基于时间段的访问控制,具有完备的 $\log$ 功能，可有效地防止 DoS 攻击, 可限制同时运行同类服务器数目, 可限制启动的服务数目, 可作为其他系统的代理,可在特定端口绑定某项服务,从而实现只允许私有网络访问该服务等特点。

(3) sudo

sudo 是一个允许系统管理员给予特定的普通用户(或用户组)有限的超级用户特权,使其能够以超级用户或其他用户身份运行命令并记录其所有命令和参数的程序。最基本的原则是在普通用户可以完成工作的范围内, 给予尽可能少的特权。sudo 以命令方式操作, 它不是 shell 的替代品。sudo 可以限制用户在每个主机上运行的命令; 可对每个命令都进行记录,以便清楚地审核谁做了什么; 可为“通行证系统”提供标记日期的文件。

(4) 安全检查工具 nessus

nessus 是一个远程安全扫描器。它是自由软件, 功能强大, 更新快, 易于使用。安全扫描器的功能是对指定的网络进行安全检查和弱点分析, 确定是否有攻击者人侵或是否存在某种方式的误用, 寻找导致对手攻击的安全漏洞。nessus 的安全检查是由 plug-ins 插件完成的,除该插件外, nessus 还提供描述攻击类型的脚本语言(NSSL)来进行附加的安全测试。

(5)监听工具 sniffit

sniffit 是可在 Linux 平台上运行的网络监听软件, 它主要用来监听运行 TCP/IP 协议的计算机, 以发现其不安全性。因为数据包必须经运行 sniffit 的计算机才能进行监听, 所以它只能监听同一个网段上的计算机, 可以为其增加某些插件, 以实现额外功能。可以配置 sniffit 在后台运行, 以检测 TCP/IP 端口上用户的输人/输出信息。用户可以选择源、目的地址或地址集合,还可以选择监听的端口、协议和网络接口等。sniffit 会将监听到的数据包内容存放在当前工作目录下, 可以直接对其进行查看。

(6) 扫描工具 nmap

n map(Network Mapper) 是开放源码的网络探测和安全扫描工具。它主要用来快速扫描大型网络, 但在单机上也能很好地工作。nmap 可以查找到网络上有哪些主机, 它们提供什么服务(端口), 运行什么操作系统, 过滤防火墙使用哪些类型的数据包以及其他许多特征。 nmap 可以在绝大多数计算机上运行, 有命令行和图形界面版本。nmap 具有灵活性好、功能强大、可移植性好、文档支持和技术支持良好、操作容易以及自由性、流行性好等特点。

## 实验题

实验 13.1 Windows 2000 中安全性配置

一、实验目的: 了解 Windows 2000 中安全性的相关配置
二、实验内容:

1.备份系统

2. 设置系统格式为 NTFS

3 . 加密文件或文件夹

4. 取消共享目录的 Everyone 组

5 . 创建紧急修复磁盘

6 . 使用安全规则

7 . 对系统进行跟踪记录

## 习习题

13.1 简述操作系统安全的含义。

13.2 访问控制的含义是什么? 分为哪几种类型?

13.3 Windows 2000 的主要安全措施是什么?

13.4 U NIX 系统中的主要安全措施是什么?

## 实验题参考答案

## 实验 13.1

1.备份系统: “开始” $\rightarrow$ “程序” $\rightarrow$ “附件” $\rightarrow$ “系统工具” $\rightarrow$ “备份”。如图 13-1 所示。

2.设置系统格式为 NTFS。如图 13-2 所示。

3.加密文件或文件夹。如图 13-3、图 13-4 所示。



图 13-2 NTFS 文件系统



图 13-3 文件夹属性



图 13-4 加密和压缩属性

4. 取消共享目录的 Everyone 组。如图 13-5、图 13-6 所示。



图 13-5 共享文件夹



5 .创建紧急修复磁盘

图 13-6 删除 Everyone 组

(略)

6.使用安全规则: “开始” $\rightarrow$ “管理工具” $\rightarrow$ “本地安全设置”。如图 13-7 所示。



图 13-7 本地安全设置

7. 对系统进行跟踪记录: “开始” $\rightarrow$ “管理工具” $\rightarrow$ “事件查看器”。如图 13-8 所示。



图 13-8 事件查看器

## 习题参考答案

13.1 操作系统安全保护的研究,通常包括如下内容:第一,操作系统本身提供的安全功能和安全服务。现代操作系统本身往往要提供一定的访问控制、认证和授权等方面的安全服务。如何对操作系统本身的安全性能进行研究和开发, 使之符合特定的环境和需求, 是操作系统安全保护的一个方面; 第二, 针对各种常用的操作系统,进行相关配置, 使之能正确对付和防御各种人侵; 第三, 保证网络操作系统本身所提供的网络服务能得到安全配置。

13.2 访问控制具体包括两方面涵义,一是指对用户进人系统的控制, 最简单最常用的方法是用户账户和口令限制, 其次还有一些身份验证措施; 二是用户进人系统后对其所能访问的资源进行的限制,最常用的方法是访问权限和资源属性限制。

访问控制可分为自主访问控制和强制访问控制两大类。

自主访问控制,是指由系统提供用户有权对自身所创建的访问对象(文件、数据表等)进行访问, 并可将这些对象的访问权授予其他用户或从授予权限的用户处收回其访问权限。自主访问控制允许用户自行定义其所创建的数据, 它以一个访问矩阵来表示包括读、写、执行、附加以及控制等访问模式。

强制访问控制, 是指由系统 (通过专门设置的系统管理)对用户所创建的对象进行统一的强制性控制, 按照规定的规则决定哪些用户可以对哪些对象进行何种操作系统类型的访问,即使是创建者用户,在创建一个对象后,也可能无权访问该对象。

13.3 安全性措施: (1) 及时备份系统; (2) 设置系统格式为 NTFS; (3) 加密文件或文件夹; (4) 取消共享目录的 Everyone 组; (5) 创建紧急修复磁盘; (6) 使用好安全规则; (7)对系统进行跟踪记录。

13.4 U NIX 系统安全性措施包括用户与口令安全、文件系统安全和系统配置安全等。

## 第

## 计算机信息系统安全评价标准



美国可信计算机系统评价标准。本章介绍了计算机信息系统安全评价标准,要求掌握美国可信计算机系统评价标准中对计算机系统的安全划分的七个级别,三个大类。

## 本章重点与难点



计算机信息系统安全产品种类繁多,功能也各不相同,典型的信息安全评价标准主要有美国国防部颁布的《可信计算机系统评价标准》; 欧洲德国、法国、英国、荷兰四国联合颁布的《信息技术安全评价标准》; 加拿大颁布的《可信计算机产品评价标准》; 美国、加拿大、德国、法国、英国、荷兰六国联合颁布的《信息技术安全评价通用标准》; 中国国家质量技术监督局颁布的《计算机信息系统安全保护等级划分准则》。

由于美国最早制订了计算机安全的评价标准, 目前国际上通用的计算机安全评价标准都基本上参照了美国的《可信计算机系统评价标准》,下面就简要介绍这一评价标准,按照美国可信计算机系统评价标准,计算机系统的安全被分为了以下七个级别:

(1) D 级

$\mathrm{D}$ 级是最低的安全级别, 拥有这个级别的操作系统就像一个门户大开的房子, 任何人可以自由进出, 是完全不可信的。

(2) C1 级

C 级有两个安全子级别: $\mathrm{C} 1$ 和 C2。C1 级, 又称选择性安全保护 (Discretionary Security Protection) 系统, 它描述了一种典型的用在 UNIX 系统上的安全级别。这种级别的系统对硬件有某种程度的保护: 用户拥有注册账号和口令, 系统通过账号和口令来识别用户是否合法, 并决定用户对程序和信息拥有什么样的访问权, 但硬件受到损害的可能性仍然存在。

(3) $\mathrm{C} 2$ 级

除了 C1 级包含的特性外, C2 级别应具有访问控制环境 (Controlled-access Environment) 权力。该环境具有进一步限制用户执行某些命令或访问某些文件的权限,而且还加人了身份认证级别。

## (4) B1 级

B 级中有三个级别, B1 级即标志安全保护级别 (Labeled Security Protection), 是支持多级安全 (例如秘密和绝密) 的第一个级别, 这个级别说明处于强制性访问控制之下的对象,系统不允许文件的拥有者改变其许可权限。

(5) B2 级

B2 级, 又叫做结构保护级别 (Structured Protection), 它要求计算机系统中所有的对象都要加上标签, 而且给设备 (磁盘、磁带和终端) 分配单个或多个安全级别。它是提供较高安全级别的对象与较低安全级别的对象相通信的第一个级别。

(6) B3 级

B3 级或又称安全域级别 (Security Domain),使用安装硬件的方式来加强域的安全,例如,内存管理硬件用于保护安全域免遭无授权访问或其他安全域对象的修改。

## (7) $\mathrm{A}$ 级

A 级或又称验证设计级别 (Verity Design), 是当前橙皮书的最高级别, 它包括了一个严格的设计、控制和验证过程。与前面所提到的各级别一样, 该级别包含了较低级别的所有特性。

## 习 题

14.1 简述美国可信计算机系统评价标准中计算机系统安全的七个级别。

## 习题参考答案

14.1

(1) D 级

$\mathrm{D}$ 级是最低的安全级别, 拥有这个级别的操作系统就像一个门户大开的房子, 任何人可以自由进出, 是完全不可信的。

(2) C1 级

C 级有两个安全子级别: $\mathrm{Cl}$ 和 C2。C1 级, 又称选择性安全保护(Discretionary Security Protection) 系统, 它描述了一种典型的用在 UNIX 系统上的安全级别。这种级别的系统对硬件有某种程度的保护: 用户拥有注册账号和口令, 系统通过账号和口令来识别用户是否合法,并决定用户对程序和信息拥有什么样的访问权,但硬件受到损害的可能性仍然存在。

(3) $\mathrm{C} 2$ 级

除了 C1 级包含的特性外, C2 级别应具有访问控制环境 (Controlled-access Environment) 权力。该环境具有进一步限制用户执行某些命令或访问某些文件的权限, 而且还加人了身份认证级别。

(4) B1 级

B 级中有三个级别, B1 级即标志安全保护 (Labeled Security Protection) 级别, 是支持多级安全 (例如秘密和绝密) 的第一个级别, 这个级别说明处于强制性访问控制之下的对象,系统不允许文件的拥有者改变其许可权限。

(5) B2 级

B2 级, 又叫做结构保护 (Structured Protection) 级别, 它要求计算机系统中所有的对象
都要加上标签, 而且给设备 (磁盘、磁带和终端) 分配单个或多个安全级别。它是提供较高安全级别的对象与较低安全级别的对象相通信的第一个级别。

(6) B3 级

B3 级或又称安全域级别 (Security Domain), 使用安装硬件的方式来加强域的安全, 例如,内存管理硬件用于保护安全域免遭无授权访问或其他安全域对象的修改。

(7) A 级

A 级或又称验证设计 (Verity Design)是当前橙皮书的最高级别, 它包括了一个严格的设计、控制和验证过程。与前面所提到的各级别一样, 该级别包含了较低级别的所有特性。

## 参考文献

[1] 幸川毅.计算机网络安全技术.北京:机械工业出版社, 2005

［2]张基温.信息安全实验与实践教程.北京: 清华大学出版社,2005

[3] 叶忠杰.计算机网络安全技术.北京:科学出版社,2003

[4] 林海等.计算机网络安全.北京: 高等教育出版社, 2002

［5] 焦树海等.计算机安全概论.南京:南开大学出版社, 2001

[6] 刘荫铭,李金海等.计算机安全技术.北京:清华大学出版社, 2000

「7] 王凤英,程震.网络与信息安全.北京: 中国铁道出版社, 2006

［8]石淑华,迟瑞楠.计算机网络安全技术.北京: 人民邮电出版社, 2005

[9] 刘远生.计算机网络安全.北京:清华大学出版社,2006

[10] 胡铮.网络与信息安全.北京:清华大学出版社, 2006

[11] 石志国, 薛为民, 江例等.计算机网络安全教程.北京: 清华大学出版社, 2006

[12]陶智华.计算机网络习题集与习题解析.北京: 清华大学出版社, 2006

[13] 戴琼海,覃毅力, 张莹,陈峰.组播安全性研究和实现.计算机工程与应用, 2002

[14] 朱文涛,熊继平, 李津生,洪佩琳. 安全组播中密钥分配问题的研究. 软件学报, 2003,14(12):2052-2059.

［15] 朱文涛,熊继平,李津生,洪佩琳. 安全组播密钥管理的层次结构研究. 电子与信息学报,2004(1)

「16〕龚俭.计算机网络安全导论.北京:东南大学出版社, 2004

[17] 刘远生,辛一,薛庆水. 计算机网络安全.北京: 清华大学出版社, 2006

［18］胡向东等.应用密码学教程.北京:电子工业出版社, 2005

［19] 段云所等.信息安全概论.北京:高等教育出版社, 2003

［20］李俊宇.信息安全技术基础.北京:冶金工业出版社,2004

[21]蒋建春.计算机网络信息安全理论与实践教程.西安:西安电子科技大学出版社, 2005

[22]曹天杰.计算机系统安全.北京:高等教育出版社, 2003

［23]阎慧.防火墙原理与技术.北京: 机械工业出版社, 2006

[24] Koblas, D., “SOCKS”, Proceedings: 1992 Usenix Security Symposium.

[25]杨诚.网络安全基础教程与实训.北京:北京大学出版社

［26］鲁士文.计算机网络协议和实现技术.北京:清华大学出版社

[27]冯登国.计算机通信网络安全.北京: 清华大学出版社

[28] 韩䈶卿.计算机病毒分析与防范大全.北京: 电子工业出版社

［29]将建国,杨凡,文伟平,郑生琳.计算机网络信息安全理论与实践教程.陕西:西安电子科技大学出版社, 2005

「30〕银石动力.实战网路安全.北京: 北京邮电大学出版社, 2005

［31］李成大,张京,龚莩茗.计算机信息安全.北京: 人民邮电出版社, 2005

[32] http://www.51kaifa.com

[33] http://www.pconline.com.cn

[34] Kent S, Athinson R.Security architecture for the internet protocol. RFC 2401, 1998(11)

[35] Harkins R, Carrell D. The internet key exchange.RFC2409.1998(11)

［36］崔健双,李铁克.IPSec 安全机制浅析.信息网络安全.2002(11)

[37]敦亚南,王振兴,郭润.浅析 IPSec 安全机制.微计算机信息.2005(30)

[38] http://www.ccidnet.com

［39］陈一飞.Internet 的保密增强邮件 PEM.计算机世界报,1995(10)

