# Partition-Insensitive Parallel Admm Algorithm For High-Dimensional Linear Models

Xiaofei Wu College of Mathematics and Statistics, Chongqing University, Jiancheng Jiang Department of Mathematics and Statistics, University of North Carolina at Charlotte, and Zhimin Zhang ∗
College of Mathematics and Statistics, Chongqing University.

April 11, 2024

## Abstract

The parallel alternating direction method of multipliers (ADMM) algorithms have gained popularity in statistics and machine learning due to their efficient handling of large sample data problems. However, the parallel structure of these algorithms, based on the consensus problem, can lead to an excessive number of auxiliary variables when applied to highdimensional data, resulting in large computational burden. In this paper, we propose a partition-insensitive parallel framework based on the linearized ADMM (LADMM) algorithm and apply it to solve nonconvex penalized high-dimensional regression problems. Compared to existing parallel ADMM algorithms, our algorithm does not rely on the consensus problem, resulting in a significant reduction in the number of variables that need to be updated at each iteration. It is worth noting that the solution of our algorithm remains largely unchanged regardless of how the total sample is divided, which is known as partition-insensitivity. Furthermore, under some mild assumptions, we prove the convergence of the iterative sequence generated by our parallel algorithm. Numerical experiments on synthetic and real datasets demonstrate the feasibility and validity of the proposed algorithm. We provide a publicly available R software package to facilitate the implementation of the proposed algorithm.

Keywords: Global convergence; Nonconvex optimization; Parallel algorithm; Robust regression; LADMM

## 1 Introduction

High-dimensional linear regression models can be written as the form of " loss + penalty ",

$$\operatorname*{arg\,min}_{\boldsymbol{\beta}\in\mathbb{R}^{p}}\quad\sum_{i=1}^{n}{\mathcal{L}}(y_{i}-{\boldsymbol{x}}_{i}^{\top}{\boldsymbol{\beta}})+P_{\lambda}(|{\boldsymbol{\beta}}|),$$
$$(1)$$

i β) + Pλ(|β|), (1)
where xi ∈ R
p and yi ∈ R denote the i-th observation values of the covariates and the response, respectively. The loss function L : R → R
+ is a versatile function that encompasses various forms, such as least squares, asymmetric least squares (Newey and Powell (1987)), Huber loss (Huber (1964)), quantile loss (Koenker and Basset (1978)), and smooth quantile loss (Jennings et al.

(1993) and Aravkin et al. (2014)). Pλ(|β|) represents various nonconvex penalty terms including SCAD (Fan and Li (2001)), MCP (Zhang (2010a)), Capped-ℓ1 (Zhang (2010b)), Snet (Wang et al.

(2010)), Mnet (Huang et al. (2016)), among others.

Over the past decade, many parallel ADMM algorithms have been proposed to solve (1) when dealing with particularly large samples (n is large) and/or distributed data storage. Examples include Boyd et al. (2010), Yu and Lin (2017), Yu et al. (2017), and Fan et al. (2021). The parallel algorithm is based on the principle of decomposing a complex optimization problem into smaller and more manageable subproblems that can be solved independently and simultaneously on local machines. Assuming there are M local machines available, the data y = (y1, y2*, . . . , y*n)
⊤ and X = (x1, x2*, . . . ,* xn)
⊤ can be divided into M blocks as,

$$\mathbf{y}=(\mathbf{y}_{1}^{\top},\mathbf{y}_{2}^{\top},\ldots,\mathbf{y}_{M}^{\top})^{\top},\ \mathbf{X}=(\mathbf{X}_{1}^{\top},\mathbf{X}_{2}^{\top},\ldots,\mathbf{X}_{M}^{\top})^{\top}.\tag{2}$$

Here, ym ∈ R
nm, Xm ∈ R
nm×p, and PM
m=1 nm = n. In order to adapt to this parallel structure, the existing parallel ADMM algorithms employ strategies similar to the regularized consensus problem described by Boyd et al. (2010). The regularized consensus problem is a method in machine learning and optimization for solving consensus problems in a distributed environment. It aims to achieve cooperation among distributed machines by running local optimization algorithms with regularization terms to promote model consistency and consensus.

By introducing {rm = ym − Xmβm}
M
m=1 and the consensus constraints {β = βm}
M
m=1, the

$$\min_{\mathbf{\beta},\{\mathbf{r}_{m}\mathbf{\beta}_{m}\}_{m=1}^{M}}\quad\sum_{m=1}^{M}\mathcal{L}(\mathbf{r}_{m})+P_{\lambda}(|\mathbf{\beta}|),$$  s.t. $\mathbf{X}_{m}\mathbf{\beta}_{m}+\mathbf{r}_{m}=\mathbf{y}_{m},\ \mathbf{\beta}=\mathbf{\beta}_{m},\ m=1,2,\ldots,M,$ (3)
where rm = (rm,1, rm,2, . . . , rm,nm)
⊤ and L(rm) = Pnm l=1 L(rm,l). To solve the constrained optimization problem in (3), both the central and local machines must handle subproblems of the same dimension as β (which is p dimensions) in each iteration. However, in the case of penalized regression, it is common for β to have a relatively large dimension. As r = (r
⊤
1
, r
⊤
2
, . . . , r
⊤
m)
⊤ and each local machine needs to solve its corresponding βm, solving parallel problems results in solving at least Mp subproblems more than the nonparallel case.

Although this phenomenon can be mitigated through parallel computing structures, where M
local machines compute Mp subproblems in an equivalent time to a single machine computing p subproblems, the presence of these additional auxiliary variables {βm}
M
m=1 can negatively impact the convergence speed and accuracy of the algorithm. This drawback has also been emphasized by Lin et al. (2022), which suggested avoiding excessive auxiliary variables when designing the ADMM algorithm. Moreover, it is important to note that {βm}
M
m=1 is not the desired estimation value we initially aim for, but rather auxiliary variables added to avoid the need for double loops and facilitate a parallel structure. More details can be found in Yu et al. (2017). Hence, a natural question arises: Is it possible to design an ADMM algorithm without introducing these auxiliary variables, while also maintaining a parallel structure and avoiding double loops?

This paper proposes a new parallel strategy based on the LADMM to address the above problem.

Compared to existing related algorithms, the proposed algorithm offers three main advantages:
- Not an approximation algorithm: Our algorithm directly tackles nonnonvex optimization problems without relying on methods like local linear approximation (LLA) in Zou and Li (2008), majorization minimization step in Yu et al. (2017), or iterative reweighting in Pan et al. (2021). For smooth quantile losses, our algorithm directly derives its proximal operator, rather than using first-order approximation methods in Mkhadri et al. (2017). Additionally, we prove that our algorithm converges globally to a critical point of the nonconvex optimization problem.

- Fewer iterative variables: Compared to existing parallel ADMM algorithms, our parallel LADMM algorithm requires fewer iterative variables. Existing algorithms typically handle subproblems with dimensions of at least (2M + 1)p + 2n, while our algorithm only requires p + 2n. This reduction in the number of variables is especially significant when p and/or M
are large.

- Partition-Insensitive: As stated by Fan et al. (2021), when more local machines are employed, the parallel algorithms proposed by Yu et al. (2017) and Fan et al. (2021) tend to select more non-zero variables. In contrast, our algorithm ensures that the solution remains largely consistent across different numbers of local machines and the number of samples they process. This consistency guarantees the reliability and accuracy of the solutions, regardless of the chosen parallelization strategy.

To ensure the proposed algorithm's wide applicability, we opt for a highly flexible smooth quantile loss, denoted as L in (1), and employ general nonconvex penalties such as Snet and Mnet for Pλ(|β|) in (1). The remainder of this paper is organized as follows. In Section 2, we introduce two smooth quantile loss functions and some nonconvex penalties, and derives the closed-form solutions of their proximal operators. In Section 3, we propose the LADMM algorithm for solving nonconvex penalized regression problems and derive its parallel version. Besides, we explained the equivalence relationship between parallel and nonparallel algorithms and provide the convergence of the algorithms in this section. In Section 4, we present the performance of the proposed algorithm on some synthetic datasets, and compare it with existing methods. In Section 5, we utilize the new parallel algorithm to conduct regressions on an online publicly available dataset, leading to the discovery of several new findings. In Section 6, we summarize the findings and concludes the paper with a discussion of future research directions. The technical proofs and supplementary numerical experimentsis are included in the Appendix. R package PIPADMM for implementing the partition-insensitive parallel LADMM is available at https://github.com/xfwu1016/PIPADMM.

## 2 Preliminary

In this section, we introduce two smooth quantile loss functions and several nonconvex penalties, and combine them to create the generalized nonconvex penalized regression models. To facilitate the description of the algorithm, we provide closed-form solutions for the proximal operators of both the smooth quantile functions and nonconvex penalties.

## 2.1 Smooth Quantile Losses

The quantile loss function, proposed by Koenker and Basset (1978), is defined as

$$\rho_{\tau}(u)=u(\tau-1_{u<0})$$

where τ ∈ (0, 1) and 1u<0 is an indicator function, which is equal to 1 if u < 0, and 0 otherwise.

This loss function has been widely studied in linear regression because it can go beyond the typical Gaussian assumptions and effectively resolve heavy-tailed random error distributions. However, the traditional quantile loss function may not be suitable for scenarios with noise and outliers, as it aims for precise fitting of a specific section of the data. Studies conducted by Aravkin et al. (2014)
and Mkhadri et al. (2017) have shown the limitations of the traditional quantile loss function and suggested using the smooth quantile loss as a better alternative.

The two popular smooth quantile losses proposed by Jennings et al. (1993) and Aravkin et al.

(2014) are respectively defined as

$$\mathcal{L}_{\tau,c}(u)=\left\{\begin{array}{l}{{\tau(u-0.5c)}}\\ {{}}\\ {{\frac{\tau u^{2}}{2c}}}\\ {{}}\\ {{\frac{(1-\tau)u^{2}}{2c}}}\\ {{}}\\ {{(\tau-1)(u+0.5c)}}\end{array}\right.$$
τ (u − 0.5c) if u ≥ c,
2cif u ∈ [0, c),
2cif u ∈ [−c, 0),
(τ − 1)(u + 0.5c) if u < −c,
if $u\geq c$,  if $u\in[0,c)$,  if $u\in[-c,0)$,  if $u<-c$,
and

$$\mathcal{L}_{\tau,\kappa}(u)=\left\{\begin{array}{ll}\tau(u-\frac{\tau\kappa}{2})&\mbox{if$u>\tau\kappa$,}\\ \frac{u^{2}}{2\kappa}&\mbox{if$u\in[(\tau-1)\kappa,\tau\kappa]$,}\\ (\tau-1)[u-\frac{(\tau-1)\kappa}{2}]&\mbox{if$u<(\tau-1)\kappa$,}\end{array}\right.\tag{5}$$

where τ ∈ (0, 1), c > 0 and κ > 0 are three given constants. The smooth quantile loss is termed as a generalized loss because Lτ,c(u) and/or Lτ,κ(u) can closely resemble the quantile loss, least squares loss, asymmetric least squares loss, and Huber loss by adjusting τ , c and κ. Obviously, these two smooth quantile losses are the modified versions of the quantile loss function that incorporates smooth functions to replace the non-differentiable portion near the origin. This modification allows for differentiability at the origin, making it easier to analyze theoretically and design algorithms.

One manifestation is that Lτ,∗(u) (∗ represents c or κ) has a Lipschitz continuous first derivative, while quantile loss does not.

Because of these advantages and flexibility, the smooth quantile losses are widely used in various fields, such as nonparametric regression (Oh et al. (2011)), functional data clustering (Kim and Oh (2020)), linear regression (Zheng (2011)), and penalized linear regression (Ouhourane et al.

(2022)). Several algorithms have been proposed to handle smooth quantile regression (with or without penalty terms), including gradient descent (Zheng (2011)), orthogonal matching pursuit (Aravkin et al. (2014)) and coordinate descent (Mkhadri et al. (2017)). It is important to note that the aforementioned algorithms primarily concentrate on convex penalties. Although Mkhadri et al.

(2017) extended the algorithm to nonconvex cases, its theoretical convergence is not guaranteed. To the best of our knowledge, no ADMM algorithm has been introduced specifically for solving regression models with smooth quantile regression. The first use of parallel ADMM algorithm to solve regularized smooth quantile regression is also a contribution of this paper.

## 2.2 Nonconvex Penalized Smooth Quantile Regression Models

Next, we introduce two generalized nonconvex penalties, namely Snet (SCAD + ℓ2) in Wang et al.

(2010), and Mnet (MCP + ℓ2) in Huang et al. (2016), and additionally propose a novel nonconvex penalty, called Cnet (Capped-ℓ1 + ℓ2). Capped-ℓ1 is a nonconvex regularization proposed by Zhang
(2010b) and has garnered attention in Guan et al. (2018) and Pan et al. (2021). It is defined as Cap-L1a,λ1
(β) = λ1Pj min{|βj|, a}. Snet, Mnet and Cnet are defined separately as,

$$\begin{array}{c}{{\mathrm{Snet}(\mathbf{\beta})=\mathrm{SCAD}_{a,\lambda_{1}}(\mathbf{\beta})+\frac{\lambda_{2}}{2}\|\mathbf{\beta}\|_{2}^{2},}}\\ {{\mathrm{Mnet}(\mathbf{\beta})=\mathrm{MCP}_{a,\lambda_{1}}(\mathbf{\beta})+\frac{\lambda_{2}}{2}\|\mathbf{\beta}\|_{2}^{2},}}\\ {{\mathrm{Cnet}(\mathbf{\beta})=\mathrm{Cap-L1}_{a,\lambda_{1}}(\mathbf{\beta})+\frac{\lambda_{2}}{2}\|\mathbf{\beta}\|_{2}^{2},}}\end{array}$$

where a is a constant determined by the first regularization term, and its suggested value can be found in papers that proposed these regularization terms.

Combining the smooth quantile loss and the above generalized nonconvex penalty together produces a generalized nonconvex penalized regression model,

$$\arg\min_{\beta\in\mathbb{R}^{p}}\quad\sum_{i=1}^{n}\mathcal{L}_{\tau,*}(y_{i}-\mathbf{x}_{i}^{\top}\mathbf{\beta})+P_{\lambda}(|\mathbf{\beta}|).\tag{6}$$
7
We abbreviate it as NPSQR. NPSQR is a special case of regularized M-estimator, whose statistical properties have been studied in Negahban et al. (2010), Li et al. (2011), Loh and Wainwright
(2015), Loh (2017) and Zhou et al. (2018).

## 2.3 Proximal Operator

In iterative algorithms, the existence of closed-form solutions for the proximal operator has a significant impact on the algorithm efficiency. To facilitate the closed-form solutions for the updates of β and r in the ADMM algorithm, we introduce the following proximal operators,

$$\operatorname{prox}_{\mu,g}(\mathbf{v})=\arg\operatorname*{min}_{\mathbf{u}}\left\{g(\mathbf{u})+{\frac{\mu}{2}}\|\mathbf{u}-\mathbf{v}\|_{2}^{2}\right\},$$
$$\left(7\right)$$

where g(u) is a nonnegative real-valued function, v is a constant vector, and µ > 0 is a constant.

In this paper, the function g(u) is separable or additive, meaning g(u) = Pj g(uj ). Then, we can divide the optimization problem (7) into multiple independent univariate problems. Here, we introduce the closed-form solutions for the proximal operators of the aforementioned losses and penalties, which play a crucial role in our algorithm. The detailed derivation process of these closed-form solutions is provided in Appendix A. We are not aware of any prior work that has derived closed-form solutions for these operators (except for some special cases with Snet in Wang et al. (2010) and Mnet in Huang et al. (2016)), making our contribution novel in this regard. Furthermore, our derivation method is concise and easily extendable, enabling potential applications beyond the scope of this study.

$$\operatorname{prox}_{\mu,{\mathcal{L}}_{\tau,c}}(v_{j})={\left\{\begin{array}{l l}{v_{j}-{\frac{\tau}{\mu}},}\\ {{}}\\ {{\frac{c\mu v_{j}}{c\mu+\tau}},}\\ {{}}\\ {{\frac{c\mu v_{j}}{c\mu+1-\tau}},}\\ {{}}\\ {{v_{j}-{\frac{\tau-1}{\mu}},}}\end{array}\right.}$$
if $v_j\geq c+\frac{\tau}{\mu}$,  if $0\leq v_j<c+\frac{\tau}{\mu}$,  if $\;-c+\frac{\tau-1}{\mu}\leq v_j<0$,  if $v_j<-c+\frac{\tau-1}{\mu}$. 
, if − c +
- The closed-form solution for proximal operator of Lτ,κ(u)

$$\operatorname{prox}_{\mu,\mathcal{L}_{\tau,\kappa}}(v_{j})=\left\{\begin{array}{l}{{v_{j}-\frac{\tau}{\mu},}}\\ {{\frac{\kappa\mu v_{j}}{\kappa\mu+1},}}\\ {{v_{j}-\frac{\tau-1}{\mu},}}\end{array}\right.$$
if $v_{j}\geq\tau\kappa+\frac{\tau}{\mu}$,  if $(\tau-1)\kappa+\frac{\tau-1}{\mu}\leq v_{j}<\tau\kappa+\frac{\tau}{\mu}$,  if $v_{j}<(\tau-1)\kappa+\frac{\tau-1}{\mu}$.  
κµ+1 , if (τ − 1)κ +
Obviously, when c = 0 and κ = 0, the proximal operator of quantile loss in Yu et al. (2017) and Gu et al. (2018) is a special case in (8) or (9).

- The closed-form solution for proximal operator of Snet with (a − 1)(η + λ2) > 1:

$$\operatorname{prox}_{\eta,P_{\lambda}}(v_{j})={\left\{\begin{array}{l l}{\operatorname{sign}(v_{j})\cdot\left[{\frac{\eta|v_{j}|-\lambda_{1}}{\eta+\lambda_{2}}}\right]_{+},}\\ {\operatorname{sign}(v_{j})\cdot\left[{\frac{(a-1)\eta|v_{j}|-a\lambda_{1}}{(a-1)(\eta+\lambda_{2})-1}}\right]_{+},}\\ {\frac{\eta v_{j}}{\eta+\lambda_{2}},}\end{array}\right.}$$
$$\mathrm{if}\ |v_{j}|\leq{\frac{\lambda_{1}(1+\eta+\lambda_{2})}{\eta}},$$  $$\mathrm{if}\ {\frac{\lambda_{1}(1+\eta+\lambda_{2})}{\eta}}<|v_{j}|<{\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta}},\qquad\qquad(10)$$  $$\mathrm{if}\ |v_{j}|\geq{\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta}}.$$
, if |vj| ≥ aλ1(η+λ2)
Obviously, when λ2 = 0 and η = 1, the closed-form solution for proximal operator of SCAD in Fan and Li (2001) is a special case in (10). Besides, when η = 1, the solution in (10) is the same as the closed-form solution mentioned in Wang et al. (2010). Note that (a − 1)(η + λ2) > 1 is also valid in this paper, as a = 3.7 and *η >>* 1.

- The closed-form solution for proximal operator of Mnet:

$$\text{prox}_{\eta,P_{\lambda}}(v_{j})=\left\{\begin{array}{ll}\text{sign}(v_{j})\cdot\left[\frac{a\eta|v_{j}|-a\lambda_{1}}{a(\eta+\lambda_{2})-1}\right]_{+},&\text{if}\left|v_{j}\right|<\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta},\\ \frac{\eta v_{j}}{\eta+\lambda_{2}},&\text{if}\left|v_{j}\right|\geq\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta}.\end{array}\right.\tag{11}$$

Obviously, when λ2 = 0 and η = 1, the proximal operator of MCP in Zhang (2010a) is a special case in (11). In addition, when η = 1, the solution in (11) is the same as the solution mentioned in Huang et al. (2016).

- The closed-form solution for proximal operator of Cnet:

$$\text{prox}_{\eta,P_{\lambda}}(v_{j})=\left\{\begin{array}{ll}\text{sign}(v_{j})\cdot\left[\frac{\eta v_{j}|-\lambda_{1}}{\eta+\lambda_{2}}\right]_{+},&\text{if}|v_{j}|<\frac{a(\eta+\lambda_{2})}{\eta},\\ \frac{\eta v_{j}}{\eta+\lambda_{2}},&\text{if}|v_{j}|\geq\frac{a(\eta+\lambda_{2})}{\eta}.\end{array}\right.\tag{12}$$

In addition to these two smooth quantile losses and three nonconvex combined penalties, our PIPADMM package also offers closed-form solutions for proximal operators of least squares loss and its asymmetric variant, quantile regression loss, Huber loss, and elastic-net regularization (Zou and Hastie (2005)). Naturally, our algorithm (R package) can also be applied to solve these regression problems with elastic-net. Some of these proximal operators have already obtained the closed-form solutions from previous research in Liang et al. (2024) and its cited literature, and the closed-form solutions of all the proximal operators mentioned above can be derived using the similar methods as presented in this paper. As a result, we will not delve into detailed introductions for them.

## 3 The Parallel Ladmm Algorithm

The alternating direction method of multipliers (ADMM) is an algorithm employed to solve problems characterized by a two-block separable objective function with equality constraints. By setting r = y − Xβ, the given NPSQR problems in (6) can be transformed into the following form,

$$\operatorname*{min}_{\beta,r}\quad{\mathcal{L}}_{\tau,*}(\mathbf{r})+P_{\lambda}(|\mathbf{\beta}|),$$

$$\mathrm{s.t.}\quad X\beta+r=y,$$
$$(13)$$

s.t. Xβ + r = y, (13)
where Lτ,∗(r) = Pn i=1 Lτ,∗(ri). To solve NPSQR using ADMM, the augmented Lagrangian of (13)
needs to be formulated as,

$$L_{\mu}(\beta,\mathbf{r},\mathbf{d})={\mathcal{L}}_{\tau,*}(\mathbf{r})+P_{\lambda}(|\mathbf{\beta}|)-\mathbf{d}^{\top}(\mathbf{X}\mathbf{\beta}+\mathbf{r}-\mathbf{y})+{\frac{\mu}{2}}\left\|\mathbf{X}\mathbf{\beta}+\mathbf{r}-\mathbf{y}\right\|_{2}^{2}.$$
. (14)
$$(14)$$

Here, d ∈ R
nrepresents the dual variable, and µ > 0 is a tunable augmentation parameter. The ADMM algorithm alternates between the following iterative steps with given r 0 and d 0,

$$\left\{\begin{array}{ll}\beta^{k+1}&=\arg\min_{\beta}\left\{P_{\lambda}(|\beta|)+\frac{\mu}{2}\left\|\mathbf{X}\beta+\mathbf{r}^{k}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}\right\},\\ \mathbf{r}^{k+1}&=\arg\min_{\mathbf{r}}\left\{\mathcal{L}_{\tau,*}(\mathbf{r})+\frac{\mu}{2}\left\|\mathbf{X}\beta^{k+1}+\mathbf{r}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}\right\},\\ \mathbf{d}^{k+1}&=\mathbf{d}^{k}-\mu(\mathbf{X}\beta^{k+1}+\mathbf{r}^{k+1}-\mathbf{y}).\end{array}\right.\tag{15}$$

Similar iterative schemes have been used by Yu et al. (2017) and Gu et al. (2018) to solve the convex penalized quantile regression. However, the β-update in (15) is a regression problem similar to penalized least squares regression, which does not have a closed-form solution. This update is computationally expensive because it necessitates numerical optimization techniques like the coordinate descent algorithm, leading to a double-loop algorithm. Next, we will introduce the LADMM algorithm to address this challenge.

## 3.1 Ladmm Algorithm

Linearized ADMM (LADMM) algorithms have found wide application in convex sparse statistical learning models, including the Dantzig selector in Wang and Yuan (2012), sparse group and fused Lasso methods in Li et al. (2014), sparse quantile regression in Gu et al. (2018), and sparse support vector machines in Liang et al. (2024). The fundamental idea of the LADMM algorithm involves linearizing the quadratic term using a nontrivial matrix, thereby creating a proximal operator. We solve (13) using LADMM through the following iteration,

$$\begin{array}{ll}\mathbf{\beta}^{k+1}&=\arg\min_{\mathbf{\beta}}\left\{P_{\lambda}(|\mathbf{\beta}|)+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}+\mathbf{r}^{k}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}+\frac{1}{2}\left\|\mathbf{\beta}-\mathbf{\beta}^{k}\right\|_{\mathbf{S}}^{2}\right\},\\ \mathbf{r}^{k+1}&=\arg\min_{\mathbf{r}}\left\{\mathcal{L}_{r,*}(\mathbf{r})+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}\right\},\\ \mathbf{d}^{k+1}&=\mathbf{d}^{k}-\mu(\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k+1}-\mathbf{y}),\end{array}\tag{16}$$

where S = ηIp −µX⊤X andβ − β k 2 S
= (β −β k)
⊤S(β −β k). To ensure the convergence of the algorithm, we need S to be a positive-definite matrix, i.e., η > eigen(µX⊤X), where eigen(µX⊤X)
denotes the maximum eigenvalue of µX⊤X.

## Algorithm 1 Ladmm For Solving Npsqr.

Pre-computation: η = eigen(µX⊤X).

Input: Observation data: X, y; initial primal variables: β 0, r 0; initial dual variables d 0; augmented parameters: µ; penalty parameter: λ1, λ2; selected parameters: τ ∈ (0, 1), c > 0 or κ > 0.

Output: The last iteration solution β K.

  **while** not converged **do**  1. Update $\mathbf{d}^{k+1}=\text{prox}_{\eta,P_{\lambda}}\left(\mathbf{\beta}_{j}^{k}-\frac{\left[\mathbf{\mu}^{\mathbf{X}^{\top}}(\mathbf{X}\mathbf{\beta}^{k+1}\mathbf{r}^{k}-\mathbf{y}^{k}/\mu)\right]_{j}}{\eta}\right),j=1,2,\ldots,p,$ 2. Update $\mathbf{r}_{k}^{k+1}=\text{prox}_{\eta,\mathbf{r}_{k},\epsilon_{\epsilon_{\epsilon}}}\left(\left[\mathbf{y}+\mathbf{d}^{k}/\mu-\mathbf{X}\mathbf{\beta}^{k+1}\right]_{j}\right),i=1,2,\ldots,n,$ 3. Update $\mathbf{d}^{k+1}=\mathbf{d}^{k}-\mu(\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k+1}-\mathbf{y}).$ **end while**  **return** solution
For the β-update, omitting constant terms unrelated to β, the subproblem becomes

$$\beta^{k+1}\ =\operatorname*{arg\,min}_{\beta}\left\{P_{\lambda}(|\beta|)+\frac{\eta}{2}\left\|\beta-\beta^{k}+\frac{\mu X^{\top}(X\beta^{k}+\tau^{k}-y-d^{k}/\mu)}{\eta}\right\|_{2}^{2}\right\}.$$
$$\left(17\right)$$
. (17)
Obviously, both β k+1 and r k+1 can be represented as proximal operators, that is,

$$\begin{cases}\boldsymbol{\beta}^{k+1}=\operatorname*{prox}_{\eta,P_{\lambda}}\left(\boldsymbol{\beta}^{k}-{\frac{\mu\boldsymbol{X}^{\top}(\boldsymbol{X}\boldsymbol{\beta}^{k}+\boldsymbol{r}^{k}-\boldsymbol{y}-\boldsymbol{d}^{k}/\mu)}{\eta}}\right),\\ \boldsymbol{r}^{k+1}=\operatorname*{prox}_{\mu,\mathcal{L}_{\tau,*}}\left(\boldsymbol{y}+\boldsymbol{d}^{k}/\mu-\boldsymbol{X}\boldsymbol{\beta}^{k+1}\right).\end{cases}$$
$$(18)$$

To summarize, the iterative scheme of LADMM for (13) is described in Algorithm 1 .

## 3.2 Parallel Ladmm Algorithm

This subsection delves into the implementation of parallel LADMM algorithms designed for handling large-scale data. The main objective is to address the issue in a distributed manner, with each processor tasked with handling a subset of the training data. This distributed approach offers significant advantages when facing with a high volume of training examples that cannot be practically processed on a single machine, or when the data is inherently distributed or stored in a similar manner.

We divide X and y into M row blocks using the following approach:

$$\mathbf{y}=(\mathbf{y}_{1}^{\top},\mathbf{y}_{2}^{\top},\ldots,\mathbf{y}_{M}^{\top})^{\top},\quad\mathbf{X}=(\mathbf{X}_{1}^{\top},\mathbf{X}_{2}^{\top},\ldots,\mathbf{X}_{M}^{\top})^{\top},$$

where Xm ∈ R
nm×p and ym ∈ R
nm, with PM
m=1 nm = n. Here, Xm and ym denote the m-th block

$$(19)$$

![11_image_0.png](11_image_0.png)

$$(20)$$
$$\mathbf{r}=(\mathbf{r}_{1}^{\top},\mathbf{r}_{2}^{\top},\ldots,\mathbf{r}_{M}^{\top})^{\top},\quad\mathbf{d}=(\mathbf{d}_{1}^{\top},\mathbf{d}_{2}^{\top},\ldots,\mathbf{d}_{M}^{\top})^{\top}.\tag{1}$$

Then, we can rewrite problem (13) into the following equivalent problem:

$$\min_{\mathbf{\beta},\{\mathbf{r}_{m}\}_{m=1}^{M}}\quad\sum_{m=1}^{M}\sum_{l=1}^{n_{m}}\mathcal{L}_{\tau,*}(r_{m,l})+P_{\lambda}(|\mathbf{\beta}|),$$ $$\text{s.t.}\quad\mathbf{X}_{m}\mathbf{\beta}+\mathbf{r}_{m}=\mathbf{y}_{m},\quad m=1,2,\ldots,M,\tag{21}$$

where rm = (rm,1, rm,2, . . . , rm,nm)
⊤. Similar to (14), the augmented Lagrangian for problem (21)
is given by

$$L_{\mu}(\mathbf{\beta},\{\mathbf{r}_{m}\}_{m=1}^{M},\{\mathbf{d}_{m}\}_{m=1}^{M})=\sum_{m=1}^{M}\sum_{l=1}^{m}\mathcal{L}_{\tau,*}(r_{m,l})+P_{\lambda}(|\mathbf{\beta}|)-\sum_{m=1}^{M}\mathbf{d}_{m}^{\top}(\mathbf{X}_{m}\mathbf{\beta}+\mathbf{r}_{m}-\mathbf{y}_{m})\tag{22}$$ $$+\frac{\mu}{2}\sum_{m=1}^{M}\left\|\mathbf{X}_{m}\mathbf{\beta}+\mathbf{r}_{m}-\mathbf{y}_{m}\right\|_{2}^{2},$$

where dm ∈ R
nm is the dual variable. Then, we can solve (21) using parallel LADMM through the

  β k+1 = arg min β nPλ(|β|) + µ 2 PM m=1 Xmβ + r k m − ym − d k m/µ 2 2 + 1 2 β − β k 2 S o, r k+1 m = arg min rm nPnm l=1 Lτ,∗(rm,l) + µ 2 Xmβ k+1 + rm − ym − d k m/µ 2 2 o, m = 1, 2, . . . , M, d k+1 m = d k m − µ(Xmβ k+1 + r k+1 m − ym), m = 1, 2, . . . , M,
(23)
where S = ηIp−µPM
m=1 X⊤
mXm = ηIp−µX⊤X. The steps that need to execute parallel processes in iteration are rm and dm. However, the central machine updating β encounters two issues due to not loading data. The first issue is that the update of β requires loading the collected data X, y.

The second one is that the calculation of η also depends on the collected data.

The above two issues seem to make this parallel LADMM algorithm impossible to implement.

Fortunately, continuing to derive the specific iteration steps for β, we found that both of these issues can be solved. Similar to (18), the iteration of β and rm can be represented as

$$\begin{cases}\boldsymbol{\beta}^{k+1}=\text{prox}_{\eta,P_{k}}\left(\boldsymbol{\beta}^{k}-\frac{\mu\sum_{m=1}^{M}\boldsymbol{X}_{m}^{\top}(\boldsymbol{X}_{m}\boldsymbol{\beta}^{k}+\boldsymbol{r}_{m}^{k}-\boldsymbol{y}_{m}-\boldsymbol{d}_{m}^{k}/\mu)}{\eta}\right),\\ \boldsymbol{r}_{m}^{k+1}=\text{prox}_{\mu,c_{r}},\,\left(\boldsymbol{y}_{m}+\boldsymbol{d}_{m}^{k}/\mu-\boldsymbol{X}_{m}\boldsymbol{\beta}^{k+1}\right),m=1,2,\ldots,M.\end{cases}\tag{24}$$

Let ξ k m = X⊤
m(Xmβ k + r k m − ym − d k m/µ), m = 1, 2*, . . . , M*. From the iteration sequence, it can be seen that in the k + 1 iteration, ξ k m can be generated by each local machine and transmitted to the central machine. Then,

$$\beta^{k+1}=\mathrm{prox}_{\eta,P_{\lambda}}\left(\beta^{k}-\frac{\mu}{\eta}\sum_{m=1}^{M}\xi_{m}^{k}\right).$$

Therefore, the first issue caused by the central machine not loading data has been resolved.

The second issue is the calculation of η. Each local machine only loads a portion of the data, which means we can only obtain ηm = eigen(µX⊤
mXm) on each local machine. Note that PM
m=1 ηm ≥ eigen(µX⊤X). Then, in the specific implementation of the parallel algorithm, we can choose PM
m=1 ηm as the value for η. In practical operation, we only need to calculate ηm once at the beginning of the iteration and then pass it on to the central machine. Therefore, both issues related to the implementation of parallel LADMM have been resolved.

To sum up, the iterative scheme of parallel LADMM for (13) can be described in Algorithm 2

## Algorithm 2 Parallel Ladmm For Solving Npsqr

Pre-computation: ηm = eigen(µX⊤mXm), m = 1, 2*, . . . , M*.

Input: - Central machine: augmented parameter µ; tuning parameters λ1 and λ2; η =PM
m=1 ηm; and initial iteration variable β 0.

- The m-th local machine: observation data {Xm, ym}M
m=1; augmented parameter µ; selected parameters τ ∈ (0, 1), and c > 0 or κ > 0; and initial iteration variables β 0, r 0m, d 0m and ξ 0m =
X⊤m(Xmβ 0 + r 0m − ym − d 0m/µ).

Output: The last iteration solution β K.

while not converged do Central machine: 1. Receive ηm (only once) and ξ

km transmitted by M local machines, 2. Update β k+1 j = proxη,Pλ β k j − (µPM m=1 ξ km)j η , j = 1, 2, . . . , p, 3. Send β k+1 to the local machines. 1. Receive β k+1 transmitted by the central machine, 2. Update r k+1 m,l = proxµ,Lτ,∗ [ym + d km/µ − Xmβ k+1]l , m = 1, 2, . . . , M, l = 1, 2, . . . , nm, k+1 k+1
Local machines: for m = 1, 2*, . . . , M* (in parallel)
3. Update d
m = d
km − µ(Xmβ
k+1 + r
m − ym), m = 1, 2*, . . . , M,*
4. Calculate ξ
k+1
m = X⊤m(Xmβ
k+1 + r
k+1
m − ym − d
k+1
m /µ), m = 1, 2*, . . . , M,*
5. Send ξ
k+1
m to the central machine.
end while
return solution.
Next, we will theoretically describe the relationship between Algorithm 1 and Algorithm 2. In fact, when M = 1, the two algorithms are the same, so the following discussion focuses on the case of M ≥ 2 in Algorithm 2. For ease of distinction, let us denote nβˆk, rˆ
k, dˆkoas the k-th iteration results of Algorithm 1, and nβ˜k, r˜
k, d˜koas the k-th iteration results of Algorithm 2. Then, we can draw the following surprising conclusion.

Theorem 1 *If we use the same initial iteration variables (*{βˆ0, rˆ
0, dˆ0} = {β˜0, r˜
0, d˜0}) and η*, the* iterative solutions obtained by these two algorithms are actually the same, i.e.,

$$\left\{\hat{\boldsymbol{\beta}}^{k},\hat{\boldsymbol{r}}^{k},\hat{\boldsymbol{d}}^{k}\right\}=\left\{\tilde{\boldsymbol{\beta}}^{k},\tilde{\boldsymbol{r}}^{k},\tilde{\boldsymbol{d}}^{k}\right\},\;f o r\;a l l\;k.$$

This theorem states that as long as Algorithm 1 and Algorithm 2 (M ≥ 2) adopt the same initial value and η, the iterative solution remains the same regardless of how the samples are divided. In other words, as long as η is the same, changes in M and the number of samples loaded by each machine will not affect the iterative solution of parallel LADMM. While this conclusion may not seem immediately intuitive, the proof for it is remarkably simple and is given in Appendix B.1.

$$(25)$$

However, as discussed above in solving the calculation problem of η in parallel algorithms, as the number of local machines increases, the value of η will also increase. There have been some studies on the impact of the η size in the linearized ADMM algorithm. Their conclusion was that a large η value causes the algorithm to converge slower, and there may be no significant changes in the convergence solution of the iteration. Interested readers can refer to the research conducted by He et al. (2020) and its references. Next, we will discuss the convergence of the algorithm.

Let us assume that X⊤X > µIp, where µ > 0 is a constant. It is worth noting that this assumption is, in fact, the lower restricted eigenvalue condition that is required in many penalized linear models as mentioned in Wang et al. (2020) and the references cited therein. We now demonstrate the convergence of the LADMM algorithm, and the proof is given in Appendix B.2.

Theorem 2 *Let the sequence* wk = {β k, r k, d k} be generated by Algorithms 1 or 2 with an arbitrary initial feasible solution w0 = {β 0, r 0, d 0}. Then, with the condtions µ >
√2n min{c,κ}and η > eigen(µX⊤X), the sequence wk*converges to* w∗ = {β
∗, r
∗, d
∗}, where w∗*is a critical point* of Lµ.

Remark 1 To solve the NPSQR with Lτ,c, the condition µ >
√2n max{τ,1−τ}
c*guarantees convergence* of the algorithm. On the other hand, for the NPSQR with Lτ,κ, the algorithm can converge as long as µ >
√2n κ. The reason behind the different requirements for µ in these two models lies in the disparity of the Lipschitz constant of the first derivative of the two smooth quantile losses.

A reasonable concern arises regarding the assumption about µ in this theorem. When n is large and either c or k takes small values, µ may become large. However, this does not affect the convergence of the algorithm. An intuitive explanation lies in the optimization formula (14). Our loss function is not divided by n like the empirical loss. Compared to the case of empirical loss, our objective function is multiplied by a factor of n. If we consider the normalized loss function PM
m=1 Pnm l=1 Lτ,∗(rm,l)
ninstead of the unnormalized one PM
m=1 Pnm l=1 Lτ,∗(rm,l), then µ only needs to be greater than
√
√2 n min{c,κ}
. When n is relatively large, µ may be relatively small or even close to 0.

## 3.3 Comparison With Other Parallel Admm Algorithms

There is a dearth of parallel algorithms for addressing the NPSQR issue. However, recent research has introduced parallel ADMM algorithms for nonconvex penalized quantile regression (NPQR),
such as Yu et al. (2017), Fan et al. (2021) and Wen et al. (2023). Ignoring some unrelated constant terms, as the values of c and κ approach 0, the function Lτ,∗ converges to the quantile loss.

Consequently, our algorithm can be applied to solve the NPQR problem. To provide a more comprehensive comparison, we review several parallel ADMM algorithms that address the NPQR
problem.

- QPADM in Yu et al. (2017). To have a parallel structure, auxiliary variables {βm = β}
M m=1 are added to (13). This modification transforms the constrained optimization problem into the following form,

$$\min_{\mathbf{\beta},\{\mathbf{r}_{m},\mathbf{\beta}_{m}\}_{m=1}^{M}}\quad\sum_{m=1}^{M}\rho_{r}(\mathbf{r}_{m})+P_{\lambda}(|\mathbf{\beta}|),$$  s.t. $\mathbf{X}_{m}\mathbf{\beta}_{m}+\mathbf{r}_{m}=\mathbf{y}_{m},\mathbf{\beta}_{m}=\mathbf{\beta},m=1,2,\ldots,M$. (26)
Problem (26) has the following augmented Lagrangian,

$$L_{\mu}(\mathbf{\beta},\{\mathbf{r}_{m},\mathbf{\beta}_{m},\mathbf{d}_{m}\}_{m=1}^{M})=\sum_{m=1}^{M}\rho_{r}(\mathbf{r}_{m})+P_{\lambda}(|\mathbf{\beta}|)-\sum_{m=1}^{M}\mathbf{d}_{1m}^{\sf T}(\mathbf{X}_{m}\mathbf{\beta}_{m}+\mathbf{r}_{m}-\mathbf{y}_{m})$$ $$+\frac{\mu}{2}\sum_{m=1}^{M}\|\mathbf{X}_{m}\mathbf{\beta}_{m}+\mathbf{r}_{m}-\mathbf{y}_{m}\|_{2}^{2}-\sum_{m=1}^{M}\mathbf{d}_{2m}^{\sf T}(\mathbf{\beta}_{m}-\mathbf{\beta})+\frac{\mu}{2}\sum_{m=1}^{M}\|\mathbf{\beta}_{m}-\mathbf{\beta}\|_{2}^{2}\,,\tag{27}$$

where d1m ∈ R
nm and d2m ∈ R
p are the dual variables. The parallel ADMM iterative scheme of
(27) is

  β k+1 = arg min β nPλ(|β|) + µ 2 PM m=1 β km − β − d k 2m/µ 2 2 o, r k+1 m = arg min rm nρτ (rm) + µ 2 Xmβ k+1 m + rm − ym − d k 1m/µ 2 2 o, m = 1, 2, . . . , M, β k+1 m = arg min βm nXmβm + r km − ym − d k 1m/µ 2 2 +βm − β k+1 − d k 2 /µ 2 2 o, m = 1, 2, . . . , M, (28) d k+1 1m = d k 1m − µ(Xmβ k+1 m + r k+1 m − ym), m = 1, 2, . . . , M, d k+1 2m = d k 2m − µ(β k+1 m − β k+1), m = 1, 2, . . . , M, .
Note that when M = 1, the algorithm becomes a nonparallel version of ADMM. Increasing the consensus constraint βm = β aids in eliminating internal loops and adapting to parallel frameworks. However, this change introduces an additional step in solving βm, which involves finding the inverse of X⊤
mXm + Inm. Although Yu et al. (2017) suggested using the Woodbury matrix identity to alleviate the computational burden of inverting these matrices, matrix multiplication can still be time-consuming, especially when p is large. Motivated by the maximization in QICD proposed by Peng and Wang (2015), QPADM transforms the nonconvex problem into weighted ℓ 1 soft-shrinkage operator for β k +1 -subproblem. However, this approximation may result in an excessive number of iterative steps.

 QPADMslack in Fan et al. (2021). Inspired by Guan et al. (2018), Fan et al. (2021) relaxed r m in (27) to u m − v m with u m ≥ 0 and v m ≥ 0 ( m = 1, 2, . . . , M ), and made an improvement in solving the β t +1 -subproblem. These changes can reduce the iteration steps and improve the computational accuracy of QPADM in calculating NPQR. The constrained optimization problem in the is

$$\min_{\mathbf{\beta},\{\mathbf{u}_{m}\geq0,\mathbf{v}_{m}\geq0,\mathbf{\beta}_{m}\}_{m=1}^{M}}\quad\sum_{m=1}^{M}\left(\tau\mathbf{u}_{m}+(1-\tau)\mathbf{v}_{m}\right)+P_{\lambda}(|\mathbf{\beta}|),$$ $$\text{s.t.}\quad\mathbf{X}_{m}\mathbf{\beta}_{m}+\mathbf{u}_{m}-\mathbf{v}_{m}=\mathbf{y}_{m},$$ $$\mathbf{\beta}_{m}=\mathbf{\beta},m=1,2,\ldots,M.\tag{29}$$

The iteration of QPADMslack shares similar steps with that of QPADM, yet two main differences exist. Firstly, the r subproblem is replaced by the u and v subproblems. Secondly, in contrast to the approximate solution of β in QPADM, QPADMslack utilizes the approximate closed-form solution for SCAD and MCP, as proposed by Gong et al. (2013) and Guan et al. (2018). The term "approximate closed-form solution" means finding the minimum point by comparing the minimum value of the objective function among several candidate minimum points. By contrast, our LADMM algorithm utilizes the derived proximal operators in Section 2.3 to directly provide a closed-form solution for this nonconvex problem.

![16_image_1.png](16_image_1.png)

![16_image_0.png](16_image_0.png)

data. The QPADM algorithm necessitates iteration over (2M + 1)p + 2n variables, whereas the QPADMslack algorithm requires iteration over (2M + 1)p + 3n variables. When p is very large, the Woodbury matrix identity that needs to be used is

$$(\mathbf{X}_{m}^{\top}\mathbf{X}_{m}+\mathbf{I}_{p})^{-1}=\mathbf{I}_{p}-\mathbf{X}_{m}^{\top}(\mathbf{X}_{m}\mathbf{X}_{m}^{\top}+\mathbf{I}_{n_{m}})^{-1}\mathbf{X}_{m}.$$

The matrix multiplication here is quite time-consuming. Referring to Algorithm 2, we observe that our LADMM algorithm only requires iterating over p + 2n variables and computing the maximum eigenvalue of the matrix µX⊤X (or {µX⊤
mXm}
M
m=1). According to the suggestion by Liang et al.

(2024), we use the power method provided by Golub and Loan (2013) to compute the maximum eigenvalue in the LADMM algorithm. This method is very efficient. We illustrate the time required to calculate the maximum eigenvalue as p changes in Figure 2. The R code for computing the maximum eigenvalue is also available in our R package.

- Feature-splitting ADMM in Wen et al. (2023). Inspired by the three-block ADMM in Sun et al. (2015), Wen et al. (2023) proposed a feature-splitting algorithm for solving ℓ1 quantile regression. Furthermore, guided by the theoretical results of Fan et al. (2014), they utilized the LLA
algorithm to solve NPQR. In particular, they used ℓ1 quantile regression as the initial value and iterated the calculation several times to obtain the solution, with a high probability of convergence to the true solution of NPQR. Feature-splitting ADMM (FSADMM) requires iterating over p +
(3M −1)n variables. Therefore, when n is relatively large, FSADMM may encounter computational difficulties with many local machines.

## 4 Simulation Studies

In this section, we aim to demonstrate the model selection, estimation accuracy, and computational efficiency of the proposed LADMM algorithm in both nonparallel and parallel environments. To accomplish this, we apply the LADMM algorithm to solve various problems, including NPQR
(Wang et al. (2012)), nonconvex penalized least squares and Huber regression (Fan et al. (2018)
and Pan et al. (2021)), as well as NPSQR (Mkhadri et al. (2017)). To choose the optimal values for the regularization parameters λ1 and/or λ2, we follow the approach proposed by Lee et al. (2014)

$${\rm HBIC}(\lambda_{1},\lambda_{2})=\log\left(\sum_{i=1}^{n}{\cal L}(y_{i}-{\mathbf{x}}_{i}^{\top}\hat{\mathbf{\beta}}_{\lambda_{1},\lambda_{2}})\right)+|S_{\lambda_{1},\lambda_{2}}|\frac{\log(\log n)}{n}C_{n}.\tag{30}$$

Here, L represents a specific loss function, and βˆλ1,λ2 corresponds to the nonconvex estimator obtained. |Sλ1,λ2 | denotes the number of nonzero coordinates in βˆλ1,λ2
, and the value Cn = 6 log(p)
is recommended by Peng and Wang (2015) and Fan et al. (2021). By minimizing the HBIC
criterion, we can effectively select the optimal λ1 and/or λ2 values for our nonconvex estimators.

These choices allow us to balance the trade-off between model complexity and goodness of fit.

All experiments were performed using R on a computer equipped with an AMD Ryzen 9 7950X
16-Core Processor running at 4.50 GHz and with 32 GB RAM. To facilitate the implementation and usage of the LADMM algorithm, we have developed an R package called PIPADMM. The package is available at the following GitHub repository: https://github.com/xfwu1016/PIPADMM.

## 4.1 Simulation For Npqr

In the first simulation, we apply the LADMM algorithm to solve the NPQR problem and compare its performance with several recent algorithms, including QRADM from Yu et al. (2017), QRADMslack from Fan et al. (2021), and Feature-splitting ADMM (FSADMM) from Wen et al.

(2023). While both Yu et al. (2017) and Fan et al. (2021) provided R packages for their respective algorithms, these packages are only compatible with Mac operating systems. Additionally, the QPADM package only provide estimated coefficients and lacked information such as iteration count and iteration time. To ensure fairness in the comparison, we have rewritten the R code for the QPADM and QPADMslack algorithms, based on the descriptions provided in the respective papers.

For all tested ADMM algorithms, we set the maximum iteration number to 500, with the stopping criterion defined as follows:

$$\frac{\|\beta^{k}-\beta^{k-1}\|_{2}}{\operatorname*{max}(1,\|\beta^{k}\|_{2})}\leq10^{-4}.$$

This stopping criterion ensures that the difference between consecutive iterations of the estimated coefficients does not exceed a specified threshold.

Regarding our simulation studies, we employed the simulated models in the simulation studies of Peng and Wang (2015), Yu et al. (2017), Fan et al. (2021) and Wen et al. (2023). Specifically, we generate data from the heteroscedastic regression model y = x6 +x12 +x15 +x20 + 0.7x1ϵ, where ϵ ∼ N(0, 1). The covariates (x1, x2*, . . . , x*p) are generated in two steps.

- First, we generate x˜ = (˜x1, x˜2*, . . . ,* x˜p)
⊤ from a p-dimensional multivariate normal distribution N(0, Σ), where Σij = 0.5 |i−j|for 1 ≤ *i, j* ≤ p.

- Second, we set x1 = Φ(˜x1) and xj = ˜xjfor j = 2*, . . . , p*.

In nonparallel environments (M = 1), we simulate datasets with sizes (n, p) = (30,000, 1,000),
(1,000, 30,000), (10,000, 30,000), and (30,000, 30,000). In parallel environments (M ≥ 2), we simulate datasets with sizes (n, p) = (200,000, 500) and (500,000, 1,000). We run 500 independent simulations, and the average results for both nonparallel and parallel computations are presented in Table 1 and Table 2, respectively. Due to space limitations, this section will only focus on the results of the SCAD (a = 3.7) and τ = 0.7, while the other simulation results are included in Appendix C.1.

| Table 1: Comparison of various ADMMs with SCAD penalty of different data sizes.                                                                                                                                                                                                                                                                                                       |               |               |             |             |              |     |     |             |           |              |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|---------------|-------------|-------------|--------------|-----|-----|-------------|-----------|--------------|
| (n, p)                                                                                                                                                                                                                                                                                                                                                                                | (30000,1000)  | (1000,30000)  |             |             |              |     |     |             |           |              |
| P1                                                                                                                                                                                                                                                                                                                                                                                    | P2            | AE            | Ite         | Time        | P1           | P2  | AE  | Ite         | Time      |              |
| QPADM                                                                                                                                                                                                                                                                                                                                                                                 | 100           | 100           | 0.016(0.03) | 104.8(11.9) | 38.62(6.45)  | 0   | 100 | 7.585(0.91) | 500(0.0)  | 1924.5(55.3) |
| QPADMslack                                                                                                                                                                                                                                                                                                                                                                            | 100           | 100           | 0.058(0.03) | 51.2 (5.58) | 35.95(4.35)  | 0   | 100 | 8.465(1.12) | 216(13.5) | 1133.8(39.4) |
| FSADMM                                                                                                                                                                                                                                                                                                                                                                                | 100           | 100           | 0.017(0.04) | 500(0.00)   | 155.6(11.3)  | 100 | 100 | 0.621(0.09) | 500(0.00) | 134.1(10.1)  |
| LADMM                                                                                                                                                                                                                                                                                                                                                                                 | 100           | 100           | 0.022(0.03) | 44(2.29)    | 34.53(4.12)  | 100 | 100 | 0.482(0.05) | 166(11.9) | 60.7(5.0)    |
| (n, p)                                                                                                                                                                                                                                                                                                                                                                                | (10000,30000) | (30000,30000) |             |             |              |     |     |             |           |              |
| P1                                                                                                                                                                                                                                                                                                                                                                                    | P2            | AE            | Ite         | Time        | P1           | P2  | AE  | Ite         | Time      |              |
| QPADM                                                                                                                                                                                                                                                                                                                                                                                 | 100           | 100           | 3.891(1.23) | 500(0.00)   | 2178.4(66.8) | 100 | 100 | 1.758(0.13) | 500(0.00) | 3264.3(56.3) |
| QPADMslack                                                                                                                                                                                                                                                                                                                                                                            | 100           | 100           | 4.171(1.64) | 252(20.7)   | 1429.6(35.7) | 100 | 100 | 2.263(0.25) | 327(21.1) | 2126.3(41.2) |
| FSADMM                                                                                                                                                                                                                                                                                                                                                                                | 100           | 100           | 0.592(0.16) | 500(0.00)   | 238.9(18.1)  | 100 | 100 | 1.092(0.10) | 500(0.00) | 424.2(17.4)  |
| LADMM                                                                                                                                                                                                                                                                                                                                                                                 | 100           | 100           | 0.348(0.08) | 182(13.6)   | 75.6(6.6)    | 100 | 100 | 0.663(0.09) | 239(15.2) | 183.6(8.5)   |
| * The meanings of the notations used in this table are as follows: P1 (%): proportion that x1 is selected; P2 (%): proportion that x6, x12, x15, and x20 are selected; AE: absolute estimation error; Ite: number of iterations; Time (s): running time. Numbers in the parentheses represent the corresponding standard deviations, and the optimal solution is represented in bold. |               |               |             |             |              |     |     |             |           |              |

Table 1 provides evidence that LADMM outperforms QPADM and QPADMslack in terms of computational speed and estimation accuracy when the dimensionality of the problem p is large. Furthermore, LADMM outperforms FSADMM when the sample size n is large. To further illustrate the advantages of LADMM, we present the computational time in Figure 3. These numerical results indicate that LADMM demonstrates remarkable advantages in terms of computational efficiency and accuracy compared to other ADMM algorithms, particularly for scenarios where both n and/or p are large. In Table 2, we observe that when multiple local machines are employed, LADMM shows comparable performances in terms of computational time and accuracy compared to QRADM and QRADMslack. This result is also visualized in Figure 4. Table 2 and Figure 4 underscore the advantages of utilizing LADMM in parallel computing settings. It is worth noting that our solution is not particularly influenced by M, which is consistent with the theoretical results of Section 3.2.

| Table 2: Comparison of various parallel ADMMs with SCAD penalty.                                                                                                                                         |               |                |                |            |            |               |             |             |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|----------------|----------------|------------|------------|---------------|-------------|-------------|
| QPADM                                                                                                                                                                                                    | (200000, 500) | QPADM          | (500000, 1000) |            |            |               |             |             |
| M                                                                                                                                                                                                        | Nonzero       | AE             | Ite            | Time       | Nonzero    | AE            | Ite         | Time        |
| 5                                                                                                                                                                                                        | 37.2(1.83)    | 0.053(0.0008)  | 342.8(23.9)    | 72.8(5.63) | 25.7(1.37) | 0.043(0.0007) | 458.3(35.8) | 182.8(10.5) |
| 20                                                                                                                                                                                                       | 38.4(2.03)    | 0.068(0.00113) | 375.1(29.2)    | 39.8(4.73) | 27.4(1.72) | 0.051(0.0009) | 483.1(39.2) | 99.5(5.90)  |
| 100                                                                                                                                                                                                      | 40.6(2.3)     | 0.085(0.00251) | 419.7(67.8)    | 18.6(3.34) | 33.5(2.15) | 0.077(0.0018) | 496.7(17.8) | 38.6(4.74)  |
| QPADMslack                                                                                                                                                                                               | (200000, 500) | QPADMslack     | (500000, 1000) |            |            |               |             |             |
| M                                                                                                                                                                                                        | Nonzero       | AE             | Ite            | Time       | Nonzero    | AE            | Ite         | Time        |
| 5                                                                                                                                                                                                        | 34.6(1.91)    | 0.062(0.0017)  | 214.4(25.4)    | 31.2(4.05) | 24.9(1.23) | 0.039(0.0006) | 311.7(28.2) | 79.5(7.93)  |
| 20                                                                                                                                                                                                       | 39.7(2.15)    | 0.075(0.0024)  | 236.3(26.9)    | 10.7(2.11) | 29.5(1.50) | 0.048(0.0010) | 347.3(32.5) | 41.2(5.85)  |
| 100                                                                                                                                                                                                      | 41.2(2.55)    | 0.094(0.0031)  | 375.7(82.6)    | 4.61(0.83) | 32.3(1.91) | 0.074(0.0021) | 396.5(72.3) | 20.9(2.44)  |
| LADMM                                                                                                                                                                                                    | (200000, 500) | LADMM          | (500000, 1000) |            |            |               |             |             |
| M                                                                                                                                                                                                        | Nonzero       | AE             | Ite            | Time       | Nonzero    | AE            | Ite         | Time        |
| 5                                                                                                                                                                                                        | 5.63(0.41)    | 0.055(0.0008)  | 49.7(1.21)     | 19.7(1.02) | 5.42(0.35) | 0.032(0.0005) | 78.7(3.42)  | 32.6(2.32)  |
| 20                                                                                                                                                                                                       | 5.64(0.41)    | 0.056(0.0008)  | 53.0(1.32)     | 10.3(0.73) | 5.42(0.37) | 0.036(0.0006) | 79.6(3.54)  | 20.5(1.83)  |
| 100                                                                                                                                                                                                      | 5.63(0.43)    | 0.055(0.0008)  | 56.9(1.38)     | 5.32(0.45) | 5.42(0.34) | 0.035(0.0006) | 81.0(3.60)  | 15.5(1.22)  |
| * P1 and P2 are not presented in Table 2 because all methods have a value of 100 for these two metrics. It is clear that Nonzero, AE, and Ite of LADMM are not significantly affected by the value of M. |               |                |                |            |            |               |             |             |

![20_image_0.png](20_image_0.png)

## 4.2 Simulation For Npls And Nphr

In this simulation, we utilize the proposed LADMM method and the ILAMM algorithm proposed in Fan et al. (2018) and Pan et al. (2021) to solve nonconvex penalized least squares regression

![21_image_0.png](21_image_0.png)

| Table 3: Comparison of LS-SCAD and Huber-SCAD Calculated by LADMM and ILAMM LS-SCAD Huber-SCAD   |           |    |            |            |               |    |            |            |             |
|--------------------------------------------------------------------------------------------------|-----------|----|------------|------------|---------------|----|------------|------------|-------------|
| (n, p)                                                                                           | Algorithm | FP | FN         | AE         | Time          | FP | FN         | AE         | Time        |
| (100,1000)                                                                                       | ILAMM     | 0  | 1          | 0.34(0.08) | 8.8(1.2)      | 0  | 1          | 0.41(0.07) | 23.2(5.2)   |
| LADMM                                                                                            | 0         | 0  | 0.29(0.07) | 1.3(0.2)   | 0             | 0  | 0.34(0.07) | 1.41(0.3)  |             |
| (100,10000)                                                                                      | ILAMM     | 0  | 0          | 0.50(0.10) | 175.3(10.3)   | 0  | 0          | 0.52(0.18) | 362.9(15.9) |
| LADMM                                                                                            | 0         | 0  | 0.41(0.09) | 7.1(1.0)   | 0             | 0  | 0.49(0.16) | 7.8(0.8)   |             |
| (10000,10000)                                                                                    | ILAMM     | 0  | 1          | 0.05(0.01) | 1885.0(121.4) | 0  | 1          | 0.07(0.01) | 2314(102.3) |
| LADMM                                                                                            | 0         | 0  | 0.06(0.02) | 31.8(6.7)  | 0             | 0  | 0.01(0.00) | 35.2(7.5)  |             |

(NPLS) and nonconvex penalized Huber regression (NPHR). We then compare the performance of these methods. Pan et al. (2021) provided a R package for ILAMM which is available at https:
//github.com/XiaoouPan/ILAMM. Similar to Pan et al. (2021), we generate the heteroscedastic model, yi = x
⊤
i β + c
−1(x
⊤
i β)
2ϵi with xi ∼ N(0, Ip) for i = 1*, . . . , n*, where the constant c is chosen as c =
√3β
⊤β such that Ec
−1(x
⊤
i β)
22= 1. The true vector of regression coefficients β is
(4, 3, 2, −2, −2, −2, 0*, . . . ,* 0)⊤. Moreover, we consider the following two error distributions.

- Normal distribution: ϵi ∼ N(*µ, σ*2) with µ = 0 and standard deviation σ = 1.5.

- Lognormal distribution: ϵi ∼ LN(*µ, σ*2) with µ = 0 and σ = 1.2.
Table 3 presents the simulation results of LADMM and ILAMM solving least squares SCAD
(LS-SCAD) and Huber SCAD models (Huber-SCAD) when the errors follow a normal distribution.

The results demonstrate that LADMM outperforms the ILAMM in effectively solving both NPLS and NPHR models. In addition, if p is large, ILAMM may be time-consuming. The simulation results for the Lognormal distribution, as well as other nonconvex penalties, are presented in the

## 4.3 Simulation For Npsqr

In this example, we utilize the proposed LADMM and algorithm in Mkhadri et al. (2017) to solve nonconvex penalized smooth quantile regression (NPSQR) and compare their performances.

Mkhadri et al. (2017) provided an efficient R package for calculating NPSQR, which can be found at the following https://github.com/KarimOualkacha/cdaSQR/tree/master. Following the scenario 3 in Section 4.2 of Mkhadri et al. (2017), we generate data sets with yi = x
⊤
i β + ϵi, where ϵ ∼ *N(0, σ*2Ip) and σ = 5. The covariates (x1, x2*, . . . , x*p) are generated from N(0, Σ), where Σij = 0.5 |i−j|for 1 ≤ *i, j* ≤ p. The true vector of regression coefficients is

$$\beta=(\underbrace{3,\ldots,3}_{5},\underbrace{-1.5,\ldots,-1.5}_{5},\underbrace{1,\ldots,1}_{5},\underbrace{2,\ldots,2}_{5},\underbrace{0,\ldots,0}_{p-20})^{\top}.$$

The comparison results of our algorithm LADMM and cdaSQR are summarized in Table 4. These results are all about Snet, and the results for Mnet and Cnet are in the Appendix C.3. In terms of computational accuracy and speed, LADMM and cdaSQR perform similarly, but LADMM has

| Table 4: Comparison of LADMM and cdaSQR with δ = 0.5 and τ = 0.5 cdaSQR LADMM   |               |       |            |             |             |      |            |             |             |
|---------------------------------------------------------------------------------|---------------|-------|------------|-------------|-------------|------|------------|-------------|-------------|
| (n, p)                                                                          | Loss function | FP    | FN         | AE          | Time        | FP   | FN         | AE          | Time        |
| (5000,500)                                                                      | Lτ,c          | 2.52  | 7.39       | 0.47(0.05)  | 3.36(0.36)  | 0    | 0.11       | 0.34(0.03)  | 3.62(0.37)  |
| Lτ,κ                                                                            | 3.25          | 8.36  | 0.35(0.04) | 3.47(0.42)  | 0           | 0.08 | 0.29(0.02) | 3.78(0.38)  |             |
| (10000,1000)                                                                    | Lτ,c          | 3.98  | 10.36      | 1.38(0.08)  | 5.11(0.82)  | 0    | 0.01       | 0.88(0.05)  | 4.71(0.67)  |
| Lτ,κ                                                                            | 2.52          | 9.47  | 1.22(0.08) | 4.76(0.71)  | 0           | 0.04 | 0.74(0.04) | 4.83(0.69)  |             |
| (20000,2000)                                                                    | Lτ,c          | 3.69  | 15.36      | 1.89(0.12)  | 24.33(2.39) | 0    | 0.01       | 0.96(0.09)  | 20.39(2.48) |
| Lτ,κ                                                                            | 4.40          | 14.77 | 1.73(0.10) | 19.25(2.11) | 0           | 0.05 | 0.89(0.08) | 19.64(2.36) |             |

## 5 Real Data Studies

In this section, we compare the performance of several parallel ADMM algorithms in an online publicly available dataset at http://archive.ics.uci.edu/ml/datasets/Online+News+Popularity.

This dataset provides a summary of the popularity, measured in terms of shares, as well as 60 features of 39,644 news published by Mashable over a two-year period. The features include various aspects such as binary variables indicating news categories (Lifestyle, Entertainment, Business, Social Media, Technology, or World), published time (day of the week and weekend or not), average word length, number of keywords, rate of nonstop words, and more. For more information about the dataset, please refer to the study conducted by Fernandes et al. (2015).

This dataset is heterogeneous in nature, and it has been analyzed by Fan et al. (2021) using NPQR. Their aim was to analyze how various features impact the popularity of news, particularly focusing on those that had gained high levels of popularity. They identified x14 (Entertainment)
and x27 (number of key words) as the two most influential features. However, the empirical results in Fan et al. (2021) also indicated that QPADM and QPADMslack algorithms tend to select a relatively larger number of variables, and this tendency becomes more pronounced as M increases.

The following empirical results indicate that LADMM does not have this increasing trend, and also has good prediction accuracy.

As in the study by Fan et al. (2021), we standardize the non-binary factors to have zero mean and unit variance. The features and response variables are denoted as x1, x2*, . . . , x*60 and y, respectively. To assess the performance of the algorithm, we randomly partition the complete dataset 100 times. Each partition consisted of randomly selecting 35,000 samples as the training set, with the remaining samples designated as the test set. To replicate the scenario of parallel computing, we randomly divide the training set into subsets of equal size. In our analysis, we consider values of M = 10 and M = 100. We then record the average number of selected nonzero coefficients (Nonzero), the prediction error (PE), the number of iterations (Ite), and the CPU
running time (in seconds) of the algorithms. The prediction error (PE) is calculated as follows:
PE = 1 n*test* Pn*test* i=1 |yi − yˆi|, where n*test* = 4644 represents the sample size of the test set. We only include the results of SCAD (a = 3.7) regression in Table 5, and the results of MCP regression are included in Appendix C.4.

| Table 5: Analysis of the news popularity data under the SCAD penalty with τ = 0.5.   |               |               |              |             |             |             |            |
|--------------------------------------------------------------------------------------|---------------|---------------|--------------|-------------|-------------|-------------|------------|
| Algorithm                                                                            | M             | x14           | x27          | Nonzero     | PE          | Ite         | Time       |
| QRADM                                                                                | 10            | -0.021(0.002) | 0.054(0.002) | 34.53(1.47) | 0.22(0.02)  | 223.6(37.8) | 20.1(2.32) |
| 100                                                                                  | -0.020(0.002) | 0.056(0.001)  | 34.82(1.25)  | 0.20(0.02)  | 294.8(50.3) | 4.5(0.67)   |            |
| QRADMslack                                                                           | 10            | -0.019(0.001) | 0.055(0.001) | 33.92(1.59) | 0.20(0.03)  | 112.9(11.2) | 9.8(1.03)  |
| 100                                                                                  | -0.018(0.001) | 0.057(0.001)  | 34.07(1.41)  | 0.20(0.02)  | 135.4(15.7) | 2.1(0.31)   |            |
| LADMMρ                                                                               | 10            | -0.010(0.001) | 0.021(0.001) | 10.34(0.56) | 0.18(0.02)  | 81.2(8.4)   | 3.2(0.21)  |
| 100                                                                                  | -0.011(0.001) | 0.022(0.001)  | 10.35(0.56)  | 0.18(0.02)  | 83.6(8.7)   | 2.2(0.11)   |            |
| LADMMLτ,c,δ=1                                                                        | 10            | -0.012(0.001) | 0.023(0.001) | 12.67(1.35) | 0.19(0.01)  | 65.9(9.6)   | 2.9(0.13)  |
| 100                                                                                  | -0.012(0.001) | 0.023(0.001)  | 12.65(1.38)  | 0.19(0.01)  | 68.3(9.7)   | 2.1(0.05)   |            |
| LADMMLτ,κ,δ=1                                                                        | 10            | -0.011(0.001) | 0.024(0.001) | 13.11(1.45) | 0.20(0.01)  | 72.6(10.1)  | 3.0(0.21)  |
| 100                                                                                  | -0.011(0.001) | 0.024(0.001)  | 13.11(1.45)  | 0.20(0.01)  | 78.6(10.3)  | 2.1(0.08)   |            |

Table 5 demonstrates that the LADMM algorithm exhibits competitive performance in terms of both time and accuracy compared to the QPADM and QPADMslack algorithms. Additionally, LADMM clearly demonstrates superior variable selection capability, and its iterative convergence is not affected by the value of M. It is worth noting that, in addition to the important variables x14 and x27 identified in the previous study, our analysis reveals that variables x5 (number of stopwords)
and x18 (a binary variable that represents whether the data channel is the word "world" or not) are also significant. In particular, variable x5 exhibits a notable importance. We visualize this result in Figure 5. Our newly discovered features are interpretable in real life. Excessive stopwords can make news verbose, trivial and lack coherence, making it difficult to convey clear ideas and information. On the other hand, the use of "world" as data channels for news may result in a relatively smaller audience and, consequently, lower sharing volume, as the focus of news coverage might differ from the interests of the general public.

![24_image_0.png](24_image_0.png)

## 6 Conclusion And Discussion

This paper introduces a parallel LADMM algorithm designed to efficiently solve nonconvex penalized smooth quantile regression problems. Our algorithm is easy to implement, and it offers great flexibility that allows for its extension to many other nonconvex penalized regression models, such as quantile regressions, least squares regressions, and Huber regressions. These extensions have also been implemented in our R package PIPADMM. At present, the parallel algorithm implementation in our R package is akin to the pseudo-parallelism of the R packages QRADMM
and QPADMslack. One advantage of this pseudo-parallelism is that it is very convenient for readers to verify algorithms and reproduce code on a computer. Readers can also utilize our designed algorithm framework for processing distributed stored data in Spark. Notably, compared to existing parallel algorithms that rely on consensus-based approaches for solving regression models, our solution companion changes very little with different sample partitioning strategies and requires fewer iterations to achieve convergence. Furthermore, for smooth loss functions, we prove the global convergence of our LADMM algorithm, meaning that the iterative solutions converge to a critical point of the Lagrangian function.

The parallel algorithm design process outlined in Section 3.2 indicates that other linearized ADMM algorithms, such as those presented in Li et al. (2014), Gu et al. (2018), and Liang et al. (2024), can be readily adapted to parallel computation using our strategy. Although this paper only deals with regression problems with simple combined regularization like Elastic-net, Snet, Mnet, and Cnet, our algorithm also has the potential to handle more complex combinatorial regularization terms. Examples include sparse group lasso in Wu and Lange (2008) and Laria et al. (2019), as well as sparse fused lasso in Tibshirani et al. (2005) and Wu et al. (2024).

There is still much work to be done, such as studying the convergence of parallel ADMM
algorithms for solving NPQR, which has remained an unresolved open problem in Yu et al. (2017). This paper only employs NPSQR to approximate NPQR, which appears to solve the convergence issue. However, this study demonstrated that the global convergence claimed by Theorem 2 cannot be guaranteed for arbitrarily small c and κ. Furthermore, our algorithm not only efficiently handles regularized regression problems, but also easily extends to regularized classification problems with smoothing losses, such as Huber loss SVM in Wang et al. (2008) and least squares loss SVM in Huang et al. (2014).

## Acknowledgements

We are grateful to Professor Karim Oualkacha from the Department of Mathematics at the Universit´e du Qu´ebec `a Montr´eal for providing us with the code for the R package cdaSQR. Specifically, we are very grateful to Professor Bingsheng He for his valuable discussions with us, which greatly helped us prove the convergence of the algorithm. The research was partially supported by the National Natural Science Foundation of China [grant numbers 11871121, 12171405, 12271066] and the project of science and technology research program of Chongqing Education Commission of China [Grant Numbers KJQN202302003].

## References

Aravkin, A. Y., Kambadur, A., Lozano, A. C., and Luss, R. (2014). Sparse Quantile Huber Regression for Efficient and Robust Estimation. *ArXiv*, 14(1):1–1.

Boyd, S., Parikh, N., Chu, E., Peleato, B., and Eckstein, J. (2010). Distributed Optimization and Statistical Learning Via the Alternating Direction Method of Multipliers. Foundation and Trends in Machine Learning, 3(1):1–122.

Fan, J. and Li, R. (2001). Variable Selection via Nonconcave Penalized Likelihood and its Oracle Properties. *Journal of the American Statistical Association*, 96(456):1348–1360.

Fan, J., Liu, H., Sun, Q., and Zhang, T. (2018). I-LAMM for Sparse Learning: Simultaneous Control of Algorithmic Complexity and Statistical Error. *The Annals of Statistics*, 46(2):814–
841.

Fan, J., Xue, L., and Zou, H. (2014). Strong Oracle Optimality of Folded Concave Penalized Estimation. *The Annals of Statistics*, 42(3):819–849.

Fan, Y., Lin, N., and Yin, X. (2021). Penalized Quantile Regression for Distributed Big Data Using the Slack Variable Representation. *Journal of Computational and Graphical Statistics*, 30(3):557–565.
Fernandes, K., Vinagre, P., and Cortez, P. (2015). A Proactive Intelligent Decision Support System for Predicting the Popularity of Online News. In 17th Portuguese Conference on Artificial Intelligence, pages 535–546.

Golub, G. H. and Loan, C. F. V. (2013). *Matrix Computations - 4th Edition*. Johns Hopkins

University Press.

Gong, P., Zhang, C., Lu, Z., Huang, J., and Ye, J. (2013). A General Iterative Shrinkage and Thresholding Algorithm for Non-convex Regularized Optimization Problems. International Conference on Machine Learning, 28:37–45.

Gu, Y., Fan, J., Kong, L., Ma, S., and Zou, H. (2018). ADMM for High-Dimensional Sparse Penalized Quantile Regression. *Technometrics*, 60(3):319–331.

Guan, L., Qiao, L., Li, D., Sun, T., Ge, K., and Lu, X. (2018). An Efficient ADMM-Based Algorithm to Nonconvex Penalized Support Vector Machines. *2018 IEEE International Conference* on Data Mining Workshops, pages 1209–1216.

Guo, K., Han, D., and Wu, T. (2016). Convergence of Alternating Direction Method for Minimizing Sum of Two Nonconvex Functions with Linear Constraints. *International Journal of Computer* Mathematics, 94(8):1–18.

He, B., Ma, F., and Yuan, X. (2020). Optimally Linearizing the Alternating Direction Method of Multipliers for Convex Programming. *Computational Optimization and Applications*, 75:361– 388.
Huang, J., Breheny, P., Ma, S., and Zhang, C. (2016). THE Mnet Method for Variable Selection.

Statistica Sinica, 3:903–923.

Huang, X., Shi, L., and Suykens, J. A. K. (2014). Asymmetric Least Squares Support Vector Machine Classifiers. *Computational Statistics & Data Analysis*, 70:395–405.

Huber, P. J. (1964). Robust Estimation of a Location Parameter. *Annals of Mathematical Statistics*,
35:492–518.
Jennings, L. S., Wong, K. H., and Teo, K. L. (1993). An Optimal Control Problem in Biomechanics.

Ifac Proceedings Volumes, 26(2):279–282.

Kim, J. and Oh, H.-S. (2020). Pseudo-quantile Functional Data Clustering. Journal of Multivariate Analysis, 178:104626.
Koenker, R. and Basset, G. (1978). Regressions Quantiles. *Econometrica*, 46. Laria, J. C., Aguilera-Morillo, M. C., and Lillo, R. E. (2019). An Iterative Sparse-Group Lasso.

Journal of Computational and Graphical Statistics, 28(3):722–731.

Lee, E. R., Noh, H., and Park, B. U. (2014). Model Selection via Bayesian Information Criterion for Quantile Regression Models. *Journal of the American Statistical Association*, 109(505):216–229.

Li, G., Peng, H., and Zhu, L. (2011). Nonconcave Penalized M-estimation with a Diverging Number of Parameters. *Statistica Sinica*, 21(1):391–419.

Li, X., Mo, L., Yuan, X., and Zhang, J. (2014). Linearized Alternating Direction Method of Multipliers for Sparse Group and Fused LASSO Models. *Computational Statistics & Data Analysis*,
79:203–221.
Liang, R., Wu, X., and Zhang, Z. (2024). Linearized Alternating Direction Method of Multipliers for Elastic-net Support Vector Machines. *Pattern Recognition*, 148:110134.

Lin, Z., Fang, C., and Li, H. (2022). Alternating Direction Method of Multipliers for Machine Learning. Springer Singapore.

Loh, P.-L. (2017). Statistical Consistency and Asymptotic Normality for High-dimensional Robust M-estimators. *The Annals of Statistics*, 45(2):866–896.

Loh, P.-L. and Wainwright, M. J. (2015). Regularized M-estimators with Nonconvexity: Statistical and Algorithmic Theory for Local Optima. *The Journal of Machine Learning Research*.

Mkhadri, A., Ouhourane, M., and Oualkacha, K. (2017). A Coordinate Descent Algorithm for Computing Penalized Smooth Quantile Regression. *Statistics and Computing*, 27:865–883.

Negahban, S. N., Ravikumar, P., Wainwright, M. J., and Yu, B. (2010). A Unified Framework for High-Dimensional Analysis of M-Estimators with Decomposable Regularizers. *Statistical* Science, 27(4):538–557.

Newey, W. and Powell, J. (1987). Asymmetric Least Squares Estimation and Testing. Econometrica, 55:819–847.

Oh, H.-S., Thomas, C. M. L., and Douglas, W. N. (2011). Fast Nonparametric Quantile Regression With Arbitrary Smoothing Methods. *Journal of Computational and Graphical Statistics*,
20(2):510–526.

Ouhourane, M., Yang, Y., Benedet, A. L., and Oualkacha, K. (2022). Group Penalized Quantile Regression. *Statistical Methods and Applications*, 31(3):495–529.

Pan, X., Sun, Q., and Zhou, W. (2021). Iteratively Reweighted ℓ1-penalized Robust Regression.

Electronic Journal of Statistics, 15(1):3287–3348.

Peng, B. and Wang, L. (2015). An Iterative Coordinate Descent Algorithm for High-Dimensional Nonconvex Penalized Quantile Regression. *Journal of Computational & Graphical Statistics*, 24(3):676–694.

Sun, D., Toh, K.-C., and Yang, L. (2015). A Convergent 3-Block SemiProximal Alternating Direction Method of Multipliers for Conic Programming with 4-Type Constraints. SIAM Journal on Optimization, 25(2):882–915.

Tibshirani, R., Saunders, M., Rosset, S., Zhu, J., and Knight, K. (2005). Sparsity and Smoothness Via the Fused Lasso. *Journal of the Royal Statistical Society: Series B (Statistical Methodology*, 67(1):91–108.

Wang, L., Peng, B., Bradic, J., Li, R., and Wu, Y. (2020). A Tuning-free Robust and Efficient Approach to High-dimensional Regression. *Journal of the American Statistical Association*,
115(532):1–44.

Wang, L., Wu, Y., and Li, R. (2012). Quantile Regression for Analyzing Heterogeneity in Ultra-
High Dimension. *Journal of the American Statistical Association*, 107:214–222.

Wang, L., Zhu, J., and Zou, H. (2008). Hybrid Huberized Support Vector Machines for Microarray Classification and Gene Selection. *Bioinformatics*, 24(3):412–419.

Wang, X., Park, T., and Carriere, K. C. (2010). Variable Selection via Combined Penalization for High-dimensional Data Analysis. *Computational Statistics & Data Analysis*, 54(10):2230–2243.

Wang, X. and Yuan, X. (2012). The Linearized Alternating Direction Method of Multipliers for Dantzig Selector. *Siam Journal on Scientific Computing*, 34(5):2792–2811.
Wen, J., Yang, S., Wang, C., Jiang, Y., and Li, R. (2023). Feature-splitting Algorithms for Ultrahigh Dimensional Quantile Regression. *Journal of Econometrics*, page 105426.

Wu, T. and Lange, K. (2008). Coordinate Descent Algorithms for Lasso Penalized Regression.

Wu, X., Ming, H., Zhang, Z., and Cui, Z. (2024). Multi-block Alternating Direction Method of Multipliers for Ultrahigh Dimensional Quantile Fused Regression. *Computational Statistics &*
Data Analysis, 192:107901.
Yu, L. and Lin, N. (2017). ADMM for Penalized Quantile Regression in Big Data. International

Statistical Review, 85:494–518.

Yu, L., Lin, N., and Wang, L. (2017). A Parallel Algorithm for Large-Scale Nonconvex Penalized Quantile Regression. *Journal of Computational and Graphical Statistics*, 26(4):935–939.
Zhang, C. (2010a). Nearly Unbiased Variable Selection Under Minimax Concave Penalty. *Annals* of Statistics, 38(2):894–942.

Zhang, T. (2010b). Analysis of Multi-stage Convex Relaxation for Sparse Regularization. *Journal* of Machine Learning Research, 11(35):1081–1107.

Zheng, S. (2011). Gradient Descent Algorithms for Quantile Regression with Smooth Approximation. *International Journal of Machine Learning & Cybernetics*, 2:191–207.

Zhou, W.-X., Bose, K., Fan, J., and Liu, H. (2018). A New Perspective on Robust M-Estimation:
Finite Sample Theory and Applications to Dependence-Adjusted Multiple Testing. The Annals of Statistics, 46(5):1904–1931.
Zou, H. and Hastie, T. (2005). Regularization and Variable Selection Via the Elastic Net. Journal of the Royal Statistical Society Series B: Statistical Methodology, 67(2):301–320.

Zou, H. and Li, R. (2008). One-step Sparse Estimates in Nonconcave Penalized Likelihood Models.

The Annals of Statistics, 36(4):1509–1533.

## Online Support Materials

In this online support materials, we first provide the derivation of the closed-form solution for the proximal operator in Section 2.3 of the main text. Next, we give the proofs of Theorem 1 and Theorem 2. Finally, we present supplementary numerical experiments.

## A Proof Of The Closed-Form Solution Of Proximal Operator

In A.1, we derive closed-form solutions for the proximal operators of two smooth quantile regression methods similar to those in Liang et al. (2024). In A.2, we propose a simple and scalable approach for deriving closed-form solutions of the proximal operator for regularized terms.

## A.1 Loss Fuction

Recalling that the loss function Lτ,∗(u) = Pn i=1 Lτ,∗(ui), we can divide the optimization problem

$$\arg\min_{\mathbf{u}}\left\{\mathcal{L}_{\tau,*}(\mathbf{u})+\frac{\mu}{2}\left\|\mathbf{u}-\mathbf{v}\right\|_{2}^{2}\right\}\tag{31}$$

into n independent univariate problems, which can be expressed as min ui Lτ,∗(ui) + µ 2
(ui − vi)
2 2
	, i =
1, 2*, . . . , n*. We denote the minimum solution of (31) by uˆ.

- Lτ,c(ui): Let us examine the expression for Lτ,c(ui):

$$\left\{\begin{array}{ll}\tau(u_{i}-0.5c)&\mbox{if$u_{i}\geq c$,}\\ \frac{\tau u_{i}^{2}}{2c}&\mbox{if$0\leq u_{i}<c$,}\\ \frac{(1-\tau)u_{i}^{2}}{2c}&\mbox{if$-c\leq u_{i}<0$,}\\ (\tau-1)(u_{i}+0.5c)&\mbox{if$u_{i}<-c$.}\end{array}\right.\tag{32}$$

Throughout the entire domain of the above function, it is either a linear or quadratic function.

Therefore, it has a closed-form solution in each small domain. After some algebra, we have

$${\hat{u}}_{j}={\left\{\begin{array}{l l}{v_{j}-{\frac{\tau}{\mu}},}\\ {}&{}\\ {{\frac{c\mu v_{j}}{c\mu+\tau}},}\\ {}&{}\\ {{\frac{c\mu v_{j}}{c\mu+1-\tau}},}\\ {}&{}\\ {{v_{j}-{\frac{\tau-1}{\mu}},}}\end{array}\right.}$$
 if $v_j\geq c+\frac{\tau}{\mu}$,  if $0\leq v_j<c+\frac{\tau}{\mu}$,  if $\,-\,c+\frac{\tau-1}{\mu}\leq v_j<0$,  if $v_j<-c+\frac{\tau-1}{\mu}$. 
$$(33)$$

- Lτ,κ(ui): Let us examine the expression for Lτ,κ(ui):

$$\left\{\begin{array}{l l}{\tau(u_{i}-{\frac{\tau\kappa}{2}})}\\ {}\\ {\frac{u_{i}^{2}}{2\kappa}}\\ {}\\ {(\tau-1)[u_{i}-{\frac{(\tau-1)\kappa}{2}}]}\end{array}\right.$$
) if ui *> τκ,*
if $u_i>\tau\kappa$,  if $u_i\in[(\tau-1)\kappa,\tau\kappa]$,  if $u_i<(\tau-1)\kappa$. 
2κif ui ∈ [(τ − 1)*κ, τκ*],
$$(34)$$

Similar to Lτ,c(ui), we can derive the following closed-form solution of Lτ,κ(ui),

$${\hat{u}}_{j}={\left\{\begin{array}{l l}{v_{j}-{\frac{\tau}{\mu}},}&{{\mathrm{if~}}v_{j}\geq\tau\kappa+{\frac{\tau}{\mu}},}\\ {{\frac{c w_{i}}{c\mu+\tau}},}&{{\mathrm{if~}}(\tau-1)\kappa+{\frac{\tau-1}{\mu}}\leq v_{j}<\tau\kappa+{\frac{\tau}{\mu}},}\\ {v_{j}-{\frac{\tau-1}{\mu}},}&{{\mathrm{if~}}v_{j}<(\tau-1)\kappa+{\frac{\tau-1}{\mu}}}\end{array}\right.}$$
$$(35)$$
$$(36)$$

## A.2 Nonconvex Penalty

Recalling that the nonconvex penalty Pλ(|u|) = Pp j Pλ(|uj|), we can divide the optimization problem

$$\operatorname*{arg\,min}_{\mathbf{u}}\left\{P_{\lambda}(|\mathbf{u}|)+{\frac{\eta}{2}}\left\|\mathbf{u}-\mathbf{v}\right\|_{2}^{2}\right\}$$

into p independent univariate problems, which can be expressed as min
uj
Pλ(|uj|) + µ
$$u_{j}|\rangle+\frac{\mu}{2}\left(u_{j}-v_{j}\right)_{2}^{2}\right\},j$$
	, j =
1, 2*, . . . , p*. Let

$$\hat{u}_{j}=\arg\operatorname*{min}_{u_{j}}\left\{P_{\lambda}(|u_{j}|)+\frac{\eta}{2}\left(u_{j}-v_{j}\right)_{2}^{2}\right\}.$$
o. (36)

Because Pλ(|uj|) is a function of the absolute value of uj, and the subsequent term is a quadratic function (vjis a constant), we have sign(ˆuj ) = sign(vj ) and sign(vj )ˆuj ≥ 0. Let

$$(37)$$
$$\tilde{u}_{j}=\mathrm{sign}(v_{j})\hat{u}_{j},$$
$$(38)$$
u˜j = sign(vj )ˆuj, (37)
then we can convert (36) into the following optimization formula

$$\tilde{u}_{j}=\operatorname*{arg\,min}_{u_{j}\geq0}\left\{P_{\lambda}(u_{j})+\frac{\eta}{2}\left(u_{j}-|v_{j}|\right)_{2}^{2}\right\}.$$

Make the first derivative of the optimization formula above equal to 0, resulting in

$$\tilde{u}_{j}=|v_{j}|-\nabla P_{\lambda}(\tilde{u}_{j})/\eta\mathrm{~and~}\tilde{u}_{j}\geq0.$$
u˜j = |vj| − ∇Pλ(˜uj )/η and ˜uj ≥ 0. (39)
By (37), we have

$$\hat{u}_{j}=\mathrm{sign}(v_{j})\hat{u}_{j}.$$

uˆj = sign(vj )˜uj. (40)
The above two equations play a crucial role in deriving the closed-form solutions for the proximal operators of the (nonconvex) penalty term. Clearly, ˆujin (40) is the solution of the proximal operator.

- For Snet, we have

$$\nabla P_{\lambda}(\tilde{u}_{j})=\left\{\begin{array}{ll}\lambda_{1}+\lambda_{2}\tilde{u}_{j},&\mbox{if$\tilde{u}_{j}\leq\lambda_{1}$,}\\ \\ \frac{a\lambda_{1}-\tilde{u}_{j}}{a-1}+\lambda_{2}\tilde{u}_{j},&\mbox{if$\lambda_{1}<\tilde{u}_{j}<a\lambda_{1}$,}\\ \\ \lambda_{2}\tilde{u}_{j},&\mbox{if$\tilde{u}_{j}\geq a\lambda_{1}$.}\end{array}\right.\tag{41}$$
$$(39)$$
$$(40)$$

By substituting (41) into the equation (39), we can discuss the solutions of the equation (39) in different regions. For ˜uj ≤ λ1, the solution of equation (39) is hη|vj |−λ1 η+λ2 i
+
. For λ1 < u˜j *< aλ*1, the solution of equation (39) is h(a−1)η|vj |−aλ1
(a−1)(η+λ2)−1 i
+
. For ˜uj ≥ aλ1, the solution of equation (39) is η|vj | η+λ2
.

Note that ˆuj = sign(vj )˜uj and (a − 1)(η + λ2) > 1, it follows that

$$\hat{u}_{j}=\begin{cases}\text{sign}(v_{j})\cdot\left[\frac{\eta|v_{j}|-\lambda_{1}}{\eta+\lambda_{2}}\right]_{+},&\text{if}|v_{j}|\leq\frac{\lambda_{1}(1+\eta+\lambda_{2})}{\eta},\\ \text{sign}(v_{j})\cdot\left[\frac{(a-1)\eta(v_{j}|-\lambda_{1})}{(a-1)(\eta+\lambda_{2})-1}\right]_{+},&\text{if}\frac{\lambda_{1}(1+\eta+\lambda_{2})}{\eta}<|v_{j}|<\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta},\\ \frac{\eta v_{j}}{\eta+\lambda_{2}},&\text{if}|v_{j}|\geq\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta}.\end{cases}\tag{42}$$

- For Mnet, we have

$$\nabla P_{\lambda}(\tilde{u}_{j})=\left\{\begin{array}{ll}\lambda_{1}-\frac{\tilde{u}_{j}}{a}+\lambda_{2}\tilde{u}_{j},&\mbox{if$\tilde{u}_{j}\leq a\lambda_{1}$,}\\ \lambda_{2}\tilde{u}_{j},&\mbox{if$\tilde{u}_{j}>a\lambda_{1}$.}\end{array}\right.\tag{43}$$

By substituting (43) into the equation (39), we can discuss the solutions of the equation (39) in different regions. For ˜uj ≤ aλ1, the solution of equation (39) is [ aη|vj |−aλ1 a(η+λ2)−1
]+. For ˜uj *> aλ*1, the solution of equation (39) is η|vj | η+λ2
. Together with ˆuj = sign(vj )˜uj, we obtain

$${\hat{u}}_{j}={\left\{\begin{array}{l l}{\operatorname{sign}(v_{j})\cdot\left[{\frac{a\eta|v_{j}|-a\lambda_{1}}{a(\eta+\lambda_{2})-1}}\right]_{+},}\\ {\ }\\ {\ }\\ {\frac{\eta v_{j}}{\eta+\lambda_{2}},}\end{array}\right.}$$
$$\mathrm{if}\ |v_{j}|<{\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta}},$$  if $|v_{j}|\geq{\frac{a\lambda_{1}(\eta+\lambda_{2})}{\eta}}$. 
, if |vj| ≥ aλ1(η+λ2)
$$\left(44\right)$$

- For Cnet, we have

$$\nabla P_{\lambda}(\tilde{u}_{j})=\left\{\begin{array}{l}{{\lambda_{1}+\lambda_{2}\tilde{u}_{j},}}\\ {{}}\\ {{\lambda_{2}\tilde{u}_{j},}}\end{array}\right.$$
λ1 + λ2u˜j, if ˜uj ≤ a,
$$\mathrm{if~}\tilde{u}_{j}\leq a,$$  if $\tilde{u}_{j}>a$. 
λ2u˜j, if ˜uj *> a.*
$$(45)$$

By substituting (45) into the equation (39), we can discuss the solutions of the equation (39) in different regions. For ˜uj ≤ a, the solution of equation (39) is [ η|vj |−λ1 η+λ2]+. For ˜uj *> aλ*1, the solution of equation (39) is η|vj | η+λ2
. Together with ˆuj = sign(vj )˜uj, we have

$${\hat{u}}_{j}={\left\{\begin{array}{l l}{\operatorname{sign}(v_{j})\cdot\left[{\frac{\eta|v_{j}|-\lambda_{1}}{\eta+\lambda_{2}}}\right]_{+},}\\ {\ }\\ {\frac{\eta v_{j}}{\eta+\lambda_{2}},}\end{array}\right.}$$
if $|v_{j}|<\frac{a(\eta+\lambda_{2})}{\eta}$,  if $|v_{j}|\geq\frac{a(\eta+\lambda_{2})}{\eta}$.  
, if |vj| ≥ a(η+λ2)

## B.1 Proof Of Theorem 1

Looking back at (19) and (20), we have

$$\left[\mu\mathbf{X}^{\top}(\mathbf{X}\mathbf{\beta}^{k}+\mathbf{r}^{k}-\mathbf{y}-\mathbf{d}^{k}/\mu)\right]=\left[\mu\sum_{m=1}^{M}\mathbf{X}_{m}^{\top}(\mathbf{X}_{m}\mathbf{\beta}^{k}+\mathbf{r}_{m}^{k}-\mathbf{y}_{m}-\mathbf{d}_{m}^{k}/\mu)\right].$$

If the two algorithms have the same k-th iteration solution β k, r k, d k	, then we can derive the following equation from (18) and (24),

$$\hat{\beta}^{k+1}=\hat{\beta}^{k+1},k=0,1,2,3,\ldots.\tag{47}$$

Substituting the above equation into (16) and (23), along with (20), we can observe that rˆ
k+1 =
r˜
k+1 and dˆk+1 = d˜k+1. Therefore, we are able to conclude the result of Theorem 1.

## B.2 Proof Of Theorem 2

The proof of Theorem 2 mainly follows the proof of algorithm convergence presented in Guo et al.

(2016). However, there are two key differences in our proof. One is the inclusion of an additional quadratic linearization term in our algorithm. The other is our method does not rely on assumptions about the boundedness of iterative solutions, which is necessary for the convergence proof in Guo et al. (2016). Our proof can be divided into the following four steps,

- First, we prove that the augmented Lagrangian function that requires alternating iteration minimization is monotonically nonincreasing.

- Second, we demonstrate that the iterative solutions of our algorithm remain bounded throughout the entire iteration process.

- Third, we demonstrate that the iterative solutions of LADMM satisfy limk→+∞ ∥wk − wk+1∥2 = 0.

- Finally, we prove that the augmented Lagrangian function of all limit points of our LADMM algorithm is a constant.
Upon completing these four steps, following the approach outlined in Theorem 3.1 of Guo et al.

(2016), we can conclude that the iterative sequence produced by our algorithm is a Cauchy sequence.

Now, we start our proof. Because Theorem 1 has been proven to take the same η, the solutions of Algorithm 1 and Algorithm 2 are exactly the same. Therefore, we only need to discuss the nonparallel version of the LADMM algorithm. In terms of constrained optimization, we have

$$\operatorname*{min}_{\boldsymbol{\beta},\boldsymbol{r}}\quad\sum_{i=1}^{n}{\mathcal{L}}_{\tau,*}(r_{i})+P_{\lambda}(|{\boldsymbol{\beta}}|),$$  s.t. $\quad\boldsymbol{X}{\boldsymbol{\beta}}+\boldsymbol{r}=\boldsymbol{y}$.  
$$(48)$$

s.t. Xβ + r = y. (48)
In Guo et al. (2016) , they assumed that Lτ,∗ is a continuously differentiable function with Lipschitz continuous gradient ∇Lτ,∗. Here, we employ the following lemma to ensure that Lτ,c and Lτ,κ possess this property.

Lemma 1 (Proposition 2 in Mkhadri et al. (2017)) The smooth quantile Lτ,c and Lτ,κ are differentiable and have Lipschitz continuous first derivatives, that is,

$$\begin{array}{l}{{\|\nabla{\mathcal{L}}_{\tau,c}(u_{1})-\nabla{\mathcal{L}}_{\tau,c}(u_{2})\|_{2}\leq\frac{\operatorname*{max}\{\tau,1-\tau\}}{c}\|u_{1}-u_{2}\|_{2},}}\\ {{\|\nabla{\mathcal{L}}_{\tau,\kappa}(u_{1})-\nabla{\mathcal{L}}_{\tau,\kappa}(u_{2})\|_{2}\leq\frac{1}{\kappa}\|u_{1}-u_{2}\|_{2},}}\end{array}$$

where u1 and u2 *are two arbitrary real numbers.*
Problem (48) has the following augmented Lagrangian,

$$L_{\mu}(\mathbf{\beta},\mathbf{r},\mathbf{d})=\mathcal{L}_{\tau,*}(\mathbf{r})+P_{\lambda}(|\mathbf{\beta}|)-\mathbf{d}^{\top}(\mathbf{X}\mathbf{\beta}+\mathbf{r}-\mathbf{y})+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}+\mathbf{r}-\mathbf{y}\right\|_{2}^{2},\tag{49}$$

and the iterative steps of LADMM are as follows,

$$\left\{\begin{array}{ll}\beta^{k+1}&=\arg\min_{\beta}\left\{P_{\lambda}(|\beta|)+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}+\mathbf{r}^{k}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}+\frac{1}{2}\left\|\mathbf{\beta}-\mathbf{\beta}^{k}\right\|_{\mathbf{S}}^{2}\right\},\\ \mathbf{r}^{k+1}&=\arg\min_{r}\left\{\mathcal{L}_{r,r}(\mathbf{r})+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}\right\},\\ \mathbf{d}^{k+1}&=\mathbf{d}^{k}-\mu(\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k+1}-\mathbf{y}).\end{array}\right.\tag{50}$$
$$\mathrm{~i~}$$

We first demonstrate that the augmented Lagrangian function Lµ(β k, r k, d k) decreases as the number of iterations increases.

Lemma 2 *Let the sequence* wk = {β k, r k, d k} *be generated by the LADMM, then*

$$L_{\mu}(\mathbf{w}^{k+1})\leq L_{\mu}(\mathbf{w}^{k})+\left({\frac{n}{\mu\operatorname*{min}\{c^{2},\kappa^{2}\}}}-{\frac{\mu}{2}}\right)\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}.$$

Together with µ >
$$\cdot\ \frac{\sqrt{2n}}{\operatorname*{min}\{c,\kappa\}},\ \{L_{\mu}(\mathbf{w}^{k})\}_{k=1}^{\infty}$$
k=1 *is monotonically nonincreasing.*
Proof *The optimality conditions for the* k + 1*-iteration of LADMM is*

$$\begin{array}{l l}{{{\mathbf{0}}}}&{{\in\partial P_{\lambda}(|\partial^{k+1}|)-{\mathbf{X}}^{\top}{\mathbf{d}}^{k}+\mu{\mathbf{X}}^{\top}({\mathbf{X}}\partial^{k+1}+{\mathbf{r}}^{k}-{\mathbf{y}})+{\mathbf{S}}(\partial^{k+1}-\partial^{k}),}}\\ {{{\mathbf{0}}}}&{{=\nabla{\mathcal{L}}_{\tau*}({\mathbf{r}}^{k+1})-{\mathbf{d}}^{k}+\mu({\mathbf{X}}\beta^{k+1}+{\mathbf{r}}^{k+1}-{\mathbf{y}}),}}\\ {{{\mathbf{d}}^{k+1}={\mathbf{d}}^{k}-\mu({\mathbf{X}}\beta^{k+1}+{\mathbf{r}}^{k+1}-{\mathbf{y}}).}}\end{array}$$
$$\left(51\right)$$
$$(52)$$
$$\left(54\right)$$

Using the last equality and rearranging terms, we obtain

$$\left\{\begin{array}{l l}{{0}}&{{\in\partial P_{\lambda}(|\boldsymbol{\beta}^{k+1}|)-\boldsymbol{X}^{\top}\boldsymbol{d}^{k+1}+\mu\boldsymbol{X}^{\top}(\boldsymbol{r}^{k}-\boldsymbol{r}^{k+1})+\boldsymbol{S}(\boldsymbol{\beta}^{k+1}-\boldsymbol{\beta}^{k}),}}\\ {{}}&{{}}\\ {{\nabla{\mathcal{L}}_{\tau,*}(\boldsymbol{r}^{k+1})}}&{{=\boldsymbol{d}^{k+1}.}}\end{array}\right.$$
$$\left(53\right)$$

From the definition of the augmented Lagrangian function Lµ*, it follows that*

$$L_{\mu}(\mathbf{\beta}^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k+1})=L_{\mu}(\mathbf{\beta}^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k})+\langle\mathbf{d}^{k}-\mathbf{d}^{k+1},\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k+1}-\mathbf{y}\rangle$$ $$=L_{\mu}(\mathbf{\beta}^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k})+\frac{1}{\mu}\|\mathbf{d}^{k}-\mathbf{d}^{k+1}\|_{2}^{2},$$
, (54)
and

$$\begin{split}L_{\mu}(\boldsymbol{\beta}^{k+1},\boldsymbol{r}^{k},\boldsymbol{d}^{k})&-L_{\mu}(\boldsymbol{\beta}^{k+1},\boldsymbol{r}^{k+1},\boldsymbol{d}^{k})=(\mathcal{L}_{\tau,\tau}(\boldsymbol{r}^{k})-\mathcal{L}_{\tau,\star}(\boldsymbol{r}^{k+1}))-\langle\boldsymbol{d}^{k},\boldsymbol{r}^{k}-\boldsymbol{r}^{k+1}\rangle\\ &+\frac{\mu}{2}\left[\|\boldsymbol{X}\boldsymbol{\beta}^{k+1}+\boldsymbol{r}^{k}-\boldsymbol{y}\|_{2}^{2}-\|\boldsymbol{X}\boldsymbol{\beta}^{k+1}+\boldsymbol{r}^{k+1}-\boldsymbol{y}\|_{2}^{2}\right].\end{split}$$
_Since $\mathcal{L}_{\tau,*}$ is a convex function and $\mathbf{d}^{k+1}=\mathbf{d}^{k}-\mu(\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k+1}-\mathbf{y})$, we have:_
$$\left\{\begin{array}{l l}{{\mathcal{L}_{\tau,s}(\mathbf{r}^{k})-\mathcal{L}_{\tau,s}(\mathbf{r}^{k+1})\geq\langle\nabla\mathcal{L}_{\tau,s}(\mathbf{r}^{k+1}),\mathbf{r}^{k}-\mathbf{r}^{k+1}\rangle,}}\\ {{}}&{{}}\\ {{\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k}-\mathbf{y}=(\mathbf{d}^{k}-\mathbf{d}^{k+1})/\mu+(\mathbf{r}^{k}-\mathbf{r}^{k+1}),}}\\ {{}}&{{}}\\ {{\mathbf{X}\mathbf{\beta}^{k+1}+\mathbf{r}^{k+1}-\mathbf{y}=(\mathbf{d}^{k}-\mathbf{d}^{k+1})/\mu.}}\end{array}\right.$$

$$\left(55\right)$$
$$(56)$$

Note that ∇Lτ,∗(r k+1) = d k+1*, and inserting Equation (56) into Equation (55) yields*

$$L_{\mu}(\beta^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k})\leq L_{\mu}(\beta^{k+1},\mathbf{r}^{k},\mathbf{d}^{k})-\frac{\mu}{2}\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}.$$
$$\left(57\right)$$
$$(58)$$

Combining Equations (54) and (57), we get

$$L_{\mu}(\beta^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k+1})\leq L_{\mu}(\beta^{k+1},\mathbf{r}^{k},\mathbf{d}^{k})-\frac{\mu}{2}\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}+\frac{1}{\mu}\|\mathbf{d}^{k}-\mathbf{d}^{k+1}\|_{2}^{2}.$$
. (58)
From Lemma 1 and recalling that Lτ,∗(r) = Pn i=1 Lτ,∗(ri)*, we can derive*

$$\|\mathbf{d}^{k}-\mathbf{d}^{k+1}\|_{2}=\|\nabla{\mathcal{L}}_{\tau,*}(\mathbf{r}^{k})-\nabla{\mathcal{L}}_{\tau,*}(\mathbf{r}^{k+1})\|_{2}\leq{\frac{\sqrt{n}}{\operatorname*{min}\{c,\kappa\}}}\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}.$$

Consequently, we have

$$L_{\mu}(\beta^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k+1})\leq L_{\mu}(\beta^{k+1},\mathbf{r}^{k},\mathbf{d}^{k})+\left(\frac{n}{\mu\operatorname*{min}\{c^{2},\kappa^{2}\}}-\frac{\mu}{2}\right)\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}.$$
. (60)
Note that β k+1 *is the value that minimizes* Lµ(β, r k, d k)+ 12 β − β k 2 S
and S is a positive-definite matrix, then we get

$$(59)$$
$$(60)$$
$$L_{\mu}(\beta^{k+1},r^{k},d^{k})\leq L_{\mu}(\beta^{k},r^{k},d^{k}).$$
$$(61)$$
$$(62)$$
k). (61)
As a result,

$$L_{\mu}(\mathbf{\beta}^{k+1},\mathbf{r}^{k+1},\mathbf{d}^{k+1})\leq L_{\mu}(\mathbf{\beta}^{k},\mathbf{r}^{k},\mathbf{d}^{k})+\left(\frac{n}{\mu\operatorname*{min}\{c^{2},\kappa^{2}\}}-\frac{\mu}{2}\right)\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}.$$
. (62)
Since we assume that µ >
√2n min{c,κ}
, then we have n µ min{c 2,κ2} −
µ 2
< 0*, which implies that* {Lµ(wk)}
is monotonically nonincreasing. ■
Next, we will prove that the iterative sequences generated by LADMM are bounded.

Lemma 3 (a) With µ >
√2n min{c,κ}
and X⊤X > µIp(µ > 0), if Pλ(β) is the SCAD,MCP or Cappedℓ1*, then the sequence* wk = {β k, r k, d k} *is generated by LADMM is bounded.*

 $(b)\ With\ \mu>\frac{\sqrt{2n}}{\min(c\circ\xi)},\ if\ P_\lambda(|\beta^k|)\ is\ Mnet,\ Snet\ or\ Cnet,\ then\ the\ sequence\ \mathbf{w}^k=1\ is\ generated\ by\ LADMM\ is\ bounded$. 
{β k, r k, d k} *is generated by LADMM is bounded.*

$$L_{\mu}(\mathbf{w}^{0})\geq L_{\mu}(\mathbf{w}^{k})=\mathcal{L}_{rs}(\mathbf{r}^{k})+P_{\lambda}(|\mathbf{\beta}^{k}|)-\langle\mathbf{d}^{k},\mathbf{X}\mathbf{\beta}^{k}+\mathbf{r}^{k}-\mathbf{y}\rangle+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}^{k}+\mathbf{r}^{k}-\mathbf{y}\right\|_{2}^{2}\tag{63}$$ $$=\mathcal{L}_{rs}(\mathbf{r}^{k})+P_{\lambda}(|\mathbf{\beta}^{k}|)+\frac{\mu}{2}\left\|\mathbf{X}\mathbf{\beta}^{k}+\mathbf{r}^{k}-\mathbf{y}-\mathbf{d}^{k}/\mu\right\|_{2}^{2}-\frac{\left\|\mathbf{d}^{k}\right\|_{2}^{2}}{2\mu}.$$

Because the value of w0is given, Lµ(w0) *is a bounded constant. The first-order optimal condition* of the algorithm in (53) indicates that ∇Lτ,∗(r k) = d k.

(a) From the expressions of Pλ(|β k|) and ∇Pλ(|β k|), it can be seen that they are both positive and bounded functions. Then d k and Pλ(|β k|) −
∥d k∥
2 2 2µare bounded. Since Lµ(w0) is a bounded constant, both Lτ,∗(r k) ≥ 0 and µ 2 Xβk + r k − y − d k/µ 2 2
≥ 0 *are bounded.*
Note that if ∥r k∥2 → ∞, Lτ,∗(r k) → ∞*, then* r k must be bounded. Then, as long as X⊤X > µIp
, β k must be bounded. Consequently, wkis bounded.

(b) If Pλ(|β k|) *is Mnet, Snet or Cnet, then* Pλ(|β k|) −
∥d k∥
2 2 2µ→ ∞ *as long as* ∥β k∥2 → ∞.

Hence, β k*is bounded. For the same reason as (a), we can also conclude that both* Lτ,∗(r k) ≥ 0 and µ 2 Xβk + r k − y − d k/µ 2 2
≥ 0 *are bounded.* Lτ,∗(r k) *is bounded, indicating that* r kis bounded.

When β k, r k and µ 2 Xβk + r k − y − d k/µ 2 2 are all bounded, it can be deduced that d kis also bounded. Consequently, wk*is bounded.* ■
Now, we derive the conclusions limk→+∞ ∥wk − wk+1∥2 = 0, which is similar to Guan et al.

(2018). However, this conclusion only ensures that the difference between wk and wk+1 is close to 0, but it does not guarantee that wkconverges. Lemma 4 *Let the sequence* wk = {β k, r k, d k} *be generated by LADMM, then*

$$\sum_{k=0}^{\infty}\|\mathbf{w}^{k}-\mathbf{w}^{k+1}\|_{2}^{2}<+\infty\,\,\,a n d\,\operatorname*{lim}_{k\rightarrow+\infty}\|\mathbf{w}^{k}-\mathbf{w}^{k+1}\|_{2}=0.$$

Proof *From Lemma 2 , we know* {Lµ(wk)}
+∞
k=1 is a monotonically nondecreasing sequence. Next, we will determine its lower bound to demonstrate that {Lµ(wk)}
+∞
k=1 *is convergent.*
Since {wk} is bounded, it has at least one cluster point. We assume w∗*to be an arbitrary* cluster point of {wk}. Let {wkj } represent the subsequence of {wk} that converges to w∗*, i.e.*
wkj → w∗. Since Lµ *is a continuous function and* {Lµ(wk)}
+∞
k=1 *a monotonically nondecreasing* sequence, then we have

$$L^{(j)}\geq L_{\mu}(\operatorname*{lim}_{j\to\infty}{\boldsymbol{w}}^{(j)})=L_{\mu}({\boldsymbol{w}})$$

Lµ(wkj) ≥ Lµ( limj→∞
wkj) = Lµ(w∗).

As a result, {Lµ(wkj )}
+∞
j=1 *has a lower bound, which, together with the fact that* {Lµ(wkj )}
+∞
j=1 is nonincreasing, means that {Lµ(wkj )}
+∞
j=1 converges to Lµ(w∗)*. Considering that* {Lµ(wk)}
+∞
k=1 is monotonically nonincreasing, it follows that Lµ(w∗) *also serves as the lower bound for* {Lµ(wk)}
+∞
k=1.

Thus, we can conclude that {Lµ(wk)}
+∞
k=1 converges to Lµ(w∗) and Lµ(wk) ≥ Lµ(w∗).

Rearranging terms of Equation (51) yields

$$\left(\frac{\mu}{2}-\frac{n}{\mu\operatorname*{min}\{c^{2},\kappa^{2}\}}\right)\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}\leq L_{\mu}(\mathbf{w}^{k})-L_{\mu}(\mathbf{w}^{k+1}),$$

and summing up for k = 0, . . . , +∞*, it follows*

$$\left(\frac{\mu}{2}-\frac{n}{\mu\operatorname*{min}\{c^{2},\kappa^{2}\}}\right)\sum_{k=0}^{+\infty}\|\mathbf{r}^{k}-\mathbf{r}^{k+1}\|_{2}^{2}\leq L_{\mu}(\mathbf{w}^{0})-L_{\mu}(\mathbf{w}^{*})<+\infty.$$

Since µ 2 −n µ min{c 2,κ2}
> 0*, we obtain* P+∞
k=0 ∥r k − r k+1∥
2 2 < +∞. Consequently, it follows from Equation (59) that P+∞
k=0 ∥d k − d k+1∥
2 2 < +∞. Hence, to complete the proof, we just need to prove that P+∞
k=0 ∥β k − β k+1∥
2 2 < +∞. For the m*-th local machine, we have*

$$\left\{\begin{array}{l l}{{\mathbf{d}_{m}^{k+1}=\mathbf{d}_{m}^{k}-\mu(\mathbf{X}_{m}\mathbf{\beta}^{k+1}+\mathbf{r}_{m}^{k+1}-\mathbf{y}_{m}),}}\\ {{}}\\ {{\mathbf{d}_{m}^{k}=\mathbf{d}_{m}^{k-1}-\mu(\mathbf{X}_{m}\mathbf{\beta}^{k}+\mathbf{r}_{m}^{k}-\mathbf{y}_{m}),}}\end{array}\right.$$

and make a difference between the above two equations to obtain

$$\mathbf{d}_{m}^{k+1}-\mathbf{d}_{m}^{k}=\mathbf{d}_{m}^{k}-\mathbf{d}_{m}^{k-1}-\mu\mathbf{X}_{m}(\mathbf{\beta}^{k+1}-\mathbf{\beta}^{k})-\mu(\mathbf{r}_{m}^{k+1}-\mathbf{r}_{m}^{k}).$$

It then follows that

$$\|\mu\mathbf{X}_{m}(\mathbf{\beta}^{k+1}-\mathbf{\beta}^{k})\|_{2}^{2}=\|(\mathbf{d}_{m}^{k}-\mathbf{d}_{m}^{k-1})-(\mathbf{d}_{m}^{k+1}-\mathbf{d}_{m}^{k})-\mu(\mathbf{r}_{m}^{k+1}-\mathbf{r}_{m}^{k})\|_{2}^{2}$$ $$\leq3(\|\mathbf{d}_{m}^{k}-\mathbf{d}_{m}^{k-1}\|_{2}^{2}+\|\mathbf{d}_{m}^{k+1}-\mathbf{d}_{m}^{k}\|_{2}^{2}+\|\mu(\mathbf{r}_{m}^{k+1}-\mathbf{r}_{m}^{k})\|_{2}^{2}).\tag{64}$$

Since X⊤
mXm > µIp*, we have*

$$\|\mu{\bf X}_{m}(\beta^{k+1}-\beta^{k})\|_{2}^{2}\geq\mu^{2}\underline{{{\mu}}}\|\beta^{k+1}-\beta^{k}\|_{2}^{2}.$$
. (65)
$$(65)$$
$$\sum_{k=0}^{+\infty}\|\beta^{k}-\beta^{k+1}\|_{2}^{2}<+\infty.$$

Since wk = {β k, r k, d k}*, we have established that*

$$\sum_{k=1}^{\infty}\|{\boldsymbol{w}}^{k}-{\boldsymbol{w}}^{k+1}\|_{2}^{2}\leq\infty,$$

which indicates that limk→+∞ ∥wk − wk+1∥2 = 0. ■
From Lemma 2, we know that wk has at least one limit point. Next, we will prove some properties about the limit points.

Lemma 5 Let S(w∞) denote the set of the limit points of {wk}, and C(w∗) denote the set of critical points of Lµ(w). S(w∞) ⊂ C(w∗), and Lµ(w) *is finite and constant on* S(w∞). Proof We say w∗is the critical point of Lµ(w)*, if it satisfies*

$$\left\{\begin{array}{l l}{{X^{\top}d^{*}}}&{{\in\partial P_{\lambda}(|\beta^{*}|),}}\\ {{d^{*}}}&{{=\nabla{\mathcal{L}}_{\tau,*}(r^{*}),}}\\ {{0=}}&{{X\beta^{*}+r^{*}-y.}}\end{array}\right.$$
$$(66)$$

Recalling the optimality conditions for the k + 1*-iteration of LADMM in (52), we get*

$$\left\{\begin{array}{l l}{{{\bf0}}}&{{\in\partial P_{\lambda}(|\beta^{k+1}|)-{\bf X}^{\top}{\mathbf d}^{k+1}+{\mathbf S}(\beta^{k+1}-\beta^{k}),}}\\ {{{\bf0}}}&{{=\nabla{\cal L}_{\tau,*}({\mathbf r}^{k+1})-{\mathbf d}^{k+1},}}\\ {{{\mathbf d}^{k+1}={\mathbf d}^{k}-\mu({\mathbf X}\beta^{k+1}+{\mathbf r}^{k+1}-{\mathbf y}).}}\end{array}\right.$$
$$(67)$$

For any limit point w∞*, from Lemma 4 and (67), we have*

$$\left\{\begin{array}{ll}\mathbf{X}^{\top}\mathbf{d}^{\infty}&\in\partial P_{\lambda}(|\mathbf{\beta}^{\infty}|),\\ \mathbf{d}^{\infty}&=\nabla\mathbf{\mathcal{L}}_{\tau,*}(\mathbf{r}^{\infty}),\\ \mathbf{0}&=\mathbf{X}\mathbf{\beta}^{\infty}+\mathbf{r}^{\infty}-\mathbf{y}.\end{array}\right.\tag{68}$$

As a consequence, S(w∞) ⊂ S(w∗). Note that Lµ(wk) *is nonincreasing and convergent, it follows* that Lµ(w) *is finite and constant on* S(w∞). ■
Now, we are ready to prove Theorem 2. Despite the LADMM algorithm having an additional term of 12 β − β k 2 S
compared to the ADMM algorithm in Guo et al. (2016), the convergence proof is similar to that of Theorem 3.1 in Guo et al. (2016). Following the same steps as their proof, we can conclude that

$$\sum_{k=0}^{+\infty}\|\mathbf{w}^{k+1}-\mathbf{w}^{k}\|_{2}<+\infty.\tag{1}$$
$$(69)$$

That is, {wk} is a Cauchy sequence and it converges. Together with Lemma 5, {wk} converges to a critical point of Lµ(w).

## C Supplementary Numerical Experiments C.1 Supplementary Experiments For Section 4.1

In this subsection, we analyze the performance of LADMM in comparison to other ADMM variants when solving quantile regression with the MCP (a = 3) penalty. Table 6 presents the results for the nonparallel version (M = 1), while Table 7 displays the results for the parallel version (M > 1). The results of Table 6 and Table 7 demonstrate that our proposed LADMM algorithm has significant advantages over existing algorithms when solving quantile regressions with MCP.

Table 6: Comparison of various ADMMs with MCP penalty of different data sizes.

(*n, p*) (30000,1000) (1000,30000)

τ = 0.3 P1 P2 AE Ite Time P1 P2 AE Ite Time

QPADM 100 100 0.013(0.01) 95.9(9.8) 34.67(5.7) 0 100 6.68(0.97) 500(0.0) 2013.4(59.4)

QPADMslack 100 100 0.042(0.02) 47.2(6.1) 38.72(5.3) 0 100 7.13(0.89) 226(13.8) 1234.8(36.7)

FSLADMM 100 100 0.015(0.03) 500(0.0) 161.32(10.9) 100 100 0.69(0.07) 500(0.0) 129.5(11.3)

LADMM 100 100 0.014(0.01) 39.5 (3.0) 31.87(3.9) 100 100 0.38(0.05) 123(10.2) 56.3(4.6)

τ = 0.5 P1 P2 AE Ite Time P1 P2 AE Ite Time

QPADM 0 100 0.011(0.01) 87.9(8.5) 29.58(5.1) 0 100 5.92(0.82) 500(0.0) 1967.5(60.1) QPADMslack 0 100 0.038(0.03) 41.7(5.5) 32.39(4.8) 0 100 7.24(0.78) 232(12.7) 1094.7(40.2) FSLADMM 0 100 0.015(0.04) 500(0.0) 148.95(9.7) 0 100 0.64(0.06) 500(0.0) 131.8(12.5)

LADMM 0 100 0.012(0.01) 35.2 (2.7) 28.59(3.5) 0 100 0.35(0.03) 119(9.1) 57.4(5.1)

τ = 0.7 P1 P2 AE Ite Time P1 P2 AE Ite Time

QPADM 100 100 0.016(0.02) 99.2(9.3) 38.54(6.1) 100 100 6.81(0.77) 500(0.0) 2123.7(58.9) QPADMslack 100 100 0.049(0.05) 48.5(5.7) 42.21(5.6) 100 100 6.93(0.72) 262(15.7) 1182.6(49.3) FSLADMM 100 100 0.021(0.04) 500(0.0) 157.17(9.9) 100 100 0.72(0.06) 500(0.0) 136.5(13.0)

LADMM 100 100 0.018(0.01) 40.8 (3.1) 30.27(3.2) 100 100 0.39(0.03) 130(9.9) 60.2(4.9)

* The meanings of the notations used in this table are as follows: P1 (%): proportion that x1 is selected; P2 (%): proportion that x6, x12, x15,

and x20 are selected; AE: absolute estimation error; Ite: number of iterations; Time (s): CPU running time. Numbers in the parentheses

represent the corresponding standard deviations, and the optimal solution is represented in bold.

| Table 7: Comparison of various parallel ADMMs with MCP penalty.                                                                                                                    |           |              |             |             |           |              |             |             |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|--------------|-------------|-------------|-----------|--------------|-------------|-------------|
| (n = 500000, p = 1000)                                                                                                                                                             | τ = 0.4   | τ = 0.5      |             |             |           |              |             |             |
| M = 5                                                                                                                                                                              | Nonzero   | AE           | Ite         | Time        | Nonzero   | AE           | Ite         | Time        |
| QPADM                                                                                                                                                                              | 30.8(2.8) | 0.048(0.005) | 492.9(39.6) | 204.7(25.7) | 25.7(2.2) | 0.043(0.004) | 495.9(39.7) | 212.6(30.2) |
| QPADMslack                                                                                                                                                                         | 28.1(3.1) | 0.045(0.006) | 335.1(26.8) | 127.2(16.5) | 24.1(1.8) | 0.042(0.005) | 347.2(45.1) | 135.2(15.9) |
| LADMM                                                                                                                                                                              | 5.3(0.3)  | 0.029(0.001) | 79.5 (4.2)  | 41.2(4.1)   | 4.1(0.07) | 0.024(0.001) | 82.6 (5.3)  | 39.7(3.8)   |
| M = 20                                                                                                                                                                             | Nonzero   | AE           | Ite         | Time        | Nonzero   | AE           | Ite         | Time        |
| QPADM                                                                                                                                                                              | 32.6(3.5) | 0.051(0.06)  | 500(0.0)    | 129.8(12.6) | 28.3(2.4) | 0.048(0.05)  | 500(0.0)    | 129.6(15.0) |
| QPADMslack                                                                                                                                                                         | 29.4(3.4) | 0.048(0.07)  | 341.4(35.2) | 62.9(8.5)   | 25.9(2.1) | 0.047(0.05)  | 402.3(51.5) | 72.9(7.8)   |
| LADMM                                                                                                                                                                              | 5.3(0.3)  | 0.029(0.001) | 80.4 (4.4)  | 28.5(3.2)   | 4.0(0.07) | 0.024(0.001) | 83.3 (5.4)  | 27.5(3.5)   |
| M = 100                                                                                                                                                                            | Nonzero   | AE           | Ite         | Time        | Nonzero   | AE           | Ite         | Time        |
| QPADM                                                                                                                                                                              | 35.1(4.0) | 0.076(0.08)  | 500(0.0)    | 48.54(4.1)  | 30.8(2.7) | 0.052(0.06)  | 500(0.0)    | 38.4(3.9)   |
| QPADMslack                                                                                                                                                                         | 32.7(3.8) | 0.069(0.06)  | 448.5(56.2) | 18.21(2.5)  | 28.6(3.2) | 0.049(0.06)  | 441.4(62.1) | 20.1(2.5)   |
| LADMM                                                                                                                                                                              | 5.3(0.3)  | 0.030(0.001) | 84.5 (4.7)  | 19.27(2.6)  | 4.1(0.07) | 0.025(0.001) | 84.9 (5.6)  | 20.7(2.2)   |
| * P1 and P2 are not presented in Table 7 because all methods have a value of 100 for these two metrics. The Nonzero, AE, and Ite of LADMM are not greatly affected by the M value. |           |              |             |             |           |              |             |             |

## C.2 Supplementary Experiments For Section 4.2

In this subsection, we compare the performance of LADMM and ILAMM in solving least squares regressions with MCP (a = 3) and Capped-ℓ1 (a = 3) when the errors follow the Lognormal distribution. Table 8 shows that our algorithm performs better than ILAMM in solving these two regression models.

MCP Capped-ℓ1

Algorithm (*n, p*) FP FN AE Time FP FN AE Time

(100,1000) 0 1 0.43(0.08) 8.6(0.9) 0 1 0.52(0.07) 9.1(1.0) (100,10000) 0 2 0.61(0.10) 164.2(10.6) 0 2 0.67(0.12) 157.3(9.8)

(1000,10000) 0 2 0.53(0.08) 252.5(21.9) 0 2 0.58(0.09) 283.8(27.5) (10000,10000) 0 0 0.09(0.02) 1846.8(138.6) 0 0 0.13(0.04) 2014.5(142.4)

| MCP         | Capped-ℓ1   |
|-------------|-------------|
| ILAMM LADMM |             |

Algorithm (*n, p*) FP FN AE Time FP FN AE Time

(100,1000) 0 0 0.44(0.04) 1.4(0.07) 0 0 0.39(0.02) 1.2(0.09)

(100,10000) 0 0 0.52(0.05) 7.6(1.12) 0 0 0.45(0.04) 5.5(1.01) (1000,10000) 0 0 0.48(0.07) 15.8(2.65) 0 0 0.41(0.05) 13.1(1.98) (10000,10000) 0 0 0.05(0.01) 35.7(5.48) 0 0 0.04(0.01) 25.5(4.70)

* False Positive (FP) refers to the number of variables with a coefficient of zero that are mistakenly included in the final model,

while False Negative (FN) refers to the number of variables with non-zero coefficients that are omitted from the model.

## C.3 Supplementary Experiments For Section 4.3

In this subsection, we compare the performance of LADMM and cdaSQR in solving smooth quantile regressions with Mnet (a = 3) penalty. Table 9 demonstrates the results. However, cdaSQR is unable to solve the Cnet (a = 3) penalty. Therefore, we solely present the results of LADMM in solving Cnet regression in Figure 6. Both the table and the figure illustrate the superiority of our algorithm.

| Table 9: Comparison of LADMM and cdaSQR with δ = 0.5 and τ = 0.5 cdaSQR LADMM   |              |      |            |             |            |      |            |            |            |
|---------------------------------------------------------------------------------|--------------|------|------------|-------------|------------|------|------------|------------|------------|
| Loss                                                                            | (n, p)       | FP   | FN         | AE          | Time       | FP   | FN         | AE         | Time       |
| (5000,500)                                                                      | 1.96         | 6.48 | 0.36(0.03) | 3.46(0.23)  | 0          | 0.08 | 0.37(0.02) | 3.72(0.29) |            |
| Lτ,c                                                                            | (10000,1000) | 2.10 | 7.21       | 0.48(0.05)  | 5.13(0.61) | 0    | 0.09       | 0.45(0.04) | 4.85(0.55) |
| (20000,2000)                                                                    | 3.08         | 9.59 | 0.62(0.07) | 24.36(3.28) | 0          | 0.10 | 0.53(0.06) | 19.82(2.7) |            |
| Loss                                                                            | (n, p)       | FP   | FN         | AE          | Time       | FP   | FN         | AE         | Time       |
| (5000,500)                                                                      | 2.01         | 6.07 | 0.39(0.02) | 4.12(0.32)  | 0          | 0.05 | 0.42(0.03) | 3.64(0.32) |            |
| Lτ,κ                                                                            | (10000,1000) | 2.54 | 7.42       | 0.51(0.06)  | 6.27(0.95) | 0    | 0.06       | 0.46(0.05) | 4.58(0.57) |
| (20000,2000)                                                                    | 2.92         | 9.43 | 0.64(0.08) | 26.72(3.73) | 0          | 0.08 | 0.57(0.06) | 21.36(2.9) |            |

![44_image_0.png](44_image_0.png)

![44_image_1.png](44_image_1.png)

## C.4 Supplementary Experiments For Section 5

In this subsection, we compare the performance of several parallel ADMM algorithms in solving MCP (a = 3) regressions using an online publicly available dataset. The results (M = 100) are presented in Table 10. The prediction error (PE) is calculated as follows: PE = 1 n*test* Pn*test* i=1 |yi−yˆi|, where n*test* = 4644 represents the size of the test set. The experimental results presented in Table 10 indicate that our LADMM algorithm exhibits competitive performance compared to other parallel algorithms when solving MCP (a = 3) regressions on this real dataset.

| Table 10: Analysis of the news popularity data under the MCP penalty.   |               |               |              |            |             |             |            |
|-------------------------------------------------------------------------|---------------|---------------|--------------|------------|-------------|-------------|------------|
| Algorithm                                                               | x14           | x27           | Nonzero      | PE         | Ite         | Time        |            |
| QRADM                                                                   | -0.023(0.003) | 0.056(0.004)  | 33.9(2.30)   | 0.20(0.01) | 230.2(44.3) | 3.62(0.48)  |            |
| τ = 0.5                                                                 | QRADMslack    | -0.020(0.001) | 0.052(0.002) | 35.1(1.95) | 0.20(0.01)  | 118.3(10.6) | 2.01(0.36) |
| LADMMρ                                                                  | -0.011(0.001) | 0.024(0.001)  | 12.3(0.66)   | 0.18(0.01) | 73.6(5.9)   | 1.11(0.21)  |            |
| LADMMLτ,c,δ=1                                                           | -0.013(0.001) | 0.026(0.002)  | 13.1(0.56)   | 0.19(0.01) | 71.5(6.1)   | 1.13(0.19)  |            |
| LADMMLτ,κ,δ=1                                                           | -0.011(0.001) | 0.023(0.001)  | 13.8(0.72)   | 0.19(0.01) | 80.2(6.3)   | 1.12(0.22)  |            |
| Algorithm                                                               | x14           | x27           | Nonzero      | FP         | Ite         | Time        |            |
| QRADM                                                                   | -0.138(0.013) | 0.317(0.009)  | 38.9(2.92)   | 0.24(0.01) | 500(0.00)   | 3.93(0.52)  |            |
| τ = 0.9                                                                 | QRADMslack    | -0.120(0.009) | 0.289(0.007) | 40.1(1.85) | 0.24(0.01)  | 472.3(51.6) | 2.56(0.37) |
| LADMMρ                                                                  | -0.043(0.002) | 0.123(0.004)  | 13.6(0.71)   | 0.21(0.01) | 66.8(7.2)   | 1.23(0.21)  |            |
| LADMMLτ,c,δ=1                                                           | -0.050(0.002) | 0.126(0.004)  | 13.9(0.69)   | 0.23(0.01) | 73.5(8.3)   | 0.95(0.21)  |            |
| LADMMLτ,κ,δ=1                                                           | -0.053(0.003) | 0.128(0.005)  | 14.2(0.80)   | 0.23(0.01) | 76.1(8.6)   | 0.23(0.25)  |            |
